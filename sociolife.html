
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SocioLife: Social Artificial Life</title>
    <!--
        SOCIOLIFE - Social Artificial Life Simulation
        
        Author: Nova Spivack
        Website: www.novaspivack.com
        License: Creative Commons Attribution-NonCommercial 4.0 International (CC BY-NC 4.0)
        License URL: https://creativecommons.org/licenses/by-nc/4.0/
        
        You are free to share and adapt this work for non-commercial purposes with proper attribution to Nova Spivack.
        
        BACKGROUND MUSIC ATTRIBUTION:
        "Life Ambient" by Serge Quadrado
        Source: Free Music Archive
        License: CC BY-NC-SA (Creative Commons Attribution-NonCommercial-ShareAlike)
        URL: https://www.novaspivack.com/wp-content/uploads/2025/11/Serge-Quadrado-Life-Ambient.mp3
        
        This work is licensed under CC BY-NC-SA 4.0
    -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #111827; color: #e5e7eb; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        canvas { display: block; cursor: crosshair; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        #zoom-control { position: fixed; right: 20px; top: 50%; transform: translateY(-50%); z-index: 100; pointer-events: auto; background: rgba(0, 0, 0, 0.7); padding: 15px 10px; border-radius: 8px; border: 1px solid rgba(255, 255, 255, 0.2); }
        #zoom-control label { display: block; color: white; font-size: 11px; text-align: center; margin-bottom: 8px; font-weight: bold; }
        #zoom-control input[type="range"] { writing-mode: vertical-lr; direction: rtl; width: 8px; height: 200px; }
        #zoom-value { display: block; color: #60a5fa; font-size: 10px; text-align: center; margin-top: 8px; font-family: monospace; }
        .panel { pointer-events: auto; background: rgba(17, 24, 39, 0.95); backdrop-filter: blur(4px); border: 1px solid #374151; }
        .stat-row { display: flex; justify-content: space-between; margin-bottom: 2px; font-size: 0.75rem; align-items: center;}
        .bar-container { width: 50px; height: 5px; background: #374151; border-radius: 3px; overflow: hidden; margin-left: 6px;}
        .bar-fill { height: 100%; transition: width 0.2s; }
        .dot { width: 8px; height: 8px; border-radius: 50%; display: inline-block; margin-right: 6px; }
        
        /* Custom Scrollbar for settings */
        .custom-scroll::-webkit-scrollbar { width: 6px; }
        .custom-scroll::-webkit-scrollbar-track { background: #1f2937; }
        .custom-scroll::-webkit-scrollbar-thumb { background: #4b5563; border-radius: 3px; }
        .custom-scroll::-webkit-scrollbar-thumb:hover { background: #6b7280; }
        .ui-control { pointer-events: auto; }
        
        input[type=range] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            background: transparent;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; height: 12px; width: 12px; border-radius: 50%; background: #3b82f6; cursor: pointer; margin-top: -4px;
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%; height: 4px; cursor: pointer; background: #374151; border-radius: 2px;
        }
        
        .active-tool { border-color: #ef4444 !important; background-color: #7f1d1d !important; box-shadow: 0 0 10px #ef4444; }
        .active-tool-monster { border-color: #a855f7 !important; background-color: #581c87 !important; box-shadow: 0 0 10px #a855f7; }
    </style>
</head>
<body>

    <!-- Canvas Layer -->
    <canvas id="simCanvas"></canvas>

    <!-- Zoom Control -->
    <div id="zoom-control">
        <label>ZOOM</label>
        <input type="range" id="zoom-slider" min="0.5" max="1.5" step="0.05" value="1.0" orient="vertical">
        <span id="zoom-value">100%</span>
    </div>

    <!-- UI Layer -->
    <div id="ui-layer" class="relative flex flex-col justify-between p-4">
        <div id="hud-collapsed-btn" class="hidden absolute top-4 right-4 z-30" style="pointer-events:auto;">
            <button onclick="toggleHUDPanel(true)" class="ui-control text-[10px] uppercase tracking-wider text-white bg-black/60 hover:bg-black/80 px-3 py-1 rounded-full shadow-lg border border-white/20">Show HUD</button>
        </div>
        
        <!-- Top Bar -->
        <div id="hud-panel" class="panel rounded-lg p-4 w-full max-w-7xl mx-auto flex flex-wrap gap-6 justify-between items-center shadow-lg z-10 relative">
            <div>
                <h1 class="text-xl font-bold text-blue-400 tracking-tight">SocioLife <span class="text-xs text-gray-400 font-normal">v31.3 (Stability)</span></h1>
                <div class="text-xs text-gray-400">Gen: <span id="gen-count" class="text-white">0</span> | Time: <span id="time-count">0</span></div>
                <div class="text-[10px] text-red-400 font-bold hidden" id="crisis-alert">‚ö†Ô∏è EXTINCTION RISK - REPRO RATE UP ‚ö†Ô∏è</div>
                <div class="text-[10px] text-green-400 font-bold hidden" id="tool-alert">‚ö†Ô∏è INFECTION TOOL ACTIVE - CLICK TO DROP ‚ö†Ô∏è</div>
                <div class="text-[10px] text-green-300 font-bold" id="status-alert">‚ú® Life Signs Healthy ‚ú®</div>
            </div>
            
            <div class="flex gap-4 text-sm">
                <div class="text-center">
                    <div class="text-gray-500 text-xs uppercase">Agents</div>
                    <div class="font-mono text-lg font-bold" id="pop-count">0</div>
                </div>
                <div class="text-center">
                    <div class="text-gray-500 text-xs uppercase text-green-500">Food</div>
                    <div class="font-mono text-lg" id="res-green">0</div>
                </div>
                <div class="text-center">
                    <div class="text-gray-500 text-xs uppercase text-yellow-500">Material</div>
                    <div class="font-mono text-lg" id="res-gold">0</div>
                </div>
                <div class="text-center">
                    <div class="text-gray-500 text-xs uppercase text-cyan-400">Treas</div>
                    <div class="font-mono text-lg" id="res-treasure">0</div>
                </div>
                <div class="text-center pl-4 border-l border-gray-700">
                    <div class="text-gray-500 text-xs uppercase text-red-500">Sick</div>
                    <div class="font-mono text-lg text-red-400" id="stat-infected">0</div>
                </div>
                <div class="text-center">
                    <div class="text-gray-500 text-xs uppercase text-blue-400">Immune</div>
                    <div class="font-mono text-lg text-blue-400" id="stat-immune">0</div>
                </div>
            </div>

            <div class="flex gap-2 items-center">
                <button onclick="sim.setTool('nest')" id="btn-nest" class="px-3 py-1 bg-orange-900/80 hover:bg-orange-700 rounded text-xs border border-orange-500 transition text-white font-bold">Place Nest</button>
                <button onclick="sim.setTool('boon')" id="btn-boon" class="px-3 py-1 bg-yellow-900/80 hover:bg-yellow-700 rounded text-xs border border-yellow-500 transition text-white font-bold">Place Boon</button>
                <button onclick="sim.setTool('infect')" id="btn-infect" class="px-3 py-1 bg-green-900/80 hover:bg-green-700 rounded text-xs border border-green-500 transition text-white font-bold">Place Germs</button>
                <button onclick="sim.setTool('monster')" id="btn-monster" class="px-3 py-1 bg-purple-900/80 hover:bg-purple-700 rounded text-xs border border-purple-500 transition text-white font-bold">Place Monster</button>
                <select id="agent-type-select" onchange="sim.setTool('agent-' + this.value)" class="px-2 py-1 bg-indigo-900/80 hover:bg-indigo-700 rounded text-xs border border-indigo-500 transition text-white font-bold">
                    <option value="">Place Agents...</option>
                    <option value="Soldier">Place Soldiers</option>
                    <option value="Farmer">Place Farmers</option>
                    <option value="Merchant">Place Merchants</option>
                    <option value="Diplomat">Place Diplomats</option>
                    <option value="Scientist">Place Scientists</option>
                    <option value="Artisan">Place Artisans</option>
                    <option value="Guardian">Place Guardians</option>
                    <option value="Raider">Place Raiders</option>
                    <option value="Gatherer">Place Gatherers</option>
                    <option value="Scout">Place Scouts</option>
                    <option value="Builder">Place Builders</option>
                    <option value="Miner">Place Miners</option>
                    <option value="Spy">Place Spies</option>
                    <option value="Technologist">Place Technologists</option>
                    <option value="Botanist">Place Botanists</option>
                    <option value="Teacher">Place Teachers</option>
                    <option value="Garbage Collector">Place Garbage Collectors</option>
                </select>
                <button onclick="sim.reset()" class="px-3 py-1 bg-red-900/50 hover:bg-red-700 rounded text-xs border border-red-700 transition">Reset</button>
                <button onclick="sim.togglePause()" class="px-3 py-1 bg-blue-900/50 hover:bg-blue-700 rounded text-xs border border-blue-700 transition" id="pause-btn">Pause</button>
                
                <!-- Sound Controls -->
                <div class="flex items-center gap-2 px-3 py-1 bg-gray-800/50 rounded text-xs border border-gray-600">
                    <label class="flex items-center gap-1 cursor-pointer">
                        <input type="checkbox" id="sound-toggle" onchange="sim.toggleSound(this.checked)" class="w-4 h-4">
                        <span class="text-white text-xs">üîä</span>
                    </label>
                    <input type="range" id="volume-slider" min="0" max="1" step="0.1" value="0.3" 
                           oninput="sim.updateVolume(this.value)" 
                           class="w-16 h-2" style="accent-color: #10b981;">
                    <span id="volume-display" class="text-white text-xs font-mono">30%</span>
                </div>
                
                <button onclick="sim.toggleSettings()" class="ml-2 p-1 text-gray-400 hover:text-white transition" title="Settings">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" />
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                    </svg>
                </button>
                <button onclick="sim.toggleAbout()" class="ml-2 px-3 py-1 bg-blue-900/70 border border-blue-500 rounded-lg shadow-lg text-white text-xs hover:bg-blue-800" title="About SocioLife">
                    About
                </button>
                <button onclick="toggleHUDPanel()" class="ui-control ml-2 px-3 py-1 text-[10px] uppercase tracking-wide text-gray-200 bg-white/10 border border-white/20 rounded-full shadow-sm hover:bg-white/20">Collapse HUD</button>
            </div>
        </div>

        <!-- About Modal -->
        <div id="about-modal" class="panel absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 p-6 rounded-xl hidden shadow-2xl w-96 md:w-[600px] z-50 border border-blue-900/50 max-h-[80vh] flex flex-col">
            <div class="flex justify-between items-center mb-4 border-b border-gray-700 pb-3">
                <div class="text-center flex-1">
                    <h2 class="text-2xl font-bold text-blue-400 mb-1">SocioLife</h2>
                    <p class="text-sm text-gray-400">by <a href="http://www.novaspivack.com" target="_blank" class="text-blue-300 hover:text-blue-200">Nova Spivack</a></p>
                    <p class="text-xs text-cyan-300 mt-1"><a href="http://www.novaspivack.com" target="_blank" class="hover:text-cyan-200">www.novaspivack.com</a></p>
                    <p class="text-[10px] text-gray-500 mt-2">
                        Licensed under <a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" class="text-cyan-400 hover:text-cyan-300">Creative Commons Attribution-NonCommercial 4.0 International (CC BY-NC 4.0)</a>
                    </p>
                    <p class="text-[10px] text-gray-600 mt-1">Non-Commercial Use with Attribution</p>
                </div>
                <button onclick="sim.toggleAbout()" class="text-gray-400 hover:text-white text-xl font-bold ml-4">&times;</button>
            </div>
            
            <div class="overflow-y-auto pr-2 custom-scroll flex-1">
                <div class="text-sm text-gray-300 space-y-3">
                    <p class="font-bold text-blue-300">About SocioLife</p>
                    <p>SocioLife is an advanced artificial life simulation exploring emergent social behaviors, tribal dynamics, economic systems, warfare, diplomacy, and technological evolution in a complex multi-agent ecosystem.</p>
                    
                    <p class="font-bold text-blue-300 mt-4">Game Mechanics</p>
                    
                    <p class="font-semibold text-cyan-300 mt-2 text-xs">Economic System</p>
                    <ul class="list-disc list-inside space-y-1 text-xs ml-2">
                        <li><strong>Commercial Bonds:</strong> Tribes form trade relationships (gold/yellow dashed lines) that provide mutual economic benefits. Both parties gain wealth from trade, with stronger bonds providing greater benefits. Commercial bonds increase resource production (food, materials, ore, treasure) and spawn more money-making roles (Merchants, Artisans, Miners, Builders, Farmers).</li>
                        <li><strong>Taxation:</strong> Tribes tax their populations on all forms of value (energy, wealth, and resources). Taxes are converted to what the tribe needs most - if a nest needs health, taxes convert to HP; otherwise they convert to wealth. This ensures tribes can sustain themselves through their populations' economic activity.</li>
                        <li><strong>Resource Value Scale:</strong> Resources have different values from least (Food) to most (Treasure). Higher-value resources provide more energy and wealth when collected. Agents prioritize gathering valuable resources.</li>
                        <li><strong>Population-Based Wealth:</strong> Nests generate wealth based on their population size and productive roles, creating a balanced economic system where larger, more productive tribes are naturally wealthier.</li>
                    </ul>
                    
                    <p class="font-semibold text-cyan-300 mt-2 text-xs">Diplomacy</p>
                    <ul class="list-disc list-inside space-y-1 text-xs ml-2">
                        <li><strong>Diplomatic Bonds:</strong> Tribes form alliances (yellow/gold lines) through Diplomats who visit other nests. Strong diplomatic bonds provide humanitarian aid - allies send wealth and HP to help struggling partners, but only if they can afford it without risking their own survival.</li>
                        <li><strong>Wartime Aggressive Diplomacy:</strong> When a tribe is at war, their Diplomats aggressively seek alliances with enemies of their opponent and neutral parties, forming strategic partnerships to strengthen their position.</li>
                        <li><strong>Reconstruction Aid:</strong> After a war, diplomatic partners of the winner receive a boon in resources and economy, rewarding alliance during conflict.</li>
                        <li><strong>Diplomatic Aid Conditions:</strong> Allies only provide aid if they are healthy, wealthy, not in too many wars, and the aid won't put their own nest at risk.</li>
                    </ul>
                    
                    <p class="font-semibold text-cyan-300 mt-2 text-xs">War System</p>
                    <ul class="list-disc list-inside space-y-1 text-xs ml-2">
                        <li><strong>War Bonds:</strong> Warring tribes are connected by angry red dashed bonds with animated particles moving both ways, clearly showing active conflicts.</li>
                        <li><strong>War Costs:</strong> Wars are expensive - both nests and agents consume significantly more energy during conflicts. Structural damage to nests increases with each active war, creating stacking penalties for multiple simultaneous conflicts.</li>
                        <li><strong>Spoils of War:</strong> When a nest is defeated, its wealth, resources, energy, and structural value (treasure) are divided among the winning tribes. If there are no war winners, all value is scattered widely around the nest location as random resources.</li>
                        <li><strong>Citizen Conversion:</strong> All citizens (agents) of a defeated tribe are converted to the winning tribe(s), distributed randomly among the victors.</li>
                        <li><strong>Post-War Reconstruction (Baby Boom):</strong> War winners experience a massive baby boom - their wealth doubles immediately, HP is restored, and they spawn agents at greatly increased rates for an extended period. During this time, they receive continuous wealth generation and resource spawning to support the larger population.</li>
                        <li><strong>War-Time Spawning:</strong> During war, nests spawn fighting roles (Soldiers, Raiders, Guardians) at greatly increased rates to support the conflict.</li>
                    </ul>
                    
                    <p class="font-semibold text-cyan-300 mt-2 text-xs">Agent Bonds</p>
                    <ul class="list-disc list-inside space-y-1 text-xs ml-2">
                        <li><strong>Elastic Bonds:</strong> Flexible white bonds between agents that allow movement and stretching. These represent friendships, alliances, and social connections.</li>
                        <li><strong>Rigid Bonds:</strong> Strong red-orange bonds (thicker lines) that are harder to break and provide stability bonuses. These represent deep commitments and family ties.</li>
                        <li><strong>Group Formation:</strong> Agents with multiple bonds can form stable groups that provide enhanced capabilities, combat bonuses, and shared resources.</li>
                    </ul>
                    
                    <p class="font-semibold text-cyan-300 mt-2 text-xs">Nest Survival</p>
                    <ul class="list-disc list-inside space-y-1 text-xs ml-2">
                        <li><strong>Dying Nest Recovery:</strong> When a nest is in distress (low HP or wealth), it activates emergency survival mechanisms: raises taxes from agents, spawns more resource-gathering workers, and directly produces resources to aid recovery.</li>
                        <li><strong>Structural Health:</strong> Nests have structural health that represents accumulated infrastructure. When a nest dies, this structural value becomes treasure distributed to winners or scattered as resources.</li>
                    </ul>
                    
                    <p class="font-bold text-blue-300 mt-4">Key Features</p>
                    <ul class="list-disc list-inside space-y-1 text-xs">
                        <li>Complex agent-based simulation with genetic inheritance and evolution</li>
                        <li>Multi-tribal societies with dynamic diplomatic and commercial relations</li>
                        <li>Technological progression through research trees and specialized roles</li>
                        <li>Specialized agent roles: soldiers, merchants, diplomats, artisans, scientists, farmers, miners, builders, and more</li>
                        <li>Food chain ecology with predators, prey, and grazers</li>
                        <li>Resource management with value-based economy (food to treasure scale)</li>
                        <li>Group agents: agents can form stable groups with enhanced capabilities</li>
                        <li>Nest system: tribes build and maintain nests that spawn agents and manage resources</li>
                    </ul>
                    
                    <p class="font-bold text-blue-300 mt-4">How to Use</p>
                    <ul class="list-disc list-inside space-y-1 text-xs">
                        <li>Click the canvas to spawn new agents at that location</li>
                        <li>Use the Infect Tool to introduce plagues (cataclysms) that spread disease</li>
                        <li>Spawn Monsters to disrupt civilizations and test defenses</li>
                        <li>Adjust settings in the Settings panel to explore different dynamics</li>
                        <li>Click agents to inspect their DNA, relationships, and status</li>
                        <li>Watch as tribes evolve, trade, form alliances, wage wars, and develop technology</li>
                        <li>Observe bonds: yellow for diplomacy, gold for commerce, red for war between nests; white/red-orange for agent bonds</li>
                        <li>Monitor the HUD for population, generation count, and other statistics</li>
                    </ul>
                    
                    <p class="font-bold text-blue-300 mt-4">Tips</p>
                    <ul class="list-disc list-inside space-y-1 text-xs">
                        <li>Increase birth rate if populations are declining too quickly</li>
                        <li>Adjust bonding rate to see different social structures and group formations</li>
                        <li>Change energy burn rate to affect survival pressure and population dynamics</li>
                        <li>Experiment with tech progression speeds to see how technology affects gameplay</li>
                        <li>Enable sound for audio feedback on key events (births, deaths, trades, diplomacy, wars)</li>
                        <li>Watch for wartime diplomacy: tribes at war will seek allies among enemies of their opponents</li>
                        <li>Economic bonds provide mutual benefits: both parties gain wealth from trade</li>
                        <li>War winners receive spoils, convert defeated citizens, and experience extended baby booms</li>
                        <li>Agents automatically eat food when they touch it if not at full energy</li>
                        <li>All resource types convert to useful value (energy or wealth) for agents, tribes, and nests</li>
                    </ul>
                    
                    <p class="font-bold text-blue-300 mt-4">Links</p>
                    <p class="text-xs">
                        Website: <a href="https://www.novaspivack.com" target="_blank" class="text-cyan-400 hover:text-cyan-300 underline">www.novaspivack.com</a><br>
                        GitHub: <a href="https://github.com/novaspivack" target="_blank" class="text-cyan-400 hover:text-cyan-300 underline">github.com/novaspivack</a>
                    </p>
                    
                    <p class="font-bold text-blue-300 mt-4">License</p>
                    <p class="text-xs">This work is licensed under the Creative Commons Attribution-NonCommercial 4.0 International License. You are free to share and adapt this work for non-commercial purposes with proper attribution to Nova Spivack.</p>
                    
                    <p class="text-xs text-gray-500 mt-4">¬© 2024 Nova Spivack. All rights reserved.</p>
                </div>
            </div>
        </div>

        <!-- Settings Modal -->
        <div id="settings-modal" class="panel absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 p-5 rounded-xl hidden shadow-2xl w-80 md:w-96 z-50 border border-blue-900/50">
            <div class="flex justify-between items-center mb-4 border-b border-gray-700 pb-2">
                <h2 class="text-lg font-bold text-white flex items-center gap-2">
                    <span class="w-2 h-2 bg-blue-500 rounded-full inline-block"></span> Global Controls
                </h2>
                <button onclick="sim.toggleSettings()" class="text-gray-400 hover:text-white text-xl font-bold">&times;</button>
            </div>
            
            <div class="space-y-4 max-h-[60vh] overflow-y-auto pr-2 custom-scroll" id="settings-content">
                <!-- Resource Controls -->
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Res Spawn Rate</span>
                        <span id="val-resSpawnRate" class="text-blue-400 font-mono">0.8</span>
                    </div>
                    <input type="range" min="0" max="1" step="0.05" oninput="sim.updateConfig('resSpawnRate', this.value)" id="in-resSpawnRate">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Food Spawn Rate</span>
                        <span id="val-foodSpawnRate" class="text-green-400 font-mono">0.6</span>
                    </div>
                    <input type="range" min="0" max="1" step="0.05" oninput="sim.updateConfig('foodSpawnRate', this.value)" id="in-foodSpawnRate">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Food Spawn Near Nests</span>
                        <span id="val-foodSpawnNearNestsRate" class="text-green-400 font-mono">0.1</span>
                    </div>
                    <input type="range" min="0" max="1" step="0.05" oninput="sim.updateConfig('foodSpawnNearNestsRate', this.value)" id="in-foodSpawnNearNestsRate">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Food Nutritional Value</span>
                        <span id="val-foodNutritionalValue" class="text-green-400 font-mono">1.0</span>
                    </div>
                    <input type="range" min="0.1" max="2.0" step="0.1" oninput="sim.updateConfig('foodNutritionalValue', this.value)" id="in-foodNutritionalValue">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Treasure Rate</span>
                        <span id="val-treasureSpawnRate" class="text-cyan-400 font-mono">0.005</span>
                    </div>
                    <input type="range" min="0" max="0.05" step="0.001" oninput="sim.updateConfig('treasureSpawnRate', this.value)" id="in-treasureSpawnRate">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Build Rate (Success %)</span>
                        <span id="val-buildRate" class="text-yellow-500 font-mono">1.0</span>
                    </div>
                    <input type="range" min="0" max="1" step="0.1" oninput="sim.updateConfig('buildRate', this.value)" id="in-buildRate">
                </div>

                <div class="border-t border-gray-700 my-2"></div>

                <!-- Social Controls -->
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Love Threshold</span>
                        <span id="val-loveThreshold" class="text-pink-400 font-mono">60</span>
                    </div>
                    <input type="range" min="0" max="100" step="5" oninput="sim.updateConfig('loveThreshold', this.value)" id="in-loveThreshold">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Hate Threshold</span>
                        <span id="val-hateThreshold" class="text-red-500 font-mono">-30</span>
                    </div>
                    <input type="range" min="-100" max="0" step="5" oninput="sim.updateConfig('hateThreshold', this.value)" id="in-hateThreshold">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Bonding Rate (Mult)</span>
                        <span id="val-bondingRate" class="text-white font-mono">3.7</span>
                    </div>
                    <input type="range" min="0" max="10" step="0.1" oninput="sim.updateConfig('bondingRate', this.value)" id="in-bondingRate">
                </div>
                 <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Bond Break Chance</span>
                        <span id="val-bondBreakRate" class="text-red-300 font-mono">0.0006</span>
                    </div>
                    <input type="range" min="0" max="0.01" step="0.0001" oninput="sim.updateConfig('bondBreakRate', this.value)" id="in-bondBreakRate">
                </div>

                <div class="border-t border-gray-700 my-2"></div>

                <!-- Pop Controls -->
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Population Cap</span>
                        <span id="val-popCap" class="text-blue-400 font-mono">170</span>
                    </div>
                    <input type="range" min="20" max="300" step="10" oninput="sim.updateConfig('popCap', this.value)" id="in-popCap">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Mate Cost (Energy)</span>
                        <span id="val-mateCost" class="text-blue-400 font-mono">30</span>
                    </div>
                    <input type="range" min="10" max="200" step="5" oninput="sim.updateConfig('mateCost', this.value)" id="in-mateCost">
                </div>
                <!-- Birth/Death Controls -->
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Birth Rate (Speed)</span>
                        <span id="val-birthRate" class="text-green-400 font-mono">5.4</span>
                    </div>
                    <input type="range" min="0.1" max="15.0" step="0.1" oninput="sim.updateConfig('birthRate', this.value)" id="in-birthRate">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Death Rate (Life %)</span>
                        <span id="val-deathRate" class="text-gray-400 font-mono">0.5</span>
                    </div>
                    <input type="range" min="0.1" max="3.0" step="0.1" oninput="sim.updateConfig('deathRate', this.value)" id="in-deathRate">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Baby Growth Rate</span>
                        <span id="val-babyGrowthRate" class="text-pink-300 font-mono">0.2</span>
                    </div>
                    <input type="range" min="0.05" max="1.0" step="0.05" oninput="sim.updateConfig('babyGrowthRate', this.value)" id="in-babyGrowthRate">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Energy Burn Rate</span>
                        <span id="val-energyBurnRate" class="text-orange-400 font-mono">0.03</span>
                    </div>
                    <input type="range" min="0.01" max="0.5" step="0.01" oninput="sim.updateConfig('energyBurnRate', this.value)" id="in-energyBurnRate">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Damage Rate (Combat)</span>
                        <span id="val-damageRate" class="text-red-400 font-mono">0.05</span>
                    </div>
                    <input type="range" min="0.01" max="0.5" step="0.01" oninput="sim.updateConfig('damageRate', this.value)" id="in-damageRate">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Tribal Tax Rate</span>
                        <span id="val-tribalTaxRate" class="text-yellow-400 font-mono">0.1</span>
                    </div>
                    <input type="range" min="0" max="0.5" step="0.01" oninput="sim.updateConfig('tribalTaxRate', this.value)" id="in-tribalTaxRate">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Group Agent Tax Premium</span>
                        <span id="val-groupAgentTaxPremium" class="text-yellow-400 font-mono">0.05</span>
                    </div>
                    <input type="range" min="0" max="0.2" step="0.01" oninput="sim.updateConfig('groupAgentTaxPremium', this.value)" id="in-groupAgentTaxPremium">
                </div>

                <div class="border-t border-gray-700 my-2"></div>

                <!-- Evolution Controls -->
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Mutation Rate</span>
                        <span id="val-mutationRate" class="text-purple-400 font-mono">0.25</span>
                    </div>
                    <input type="range" min="0" max="0.5" step="0.01" oninput="sim.updateConfig('mutationRate', this.value)" id="in-mutationRate">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Monster Lifespan</span>
                        <span id="val-monsterLifespan" class="text-purple-500 font-mono">2500</span>
                    </div>
                    <input type="range" min="500" max="10000" step="100" oninput="sim.updateConfig('monsterLifespan', this.value)" id="in-monsterLifespan">
                </div>
                
                <div class="text-[11px] font-bold text-gray-500 uppercase mt-3 mb-2 border-t border-gray-700 pt-2">Group Benefits</div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Range Bonus/Member</span>
                        <span id="val-groupRangeBonus" class="text-cyan-300 font-mono">0.02</span>
                    </div>
                    <input type="range" min="0" max="0.1" step="0.01" oninput="sim.updateConfig('groupRangeBonus', this.value)" id="in-groupRangeBonus">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Damage Bonus/Member</span>
                        <span id="val-groupDamageBonus" class="text-red-300 font-mono">0.03</span>
                    </div>
                    <input type="range" min="0" max="0.1" step="0.01" oninput="sim.updateConfig('groupDamageBonus', this.value)" id="in-groupDamageBonus">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Defense Bonus/Member</span>
                        <span id="val-groupDefenseBonus" class="text-blue-300 font-mono">0.03</span>
                    </div>
                    <input type="range" min="0" max="0.1" step="0.01" oninput="sim.updateConfig('groupDefenseBonus', this.value)" id="in-groupDefenseBonus">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Healing Bonus/Member</span>
                        <span id="val-groupHealingBonus" class="text-green-300 font-mono">0.02</span>
                    </div>
                    <input type="range" min="0" max="0.1" step="0.01" oninput="sim.updateConfig('groupHealingBonus', this.value)" id="in-groupHealingBonus">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Energy Cost/Member</span>
                        <span id="val-groupEnergyCost" class="text-yellow-300 font-mono">0.08</span>
                    </div>
                    <input type="range" min="0" max="0.2" step="0.005" oninput="sim.updateConfig('groupEnergyCost', this.value)" id="in-groupEnergyCost">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Group Agent Elastic Bond Max Length</span>
                        <span id="val-groupAgentElasticBondMaxLength" class="text-purple-300 font-mono">180</span>
                    </div>
                    <input type="range" min="100" max="300" step="10" oninput="sim.updateConfig('groupAgentElasticBondMaxLength', this.value)" id="in-groupAgentElasticBondMaxLength">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Group Agent Min Members</span>
                        <span id="val-groupAgentMinMembers" class="text-purple-300 font-mono">5</span>
                    </div>
                    <input type="range" min="3" max="10" step="1" oninput="sim.updateConfig('groupAgentMinMembers', this.value)" id="in-groupAgentMinMembers">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Group Agent Max Members</span>
                        <span id="val-groupAgentMaxMembers" class="text-purple-300 font-mono">7</span>
                    </div>
                    <input type="range" min="4" max="12" step="1" oninput="sim.updateConfig('groupAgentMaxMembers', this.value)" id="in-groupAgentMaxMembers">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Group Agent Min Age (frames)</span>
                        <span id="val-groupAgentMinAge" class="text-purple-300 font-mono">500</span>
                    </div>
                    <input type="range" min="500" max="5000" step="100" oninput="sim.updateConfig('groupAgentMinAge', this.value)" id="in-groupAgentMinAge">
                </div>
                
                <div class="text-[11px] font-bold text-gray-500 uppercase mt-3 mb-2 border-t border-gray-700 pt-2">Rigid Bonds</div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Rigid Bond Chance</span>
                        <span id="val-rigidBondChance" class="text-orange-300 font-mono">0.85</span>
                    </div>
                    <input type="range" min="0" max="1" step="0.05" oninput="sim.updateConfig('rigidBondChance', this.value)" id="in-rigidBondChance">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Rigid Bond Length</span>
                        <span id="val-rigidBondLength" class="text-red-300 font-mono">40</span>
                    </div>
                    <input type="range" min="20" max="100" step="5" oninput="sim.updateConfig('rigidBondLength', this.value)" id="in-rigidBondLength">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Rigid Bond Stiffness</span>
                        <span id="val-rigidBondStiffness" class="text-red-300 font-mono">0.15</span>
                    </div>
                    <input type="range" min="0.05" max="0.5" step="0.01" oninput="sim.updateConfig('rigidBondStiffness', this.value)" id="in-rigidBondStiffness">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Formation Bonus</span>
                        <span id="val-rigidBondFormationBonus" class="text-green-300 font-mono">1.5</span>
                    </div>
                    <input type="range" min="0" max="5" step="0.1" oninput="sim.updateConfig('rigidBondFormationBonus', this.value)" id="in-rigidBondFormationBonus">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Break Resistance</span>
                        <span id="val-rigidBondBreakResistance" class="text-blue-300 font-mono">0.5</span>
                    </div>
                    <input type="range" min="0" max="1" step="0.05" oninput="sim.updateConfig('rigidBondBreakResistance', this.value)" id="in-rigidBondBreakResistance">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Nest Bond Penalty</span>
                        <span id="val-nestBondedPenalty" class="text-yellow-300 font-mono">0.3</span>
                    </div>
                    <input type="range" min="0" max="1" step="0.05" oninput="sim.updateConfig('nestBondedPenalty', this.value)" id="in-nestBondedPenalty">
                </div>
                
                <div class="text-[11px] font-bold text-gray-500 uppercase mt-3 mb-2 border-t border-gray-700 pt-2">Nest Splitting</div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Split Population</span>
                        <span id="val-nestSplitPopulation" class="text-cyan-300 font-mono">35</span>
                    </div>
                    <input type="range" min="15" max="100" step="5" oninput="sim.updateConfig('nestSplitPopulation', this.value)" id="in-nestSplitPopulation">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Parent Nest Keeps</span>
                        <span id="val-nestSplitParentRetain" class="text-cyan-300 font-mono">70%</span>
                    </div>
                    <input type="range" min="0.5" max="0.9" step="0.05" oninput="sim.updateConfig('nestSplitParentRetain', this.value)" id="in-nestSplitParentRetain">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Split Max Radius</span>
                        <span id="val-nestSplitMaxRadius" class="text-cyan-300 font-mono">105</span>
                    </div>
                    <input type="range" min="70" max="300" step="5" oninput="sim.updateConfig('nestSplitMaxRadius', this.value)" id="in-nestSplitMaxRadius">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Nest HP Decay Rate</span>
                        <span id="val-nestHpDecayRate" class="text-red-300 font-mono">0.02</span>
                    </div>
                    <input type="range" min="0" max="0.1" step="0.001" oninput="sim.updateConfig('nestHpDecayRate', this.value)" id="in-nestHpDecayRate">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Nest Agent Spawn Rate</span>
                        <span id="val-nestAgentSpawnRate" class="text-green-300 font-mono">0.02</span>
                    </div>
                    <input type="range" min="0" max="0.2" step="0.001" oninput="sim.updateConfig('nestAgentSpawnRate', this.value)" id="in-nestAgentSpawnRate">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Merge Distance</span>
                        <span id="val-nestMergeDistance" class="text-cyan-300 font-mono">80</span>
                    </div>
                    <input type="range" min="40" max="200" step="10" oninput="sim.updateConfig('nestMergeDistance', this.value)" id="in-nestMergeDistance">
                </div>
                
                <div class="text-[11px] font-bold text-gray-500 uppercase mt-3 mb-2 border-t border-gray-700 pt-2">Nest Drift</div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Base Drift Rate</span>
                        <span id="val-nestBaseDriftRate" class="text-purple-300 font-mono">1.2</span>
                    </div>
                    <input type="range" min="0" max="3" step="0.1" oninput="sim.updateConfig('nestBaseDriftRate', this.value)" id="in-nestBaseDriftRate">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Diplomatic Drift x</span>
                        <span id="val-nestDiplomaticDriftMultiplier" class="text-yellow-300 font-mono">2.0</span>
                    </div>
                    <input type="range" min="1" max="5" step="0.5" oninput="sim.updateConfig('nestDiplomaticDriftMultiplier', this.value)" id="in-nestDiplomaticDriftMultiplier">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Commercial Drift x</span>
                        <span id="val-nestCommercialDriftMultiplier" class="text-cyan-300 font-mono">2.5</span>
                    </div>
                    <input type="range" min="1" max="5" step="0.5" oninput="sim.updateConfig('nestCommercialDriftMultiplier', this.value)" id="in-nestCommercialDriftMultiplier">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Friendly Nest Attraction</span>
                        <span id="val-nestFriendlyAttractionStrength" class="text-green-300 font-mono">0.02</span>
                    </div>
                    <input type="range" min="0" max="0.1" step="0.01" oninput="sim.updateConfig('nestFriendlyAttractionStrength', this.value)" id="in-nestFriendlyAttractionStrength">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Enemy Nest Repulsion</span>
                        <span id="val-nestEnemyRepulsionStrength" class="text-red-300 font-mono">0.05</span>
                    </div>
                    <input type="range" min="0" max="0.15" step="0.01" oninput="sim.updateConfig('nestEnemyRepulsionStrength', this.value)" id="in-nestEnemyRepulsionStrength">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Unaffiliated Group Drift</span>
                        <span id="val-nestUnaffiliatedDriftRate" class="text-gray-300 font-mono">0.01</span>
                    </div>
                    <input type="range" min="0" max="0.05" step="0.005" oninput="sim.updateConfig('nestUnaffiliatedDriftRate', this.value)" id="in-nestUnaffiliatedDriftRate">
                </div>
                
                <div class="text-[11px] font-bold text-gray-500 uppercase mt-3 mb-2 border-t border-gray-700 pt-2">Social Attraction</div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Kin Attraction</span>
                        <span id="val-kinAttractionStrength" class="text-pink-300 font-mono">0.3</span>
                    </div>
                    <input type="range" min="0" max="1" step="0.05" oninput="sim.updateConfig('kinAttractionStrength', this.value)" id="in-kinAttractionStrength">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Tribe Attraction</span>
                        <span id="val-tribeAttractionStrength" class="text-blue-300 font-mono">0.15</span>
                    </div>
                    <input type="range" min="0" max="1" step="0.05" oninput="sim.updateConfig('tribeAttractionStrength', this.value)" id="in-tribeAttractionStrength">
                </div>
                
                <div class="text-[11px] font-bold text-gray-500 uppercase mt-3 mb-2 border-t border-gray-700 pt-2">Reproduction Dynamics</div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Min Density</span>
                        <span id="val-reproductionDensityMin" class="text-yellow-300 font-mono">0.2</span>
                    </div>
                    <input type="range" min="0.05" max="0.5" step="0.05" oninput="sim.updateConfig('reproductionDensityMin', this.value)" id="in-reproductionDensityMin">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Optimal Density</span>
                        <span id="val-reproductionDensityOptimal" class="text-green-300 font-mono">0.5</span>
                    </div>
                    <input type="range" min="0.3" max="0.8" step="0.05" oninput="sim.updateConfig('reproductionDensityOptimal', this.value)" id="in-reproductionDensityOptimal">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Max Density</span>
                        <span id="val-reproductionDensityMax" class="text-red-300 font-mono">0.9</span>
                    </div>
                    <input type="range" min="0.7" max="1.0" step="0.05" oninput="sim.updateConfig('reproductionDensityMax', this.value)" id="in-reproductionDensityMax">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Max Birth Multiplier</span>
                        <span id="val-reproductionMaxMultiplier" class="text-cyan-300 font-mono">2.0</span>
                    </div>
                    <input type="range" min="1.0" max="5.0" step="0.1" oninput="sim.updateConfig('reproductionMaxMultiplier', this.value)" id="in-reproductionMaxMultiplier">
                </div>
                
                <div class="text-[11px] font-bold text-gray-500 uppercase mt-3 mb-2 border-t border-gray-700 pt-2">Movement Patterns</div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Roaming Strength</span>
                        <span id="val-roamingGeneStrength" class="text-purple-300 font-mono">1.0</span>
                    </div>
                    <input type="range" min="0" max="2" step="0.1" oninput="sim.updateConfig('roamingGeneStrength', this.value)" id="in-roamingGeneStrength">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Nest Return Min</span>
                        <span id="val-nestReturnFrequencyMin" class="text-orange-300 font-mono">200</span>
                    </div>
                    <input type="range" min="50" max="500" step="50" oninput="sim.updateConfig('nestReturnFrequencyMin', this.value)" id="in-nestReturnFrequencyMin">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Nest Return Max</span>
                        <span id="val-nestReturnFrequencyMax" class="text-pink-300 font-mono">1000</span>
                    </div>
                    <input type="range" min="500" max="2000" step="100" oninput="sim.updateConfig('nestReturnFrequencyMax', this.value)" id="in-nestReturnFrequencyMax">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Leader Max Wander Radius</span>
                        <span id="val-leaderMaxWanderRadius" class="text-purple-300 font-mono">120</span>
                    </div>
                    <input type="range" min="50" max="300" step="10" oninput="sim.updateConfig('leaderMaxWanderRadius', this.value)" id="in-leaderMaxWanderRadius">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Oscillation Strength</span>
                        <span id="val-oscillatingMovementStrength" class="text-indigo-300 font-mono">0.8</span>
                    </div>
                    <input type="range" min="0" max="2" step="0.1" oninput="sim.updateConfig('oscillatingMovementStrength', this.value)" id="in-oscillatingMovementStrength">
                </div>
                
                <div class="text-[11px] font-bold text-gray-500 uppercase mt-3 mb-2 border-t border-gray-700 pt-2">Food Decay System</div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Food Decay Rate</span>
                        <span id="val-foodDecayRate" class="text-red-300 font-mono">0.0005</span>
                    </div>
                    <input type="range" min="0" max="0.005" step="0.0001" oninput="sim.updateConfig('foodDecayRate', this.value)" id="in-foodDecayRate">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Botanist Fertilize Rate</span>
                        <span id="val-botanistFertilizeRate" class="text-green-300 font-mono">0.05</span>
                    </div>
                    <input type="range" min="0" max="0.2" step="0.01" oninput="sim.updateConfig('botanistFertilizeRate', this.value)" id="in-botanistFertilizeRate">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Botanist Fertilize Radius</span>
                        <span id="val-botanistFertilizeRadius" class="text-lime-300 font-mono">30</span>
                    </div>
                    <input type="range" min="10" max="100" step="5" oninput="sim.updateConfig('botanistFertilizeRadius', this.value)" id="in-botanistFertilizeRadius">
                </div>
                
                <div class="text-[11px] font-bold text-gray-500 uppercase mt-3 mb-2 border-t border-gray-700 pt-2">Farmer & Food Chain</div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Farmer Spawn Grazer Rate</span>
                        <span id="val-farmerSpawnGrazerRate" class="text-lime-300 font-mono">0.01</span>
                    </div>
                    <input type="range" min="0" max="0.05" step="0.001" oninput="sim.updateConfig('farmerSpawnGrazerRate', this.value)" id="in-farmerSpawnGrazerRate">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Farmer Health Threshold</span>
                        <span id="val-farmerSpawnGrazerHealthThreshold" class="text-green-300 font-mono">0.7</span>
                    </div>
                    <input type="range" min="0.3" max="1.0" step="0.05" oninput="sim.updateConfig('farmerSpawnGrazerHealthThreshold', this.value)" id="in-farmerSpawnGrazerHealthThreshold">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Prey Asexual Repro Rate</span>
                        <span id="val-preyAsexualReproductionRate" class="text-yellow-300 font-mono">0.005</span>
                    </div>
                    <input type="range" min="0" max="0.02" step="0.001" oninput="sim.updateConfig('preyAsexualReproductionRate', this.value)" id="in-preyAsexualReproductionRate">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Prey Repro Radius</span>
                        <span id="val-preyAsexualReproductionRadius" class="text-orange-300 font-mono">80</span>
                    </div>
                    <input type="range" min="30" max="150" step="10" oninput="sim.updateConfig('preyAsexualReproductionRadius', this.value)" id="in-preyAsexualReproductionRadius">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Predator Spawn Rate</span>
                        <span id="val-predatorSpawnRate" class="text-red-300 font-mono">0.005</span>
                    </div>
                    <input type="range" min="0" max="0.02" step="0.001" oninput="sim.updateConfig('predatorSpawnRate', this.value)" id="in-predatorSpawnRate">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Prey Spawn Rate (groups)</span>
                        <span id="val-preySpawnRate" class="text-yellow-300 font-mono">0.01</span>
                    </div>
                    <input type="range" min="0" max="0.03" step="0.001" oninput="sim.updateConfig('preySpawnRate', this.value)" id="in-preySpawnRate">
                </div>
                
                <div class="text-[11px] font-bold text-gray-500 uppercase mt-3 mb-2 border-t border-gray-700 pt-2">Diplomacy & Trade</div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Diplomat Spawn Distance</span>
                        <span id="val-diplomatSpawnDistance" class="text-yellow-300 font-mono">220</span>
                    </div>
                    <input type="range" min="100" max="500" step="20" oninput="sim.updateConfig('diplomatSpawnDistance', this.value)" id="in-diplomatSpawnDistance">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Merchant Spawn Distance</span>
                        <span id="val-merchantSpawnDistance" class="text-cyan-300 font-mono">180</span>
                    </div>
                    <input type="range" min="100" max="400" step="20" oninput="sim.updateConfig('merchantSpawnDistance', this.value)" id="in-merchantSpawnDistance">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Merchant Trade Frequency</span>
                        <span id="val-merchantTradeFrequency" class="text-green-300 font-mono">0.02</span>
                    </div>
                    <input type="range" min="0.005" max="0.1" step="0.005" oninput="sim.updateConfig('merchantTradeFrequency', this.value)" id="in-merchantTradeFrequency">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Min Alliance for Trade</span>
                        <span id="val-minAllianceForTrade" class="text-pink-300 font-mono">20</span>
                    </div>
                    <input type="range" min="0" max="50" step="5" oninput="sim.updateConfig('minAllianceForTrade', this.value)" id="in-minAllianceForTrade">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Diplomat Negotiation Rate</span>
                        <span id="val-diplomatNegotiationFrequency" class="text-yellow-300 font-mono">0.15</span>
                    </div>
                    <input type="range" min="0.01" max="0.3" step="0.01" oninput="sim.updateConfig('diplomatNegotiationFrequency', this.value)" id="in-diplomatNegotiationFrequency">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Merchant Trade Rate</span>
                        <span id="val-merchantTradeFrequency" class="text-cyan-300 font-mono">0.08</span>
                    </div>
                    <input type="range" min="0.01" max="0.2" step="0.01" oninput="sim.updateConfig('merchantTradeFrequency', this.value)" id="in-merchantTradeFrequency">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Diplomatic Bond Growth</span>
                        <span id="val-diplomaticBondGrowth" class="text-yellow-300 font-mono">2.0</span>
                    </div>
                    <input type="range" min="0.1" max="5.0" step="0.1" oninput="sim.updateConfig('diplomaticBondGrowth', this.value)" id="in-diplomaticBondGrowth">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Commercial Bond Growth</span>
                        <span id="val-commercialBondGrowth" class="text-cyan-300 font-mono">3.0</span>
                    </div>
                    <input type="range" min="0.1" max="6.0" step="0.1" oninput="sim.updateConfig('commercialBondGrowth', this.value)" id="in-commercialBondGrowth">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Bond Decay Rate</span>
                        <span id="val-bondDecayRate" class="text-red-300 font-mono">0.002</span>
                    </div>
                    <input type="range" min="0.001" max="0.02" step="0.001" oninput="sim.updateConfig('bondDecayRate', this.value)" id="in-bondDecayRate">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Bond Reinforcement Threshold</span>
                        <span id="val-bondReinforcementThreshold" class="text-green-300 font-mono">30</span>
                    </div>
                    <input type="range" min="10" max="60" step="5" oninput="sim.updateConfig('bondReinforcementThreshold', this.value)" id="in-bondReinforcementThreshold">
                </div>
                
                <div class="text-[11px] font-bold text-gray-500 uppercase mt-3 mb-2 border-t border-gray-700 pt-2">Audio</div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>SFX Volume</span>
                        <span id="val-sfxVolume" class="text-green-300 font-mono">0.3</span>
                    </div>
                    <input type="range" min="0" max="1" step="0.1" oninput="sim.updateConfig('sfxVolume', this.value)" id="in-sfxVolume">
                </div>
            </div>

            <div class="mt-4 pt-2 border-t border-gray-700 flex justify-between items-center gap-2">
                <span class="text-[10px] text-gray-500 italic">Changes apply immediately</span>
                <div class="flex gap-2">
                    <button onclick="sim.copySettingsToClipboard()" class="text-xs text-blue-400 hover:text-blue-300 px-2 py-1 rounded border border-gray-700 hover:border-blue-500 transition">üìã Copy Settings</button>
                    <button onclick="sim.restoreDefaults()" class="text-xs text-red-400 hover:text-red-300 px-2 py-1 rounded border border-gray-700 hover:border-red-500 transition">Reset Defaults</button>
                </div>
            </div>
        </div>

        <!-- Bottom Layer -->
        <div class="flex justify-between items-end mt-auto w-full">
            
            <!-- Agent Inspector -->
            <div id="inspector" class="panel rounded-lg p-4 w-80 hidden shadow-xl border-l-4 border-l-blue-500">
                <div class="flex justify-between items-start border-b border-gray-700 pb-2 mb-2">
                    <div>
                        <h2 class="text-sm font-bold text-white">Agent DNA & Mind</h2>
                        <div class="text-xs text-gray-400 font-mono" id="ins-id">ID</div>
                        <div class="flex gap-2 mt-1">
                            <div class="text-xs font-bold px-1 rounded text-black" id="ins-role-tag">ROLE</div>
                            <div class="text-xs font-bold px-1 rounded border border-gray-500" id="ins-tribe-tag">TRIBE</div>
                        </div>
                        <div class="text-[10px] mt-1 text-yellow-300" id="ins-wealth">Wealth: 0</div>
                        <div class="text-[10px] font-bold text-orange-400" id="ins-hero" style="display:none;">‚òÖ HERO ‚òÖ</div>
                    </div>
                    <div class="text-right">
                        <div class="text-xs text-gray-400">State</div>
                        <div id="ins-state" class="text-xs font-bold text-yellow-400 uppercase tracking-wider">IDLE</div>
                        <div id="ins-health-status" class="text-[10px] font-bold mt-1"></div>
                        <div id="ins-bond-status" class="text-[10px] font-bold text-pink-400 mt-1"></div>
                    </div>
                </div>
                <div class="grid grid-cols-2 gap-x-4 gap-y-1 mb-3">
                    <div class="stat-row"><span>Energy</span> <div class="bar-container"><div id="ins-energy" class="bar-fill bg-green-500"></div></div></div>
                    <div class="stat-row"><span>Health</span> <div class="bar-container"><div id="ins-health" class="bar-fill bg-red-500"></div></div></div>
                    <div class="stat-row"><span>Lifespan</span> <div class="bar-container"><div id="ins-life" class="bar-fill bg-yellow-200"></div></div></div>
                    <div class="stat-row"><span>Lovers</span> <span id="ins-lovers" class="text-pink-400 font-mono text-xs">0</span></div>
                    <div class="stat-row"><span>Carrying</span> <span id="ins-inv" class="text-yellow-400 font-mono text-xs">Empty</span></div>
                    <div class="stat-row"><span>Charisma</span> <span id="ins-charisma" class="text-cyan-400 font-mono text-xs">0</span></div>
                    <div class="stat-row"><span>Age</span> <span id="ins-age" class="text-gray-400 font-mono text-xs">0</span></div>
                </div>
                <div class="text-[10px] font-bold text-gray-500 uppercase mt-2 mb-1">DNA Traits</div>
                <div class="grid grid-cols-2 gap-x-4 gap-y-1">
                    <div class="stat-row"><span>Twitch</span> <div class="bar-container"><div id="ins-dna-twitch" class="bar-fill bg-orange-400"></div></div></div>
                    <div class="stat-row"><span>Altruism</span> <div class="bar-container"><div id="ins-dna-altruism" class="bar-fill bg-rose-300"></div></div></div>
                    <div class="stat-row"><span>Curiosity</span> <div class="bar-container"><div id="ins-dna-curiosity" class="bar-fill bg-blue-400"></div></div></div>
                    <div class="stat-row"><span>Social</span> <div class="bar-container"><div id="ins-dna-social" class="bar-fill bg-pink-500"></div></div></div>
                    <div class="stat-row"><span>Aggro</span> <div class="bar-container"><div id="ins-dna-aggro" class="bar-fill bg-red-600"></div></div></div>
                    <div class="stat-row"><span>Botany</span> <div class="bar-container"><div id="ins-dna-botany" class="bar-fill bg-emerald-400"></div></div></div>
                    <div class="stat-row"><span>Build</span> <div class="bar-container"><div id="ins-dna-build" class="bar-fill bg-yellow-600"></div></div></div>
                    <div class="stat-row"><span>Maker</span> <div class="bar-container"><div id="ins-dna-manu" class="bar-fill bg-cyan-500"></div></div></div>
                </div>
            </div>

            <!-- Collapsible Tribe Panel -->
            <div class="relative ml-4 flex-shrink-0" style="pointer-events:auto;">
                <button id="tribe-toggle-btn" onclick="toggleTribePanel(true)" class="ui-control bg-white/15 text-white text-[10px] uppercase tracking-widest px-3 py-1 rounded-full border border-white/30 shadow-lg backdrop-blur-sm">Tribes & Nests</button>
                <div id="tribe-panel" class="panel rounded-lg p-3 mt-2 w-60 hidden shadow-xl border border-gray-700 bg-gray-900/80">
                    <div class="flex justify-between items-center border-b border-gray-700 pb-2 mb-2">
                        <div class="font-bold text-gray-300 uppercase text-[10px]">Tribes & Nests</div>
                        <button onclick="toggleTribePanel(false)" class="text-[10px] text-gray-400 hover:text-white">Close</button>
                    </div>
                <div id="tribe-list" class="space-y-2 text-[10px] overflow-y-auto custom-scroll" style="max-height: 320px;"></div>
                </div>
            </div>

            <!-- Collapsible Legend -->
            <div class="relative ml-auto flex-shrink-0" style="pointer-events:auto;">
                <button id="legend-toggle-btn" onclick="toggleLegendPanel(true)" class="ui-control bg-white/15 text-white text-[10px] uppercase tracking-widest px-3 py-1 rounded-full border border-white/30 shadow-lg backdrop-blur-sm">Legend</button>
                <div id="legend-panel" class="panel rounded-lg p-3 mt-2 w-56 h-96 overflow-y-auto custom-scroll text-xs text-gray-300 hidden shadow-xl border border-gray-700 bg-gray-900/80">
                    <div class="flex justify-between items-center border-b border-gray-700 pb-2 mb-2">
                        <div class="font-bold text-gray-500 uppercase text-[10px]">Legend</div>
                        <button onclick="toggleLegendPanel(false)" class="text-[10px] text-gray-400 hover:text-white">Close</button>
                    </div>
                <div class="grid grid-cols-1 gap-y-1">
                    <div><span class="dot border-4 border-double border-white"></span>Nest</div>
                    <div><span class="dot border border-white"></span>Tribe Halo</div>
                    <div class="border-t border-gray-700 my-1"></div>
                    <!-- Bonds Between Agents -->
                    <div class="text-[10px] text-gray-400 uppercase mb-1">Agent Bonds</div>
                    <div><hr class="w-4 inline-block mr-2 border-t-2 border-white align-middle">Elastic Bond (White)</div>
                    <div><hr class="w-4 inline-block mr-2 border-t-2 border-red-400 align-middle" style="border-width:3px;">Rigid Bond (Red-Orange)</div>
                    <div class="border-t border-gray-700 my-1"></div>
                    <!-- Bonds Between Nests/Tribes -->
                    <div class="text-[10px] text-gray-400 uppercase mb-1">Tribal Bonds</div>
                    <div><hr class="w-4 inline-block mr-2 border-t-2 border-yellow-400 align-middle" style="border-width:3px;">Diplomatic Bond (Yellow/Gold)</div>
                    <div><hr class="w-4 inline-block mr-2 border-t-2 border-cyan-400 align-middle" style="border-style:dashed; border-width:2px;">Commercial Bond (Cyan/Blue, Dashed)</div>
                    <div><hr class="w-4 inline-block mr-2 border-t-2 border-red-600 align-middle" style="border-style:dashed; border-width:4px;">War Bond (Red, Dashed, Animated)</div>
                    <div class="border-t border-gray-700 my-1"></div>
                    <!-- Special Items -->
                    <div><span class="w-2 h-2 bg-green-600 inline-block rounded-full mr-1 opacity-50"></span>Plague (Cataclysm)</div>
                    <div><span class="dot border-4 border-yellow-600 bg-transparent"></span>Defense Ring</div>
                    <div class="border-t border-gray-700 my-1"></div>
                    <!-- Roles -->
                    <div class="text-[10px] text-gray-400 uppercase mb-1">Agent Roles</div>
                    <div><span class="dot bg-white border border-black"></span>Scientist (Tier 3)</div>
                    <div><span class="dot bg-rose-500 border border-white"></span>Merchant (Tier 2)</div>
                    <div><span class="dot bg-purple-800 border border-red-500"></span>Monster</div>
                    <div><span class="dot bg-red-500"></span>Soldier (Tier 1)</div>
                    <div><span class="dot bg-indigo-500"></span>Raider (Tier 2)</div>
                    <div><span class="dot bg-emerald-400"></span>Botanist</div>
                    <div><span class="dot bg-cyan-200 border border-purple-400"></span>Artisan (Tier 1)</div>
                    <div><span class="dot bg-orange-600"></span>Miner</div>
                    <div><span class="dot bg-slate-500"></span>Guardian</div>
                    <div><span class="dot bg-yellow-500"></span>Builder</div>
                    <div><span class="dot" style="background-color: #78716c;"></span>Garbage Collector</div>
                    <div><span class="dot" style="background-color: #a3e635;"></span>Farmer</div>
                    <div><span class="dot bg-pink-200 border border-red-200"></span>Healer (Tier 2)</div>
                    <div><span class="dot bg-amber-200 border border-cyan-400"></span>Diplomat (Tier 3)</div>
                    <div><span class="dot bg-indigo-200 border border-purple-400"></span>Teacher (Tier 3)</div>
                    <div><span class="dot" style="background-color: #7c3aed; border: 1px solid #a78bfa;"></span>Spy (Tier 1)</div>
                    <div><span class="dot" style="background-color: #06b6d4; border: 1px solid #22d3ee;"></span>Technologist (Tier 2)</div>
                    <div><span class="dot bg-yellow-400 border border-white"></span>Hero</div>
                    <div><span class="dot" style="background-color: #cbd5e1;"></span>Gatherer</div>
                    <div><span class="dot" style="background-color: #94a3b8;"></span>Scout</div>
                    <div class="border-t border-gray-700 my-1"></div>
                    <!-- Food Chain -->
                    <div class="text-[10px] text-gray-400 uppercase mb-1">Food Chain</div>
                    <div><span class="dot" style="background-color: #84cc16;"></span>Grazer (Prey)</div>
                    <div><span class="dot" style="background-color: #dc2626;"></span>Predator</div>
                    <div><span class="dot" style="background-color: #facc15;"></span>Prey</div>
                    <div class="border-t border-gray-700 my-1"></div>
                    <!-- Resources -->
                    <div class="text-[10px] text-gray-400 uppercase mb-1">Resources</div>
                    <div><span class="dot bg-green-500"></span>Food (Least Valuable)</div>
                    <div><span class="dot" style="background-color: #a3e635;"></span>Seed</div>
                    <div><span class="dot bg-yellow-500"></span>Material (MAT)</div>
                    <div><span class="dot" style="background-color: #f472b6;"></span>Stim</div>
                    <div><span class="dot bg-fuchsia-400"></span>Herb (Cure)</div>
                    <div><span class="dot bg-slate-300"></span>Ore (Wealth)</div>
                    <div><span class="dot bg-cyan-400 border border-white"></span>Relic (XP)</div>
                    <div><span class="dot" style="background-color: #a78bfa;"></span>Unique</div>
                    <div><span class="dot" style="background-color: #fbbf24; border: 2px solid #f59e0b;"></span>Treasure (Most Valuable)</div>
                </div>
                <div class="mt-2 text-[10px] text-gray-500 italic text-right">Click canvas to spawn</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        /* --- MATH UTILS --- */
        class Vector {
            constructor(x, y) { this.x = x; this.y = y; }
            add(v) { this.x += v.x; this.y += v.y; return this; }
            sub(v) { this.x -= v.x; this.y -= v.y; return this; }
            mult(n) { this.x *= n; this.y *= n; return this; }
            div(n) { this.x /= n; this.y /= n; return this; }
            mag() { return Math.sqrt(this.x * this.x + this.y * this.y); }
            normalize() { let m = this.mag(); if (m !== 0) this.div(m); return this; }
            limit(max) { if (this.mag() > max) { this.normalize(); this.mult(max); } return this; }
            heading() { return Math.atan2(this.y, this.x); }
            rotate(angle) {
                let cos = Math.cos(angle);
                let sin = Math.sin(angle);
                let x = this.x * cos - this.y * sin;
                let y = this.x * sin + this.y * cos;
                this.x = x;
                this.y = y;
                return this;
            }
            // Wrap position on torus (world wraps around)
            wrap(width, height) {
                while (this.x < 0) this.x += width;
                while (this.x >= width) this.x -= width;
                while (this.y < 0) this.y += height;
                while (this.y >= height) this.y -= height;
                return this;
            }
            // Get wrapped position (returns new vector, doesn't modify this)
            wrapped(width, height) {
                let w = this.copy();
                return w.wrap(width, height);
            }
            static dist(v1, v2) { return Math.sqrt((v1.x - v2.x)**2 + (v1.y - v2.y)**2); }
            // Toroidal distance (accounts for world wrapping)
            static distTorus(v1, v2, width, height) {
                if (!width || !height) return Vector.dist(v1, v2); // Fallback to normal distance
                let dx = Math.abs(v2.x - v1.x);
                let dy = Math.abs(v2.y - v1.y);
                // Account for wrapping
                if (dx > width / 2) dx = width - dx;
                if (dy > height / 2) dy = height - dy;
                return Math.sqrt(dx * dx + dy * dy);
            }
            // Get shortest direction vector on torus (accounts for wrapping)
            static subTorus(v1, v2, width, height) {
                if (!width || !height) return Vector.sub(v1, v2); // Fallback to normal subtraction
                let dx = v2.x - v1.x;
                let dy = v2.y - v1.y;
                // Wrap to shortest path
                if (dx > width / 2) dx -= width;
                else if (dx < -width / 2) dx += width;
                if (dy > height / 2) dy -= height;
                else if (dy < -height / 2) dy += height;
                return new Vector(dx, dy);
            }
            static sub(v1, v2) { return new Vector(v1.x - v2.x, v1.y - v2.y); }
            copy() { return new Vector(this.x, this.y); }
            static random2D() { 
                let angle = Math.random() * Math.PI * 2;
                return new Vector(Math.cos(angle), Math.sin(angle));
            }
        }

        /* --- CONFIGURATION --- */
        const DEFAULT_CONFIG = {
            popSize: 80,
            popCap: 170, 
            mutationRate: 0.35,
            learningRate: 0.1,
            resSpawnRate: 1.08, // Increased by 20% (was 0.9)
            foodSpawnRate: 1.0, // Guaranteed spawn per frame + chance for extra (was 0.48)
            foodSpawnNearNestsRate: 0.5, // Much higher (was 0.22) - spawn near nests more often
            foodNutritionalValue: 1.6,
            maxRes: 400, // Doubled (was 200) - allow more resources on map
            mateCost: 20,
            mateThreshold: 120, 
            baseRadius: 70,
            seedGrowthTime: 400,
            treasureSpawnRate: 0.48, // Increased by 1000% (10x, was 0.048)
            buildRate: 1,
            bondingRate: 3.4,
            bondBreakRate: 0.002 * 0.3, // Reduced by 70% (multiply by 0.3 to keep 30%)
            birthRate: 6.1,
            deathRate: 0.4,
            damageRate: 0.09,
            babyGrowthRate: 0.1,
            energyBurnRate: 0.09,
            tribalTaxRate: 0.2,
            groupAgentTaxPremium: 0.08,
            garbageRecycleChance: 0.2,
            garbageCollectorEnergyEfficiency: 0.5,
            matDecay: 2000, // Default decay timer for MAT resources
            wallDecayRate: 0.005, 
            loveThreshold: 60,
            hateThreshold: -55,
            tribeCount: 4,
            researchSpeed: 0.5,
            unrestThreshold: 20,
            diseaseSpreadProb: 0.02,
            immunitySpreadProb: 0.05,
            lifespanBase: 3000,
            predationRange: 0.15,
            tribeWealthGain: 0.05,
            adultAge: 90,
            monsterLifespan: 1700,
            // Group benefit multipliers
            groupRangeBonus: 0.01,
            groupDamageBonus: 0.03,
            groupDefenseBonus: 0.05,
            groupHealingBonus: 0.01,
            groupEnergyCost: 0.03,
            groupCombatRange: 230,
            groupAgentMinMembers: 5,
            groupAgentMaxMembers: 9,
            groupAgentMinAge: 500,
            groupAgentStabilityThreshold: 420,
            groupAgentAscensionCooldown: 400,
            groupAgentEnergyCostMult: 0.3,
            groupAgentGatherBonus: 0.45,
            groupAgentLifespanMult: 1.5,
            groupAgentBaseRadius: 32,
            groupAgentAscensionChance: 0.4,
            // Elastic bond max length for group agents
            groupAgentElasticBondMaxLength: 110,
            stableGroupMinMembers: 2,
            stableGroupMaxMembers: 12,
            structureStabilityCap: 600,
            structureStabilityInsideGain: 3,
            structureStabilityOutsideGain: 1,
            structureStabilityInsideDecay: 1,
            structureStabilityOutsideDecay: 4,
            structureStabilityBandBonus: 1.25,
            // Rigid bond settings
            rigidBondLength: 35,
            rigidBondStiffness: 0.43,
            rigidBondFormationBonus: 2.1,
            rigidBondBreakResistance: 0.9,
            rigidBondChance: 0.85,
            nestBondedPenalty: 0.8,
            nestSplitPopulation: 20,
            nestSplitParentRetain: 0.75,
            nestSplitChildReceive: 0.3,
            nestMergeDistance: 50,
            nestSplitMaxRadius: 85,
            nestHpDecayRate: 0.005, // Further reduced from 0.00825 (40% reduction) - slower structural decay
            nestAgentSpawnRate: 0.02,
            // Agent spawn rates by role (probability per frame)
            agentSpawnRates: {
                'Scout': 0.02,
                'Gatherer': 0.03,
                'Builder': 0.02,
                'Soldier': 0.03,
                'Miner': 0.01,
                'Raider': 0.01,
                'Farmer': 0.02,
                'Botanist': 0.01,
                'Merchant': 0.01,
                'Diplomat': 0.01,
                'Guardian': 0.02,
                'Artisan': 0.01,
                'Teacher': 0.01,
                'Scientist': 0.01,
                'Spy': 0.01,
                'Technologist': 0.02,
                'Garbage Collector': 0.002
            },
            // Maximum agents per role type (prevents overpopulation)
            agentRoleCaps: {
                'Scout': 15,
                'Gatherer': 20,
                'Builder': 15,
                'Soldier': 20,
                'Miner': 12,
                'Raider': 10,
                'Farmer': 18,
                'Botanist': 12,
                'Merchant': 10,
                'Diplomat': 8,
                'Guardian': 12,
                'Artisan': 10,
                'Teacher': 8,
                'Scientist': 8,
                'Spy': 8,
                'Technologist': 10,
                'Garbage Collector': 5
            },
            // Nest drift rates
            nestBaseDriftRate: 1.8,
            nestDiplomaticDriftMultiplier: 2,
            nestCommercialDriftMultiplier: 1.5,
            nestFriendlyAttractionStrength: 0.03,
            nestEnemyRepulsionStrength: 0.02,
            nestUnaffiliatedDriftRate: 0.025,
            nestDriftSmoothing: 0.08,
            nestToolConfig: {
                maxPerNest: 5,
                spawnCooldown: 420,
                tetherRange: 220,
                resourceHarvestRange: 150,
                toolLifetime: 1200,
                toolTypes: {
                    propulsion: {
                        wealthCost: 240,
                        minHp: 500,
                        techTier: 1,
                        cooldown: 600
                    },
                    foodGrabber: {
                        wealthCost: 180,
                        minHp: 300,
                        techTier: 1,
                        cooldown: 220
                    },
                    resourceGrabber: {
                        wealthCost: 210,
                        minHp: 350,
                        techTier: 2,
                        cooldown: 220
                    },
                    venom: {
                        wealthCost: 260,
                        minHp: 450,
                        techTier: 2,
                        cooldown: 160
                    }
                }
            },
            // Social attraction
            kinAttractionStrength: 0.15,
            tribeAttractionStrength: 0.1,
            // Audio
            sfxVolume: 0.3,
            // Food Chain - INCREASED SPAWN RATES for active food chain
            grazerSpawnRate: 0.02,
            predatorSpawnRate: 0.025, // Increased from 0.007 (3.5x increase) - predators spawn in pairs
            preySpawnRate: 0.05, // Increased from 0.021 (2.4x increase) - prey spawn in groups of 3
            grazerFertilization: 1.2,
            predatorPackBonus: 0.3,
            preyEvadeBonus: 1.15,
            grazerBondStrength: 0.5,
            predatorBondStrength: 0.85,
            preyBondStrength: 0.8,
            herderGeneStrength: 0.3,
            // Farmer & Prey/Predator mechanics
            farmerSpawnGrazerRate: 0.03,
            farmerSpawnGrazerHealthThreshold: 0.75,
            preyAsexualReproductionRate: 0.04, // Increased from 0.017 (2.4x increase) - prey reproduce near food
            preyReproductionFoodBonusFactor: 0.002,
            preyAsexualReproductionRadius: 70,
            predatorPairSpawnRadius: 100,
            // Predator/Prey sexual reproduction (controlled) - INCREASED RATES
            predatorMateRate: 0.01, // Increased from 0.002 (5x increase) - predators mate more often
            predatorReproductionRate: 0.002,
            predatorMateCooldown: 400, // Reduced from 800 (2x faster) - shorter cooldown
            predatorMateEnergyThreshold: 120,
            preyMateRate: 0.025, // Increased from 0.008 (3.1x increase) - prey mate more often
            tribalReproductionRate: 0.0015,
            preyMateCooldown: 200, // Reduced from 400 (2x faster) - shorter cooldown
            preyMateEnergyThreshold: 80,
            // Density-dependent reproduction
            reproductionDensityMin: 0.05,
            reproductionDensityOptimal: 0.35,
            reproductionDensityMax: 0.85,
            reproductionMinMultiplier: 0.3,
            reproductionMaxMultiplier: 2.2,
            // Roaming behavior
            roamingGeneStrength: 1.2,
            nestReturnFrequencyMin: 200,
            nestReturnFrequencyMax: 1400,
            leaderMaxWanderRadius: 120, // Maximum distance leaders can wander from nest
            oscillatingMovementStrength: 0.6,
            // Bonded movement weighting
            bondInfluenceByStrength: true,
            // Diplomat & Merchant systems
            diplomatSpawnDistance: 280,
            merchantSpawnDistance: 180,
            diplomatVisitDuration: 500,
            merchantTradeFrequency: 0.08,
            diplomatNegotiationFrequency: 0.19,
            tradeRequiresMerchant: true,
            diplomaticBondGrowth: 3.1,
            commercialBondGrowth: 4.2,
            minAllianceForTrade: 20,
            bondDecayRate: 0.007,
            bondReinforcementThreshold: 20,
            warDeclarationThreshold: -50,
            // Ranged Combat & Warfare
            rangedCombatRange: 150,
            rangedCombatCooldown: 120,
            rangedCombatDamage: 15,
            rangedCombatChance: 0.6,
            warExhaustionPerDeath: 5,
            warExhaustionDecay: 0.1,
            // Food decay system - food lasts longer now
            foodDecayRate: 0.00075, // Reduced by 50% (was 0.0015) - food decays slower
            foodMinLife: 400, // Doubled (was 200) - food lasts longer
            foodMaxLife: 1200, // Doubled (was 600) - food lasts longer
            foodNearNestLifeMultiplier: 0.5,
            botanistFertilizeRate: 0.09,
            botanistFertilizeRadius: 20,
            resourceDecayTimers: {
                FOOD: 5000, // Doubled (was 2500) - food resources last longer
                SEED: 10000, // Doubled (was 5000) - seeds last longer
                MAT: 4000, // Doubled (was 2000) - materials last longer
                ORE: 6600, // Doubled (was 3300) - ore lasts longer
                TREASURE: 10800, // Doubled (was 5400) - treasure lasts longer
                STIM: 6000, // Doubled (was 3000) - stims last longer
                HERB: 20000, // Doubled (was 10000) - herbs last longer
                RELIC: 20000, // Doubled (was 10000) - relics last longer
                UNIQUE: 10000 // Doubled (was 5000) - unique resources last longer
            }
        };

        let CONFIG = { ...DEFAULT_CONFIG };

        // ===== CENTRALIZED AGENT SPAWNING HELPER FUNCTIONS =====
        
        /**
         * Get the required tech tier for a role
         * @param {string} role - The role name
         * @returns {number} Required tech tier (0, 1, or 2)
         */
        function getRequiredTechTier(role) {
            // Tier 1 roles
            if (role === 'Merchant' || role === 'Diplomat' || role === 'Scientist' || role === 'Spy' || 
                role === 'Artisan' || role === 'Guardian' || role === 'Teacher') {
                return 1;
            }
            // Tier 2 roles
            if (role === 'Raider' || role === 'Technologist') {
                return 2;
            }
            // All other roles are tier 0 (basic roles)
            return 0;
        }

        /**
         * Check if a role is a basic role (always available regardless of tech tier)
         * @param {string} role - The role name
         * @returns {boolean} True if basic role
         */
        function isBasicRole(role) {
            return role === 'Soldier' || role === 'Gatherer' || role === 'Scout' || 
                   role === 'Builder' || role === 'Farmer' || role === 'Miner' || 
                   role === 'Botanist' || role === 'Garbage Collector';
        }

        /**
         * Get all available roles for a tribe based on tech tier
         * @param {number} techTier - The tribe's tech tier
         * @returns {string[]} Array of available role names
         */
        function getAvailableRoles(techTier) {
            let availableRoles = [];
            if (typeof CONFIG.agentSpawnRates === 'object') {
                for (let role in CONFIG.agentSpawnRates) {
                    let requiredTier = getRequiredTechTier(role);
                    // Include role if tech tier is met OR if it's a basic role
                    if (techTier >= requiredTier || isBasicRole(role)) {
                        availableRoles.push(role);
                    }
                }
            }
            // Always include basic roles as fallback
            if (availableRoles.length === 0) {
                availableRoles = ['Gatherer', 'Scout', 'Builder', 'Farmer', 'Soldier'];
            }
            return availableRoles;
        }

        /**
         * Get current agent counts by role for a tribe
         * @param {Array} agents - All agents in the simulation
         * @param {number} tribeId - The tribe ID
         * @returns {Object} Object mapping role names to counts
         */
        function getRoleCounts(agents, tribeId) {
            let counts = {};
            if (agents) {
                agents.forEach(a => {
                    if (a.tribeId === tribeId && !a.dead && a.role) {
                        counts[a.role] = (counts[a.role] || 0) + 1;
                    }
                });
            }
            return counts;
        }

        /**
         * Weighted random selection of a role based on spawn rates and current counts
         * Respects role caps and spawn rates
         * @param {string[]} availableRoles - Roles available to spawn
         * @param {Object} currentCounts - Current agent counts by role
         * @param {Object} roleCaps - Maximum agents per role
         * @param {Object} spawnRates - Base spawn rates for each role
         * @param {Object} modifiers - Optional modifiers (war, economic, etc.)
         * @returns {string|null} Selected role name or null if none available
         */
        function weightedRandomRole(availableRoles, currentCounts, roleCaps, spawnRates, modifiers = {}) {
            if (!availableRoles || availableRoles.length === 0) return null;

            // Build weighted array
            let weights = [];
            let roles = [];

            for (let role of availableRoles) {
                // Check if role is at cap
                let cap = roleCaps[role] || Infinity;
                let current = currentCounts[role] || 0;
                if (current >= cap) continue; // Skip roles at cap

                // Base weight from spawn rate
                let weight = spawnRates[role] || 0.01;

                // Apply modifiers
                if (modifiers.war && (role === 'Soldier' || role === 'Raider' || role === 'Guardian')) {
                    weight *= 3; // 3x weight for fighting roles during war
                }
                if (modifiers.economic && (role === 'Merchant' || role === 'Artisan' || role === 'Miner' || role === 'Builder' || role === 'Farmer')) {
                    weight *= 2; // 2x weight for money roles during economic bonds
                }
                if (modifiers.hasTeachersScientists && role === 'Technologist') {
                    weight *= 3; // 3x weight for Technologist if Teachers/Scientists exist
                }
                if (modifiers.hasNearbyBlocks && role === 'Builder') {
                    weight *= 3; // 3x weight for Builder if blocks nearby
                }

                // Reduce weight if role is over target (but not at cap)
                let target = modifiers.targetPerRole || 3;
                if (current > target) {
                    weight *= 0.5; // Reduce weight by 50% if over target
                } else if (current < target) {
                    weight *= (1 + (target - current) * 0.2); // Increase weight if under target
                }

                weights.push(weight);
                roles.push(role);
            }

            if (roles.length === 0) return null;

            // Weighted random selection
            let totalWeight = weights.reduce((sum, w) => sum + w, 0);
            if (totalWeight === 0) {
                // Fallback to uniform random if all weights are 0
                return roles[Math.floor(Math.random() * roles.length)];
            }

            let random = Math.random() * totalWeight;
            let cumulative = 0;
            for (let i = 0; i < weights.length; i++) {
                cumulative += weights[i];
                if (random <= cumulative) {
                    return roles[i];
                }
            }

            // Fallback
            return roles[roles.length - 1];
        }

        function weightedResourceEnergy(type) {
            // RESOURCE VALUE SCALE: From least (food) to most (treasure)
            // Treasure is super valuable, with a clear progression
            switch(type) {
                case 'FOOD': return 25;        // Least valuable - basic sustenance
                case 'SEED': return 30;        // Slightly more valuable - can grow
                case 'MAT': return 40;         // Materials for building
                case 'STIM': return 50;        // Stimulants for energy
                case 'HERB': return 60;        // Herbs for healing/benefits
                case 'ORE': return 80;         // Ore for crafting/advanced materials
                case 'RELIC': return 120;      // Relics - very valuable artifacts
                case 'UNIQUE': return 150;     // Unique items - extremely valuable
                case 'TREASURE': return 200;   // Super valuable - highest tier
                case 'BLOCK': return 0;        // Blocks cannot be consumed - no energy value
                default: return 30;            // Default to low value
            }
        }

        function giveNestWealth(tribeId, type, resource) {
            if (typeof sim === 'undefined' || !sim.tribes) return;
            let nest = sim.tribes.nests.find(n => n.tribeId === tribeId);
            if (!nest) return;
            
            // UNIQUE resources give random boons to the tribe
            if (type === 'UNIQUE') {
                let boonType = Math.floor(Math.random() * 5);
                switch(boonType) {
                    case 0: // Wealth boost
                        nest.wealth += 50 + Math.random() * 50;
                        break;
                    case 1: // HP boost
                        nest.hp = Math.min(nest.maxHealth, nest.hp + 100 + Math.random() * 100);
                        nest.health = nest.hp;
                        break;
                    case 2: // Temporary spawn boost (increase spawn rate for next 300 frames)
                        nest.uniqueSpawnBoost = (nest.uniqueSpawnBoost || 0) + 300;
                        break;
                    case 3: // Temporary defense boost
                        nest.defenseLevel += 1;
                        nest.hp += 50;
                        break;
                    case 4: // Gene amplification (boost a random gene for all agents in tribe)
                        let geneOptions = ['aggression', 'defense', 'botany', 'manufacturing', 'intelligence', 
                                         'commerce', 'curiosity', 'social', 'altruism', 'speed'];
                        let boostedGene = geneOptions[Math.floor(Math.random() * geneOptions.length)];
                        if (typeof sim !== 'undefined' && sim.agents) {
                            sim.agents.forEach(a => {
                                if (a.tribeId === tribeId && !a.dead && a.genes && a.genes[boostedGene] !== undefined) {
                                    a.genes[boostedGene] = Math.min(1.0, (a.genes[boostedGene] || 0) + 0.1);
                                }
                            });
                        }
                        break;
                }
                return; // UNIQUE resources don't give normal wealth
            }
            
            // Wealth bonus scales with resource value - treasure gives much more wealth
            let resourceValue = weightedResourceEnergy(type) || 30;
            // Scale wealth gain: base 0.15 multiplier, but treasure gets bonus multiplier
            let multiplier = type === 'TREASURE' ? 0.25 : (type === 'RELIC' ? 0.20 : 0.15);
            let bonus = resourceValue * multiplier;
            nest.wealth += bonus;
        }

        function markLeaderUnderAttack(targetAgent, attacker) {
            if (!targetAgent || !attacker || typeof sim === 'undefined' || !sim.tribes) return;
            if (targetAgent.tribeId === -1) return;
            let tribe = sim.tribes.tribes[targetAgent.tribeId];
            if (!tribe) return;
            if (tribe.leaderId === targetAgent.id) {
                tribe.leaderUnderAttack = true;
                tribe.leaderUnderAttackTargetId = attacker.id;
                tribe.leaderUnderAttackTimer = sim.frame;
            }
        }

        /* --- SOUND EFFECTS SYSTEM --- */
        /*
            BACKGROUND MUSIC ATTRIBUTION:
            "Life Ambient" by Serge Quadrado
            Source: Free Music Archive
            License: CC BY-NC-SA (Creative Commons Attribution-NonCommercial-ShareAlike)
            URL: https://www.novaspivack.com/wp-content/uploads/2025/11/Serge-Quadrado-Life-Ambient.mp3
            
            This work is licensed under CC BY-NC-SA 4.0
        */
        class SFXEngine {
            constructor() {
                this.audioContext = null;
                this.enabled = false; // Disabled by default
                this.initialized = false;
                // Background ambient sound - using external audio file
                // "Life Ambient" by Serge Quadrado (CC BY-NC-SA, Free Music Archive)
                this.backgroundAudio = null; // HTML5 Audio element
                this.backgroundAudioSource = null; // Web Audio API MediaElementSourceNode
                this.backgroundGain = null; // Gain node for volume control
                this.backgroundRunning = false;
                this.nestHeartbeats = new Map(); // Map of nestId -> {osc, gain, pulseGain}
                
                // CENTRALIZED SOUND CONTROL - Enable/disable individual sound types from one place
                // All sound calls throughout the codebase go through _playSound() which checks this config
                // Set to false to disable a sound type, true to enable it
                // You can also use helper methods: setSoundEnabled(type, enabled), setSoundsEnabled([types], enabled)
                // disableAllSounds(), enableAllSounds()
                this.soundEnabled = {
                    'attack': false,
                    'birth': false,
                    'death': false,
                    'eat': false,
                    'heal': false,
                    'diplomacy': false,
                    'jealousy': false,
                    'merge': false,
                    'split': false,
                    'transaction': false,
                    'link_formed': false,
                    'link_broken': false,
                    'spawn': false,
                    'aquatic': false,
                    'bloop': false,
                    'bleep': false,
                    'water_drop': false,
                    'bubble': false,
                    'artisan_tone': false,
                    'collect': false,
                    'ranged_attack': false,
                    'static': false,
                    'love': false,
                    'mating': false,
                    'trade': false,
                    'bond': false
                };
            }
            
            enable() {
                if (!this.initialized) {
                    try {
                        this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                        this.initialized = true;
                        this.enabled = true;
                        console.log('Audio enabled, state:', this.audioContext.state);
                        
                        // Resume if suspended (browser autoplay policy)
                        if (this.audioContext.state === 'suspended') {
                            this.audioContext.resume().then(() => {
                                console.log('Audio context resumed');
                                this.startBackgroundSound();
                            }).catch(e => {
                                console.log('Audio resume failed:', e);
                            });
                        } else {
                            this.startBackgroundSound();
                        }
                    } catch(e) {
                        console.log('Web Audio API not supported');
                        this.enabled = false;
                    }
                } else {
                    this.enabled = true;
                    // Resume if suspended
                    if (this.audioContext && this.audioContext.state === 'suspended') {
                        this.audioContext.resume().then(() => {
                            this.startBackgroundSound();
                        }).catch(e => console.log('Audio resume failed:', e));
                    } else {
                        this.startBackgroundSound();
                    }
                }
            }
            
            startBackgroundSound() {
                if (!this.enabled || !this.initialized || this.backgroundRunning) {
                    console.log('Background sound blocked:', {enabled: this.enabled, initialized: this.initialized, running: this.backgroundRunning});
                    return;
                }
                
                const ctx = this.audioContext;
                if (!ctx) {
                    console.log('No audio context!');
                    return;
                }
                
                // CRITICAL: Ensure audio context is running
                if (ctx.state === 'suspended') {
                    console.log('Audio context suspended, resuming...');
                    ctx.resume().then(() => {
                        console.log('Audio context resumed, starting background sound');
                        this.startBackgroundSound();
                    }).catch(e => {
                        console.error('Failed to resume audio context:', e);
                    });
                    return;
                }
                
                console.log('Loading background music: "Life Ambient" by Serge Quadrado (CC BY-NC-SA, Free Music Archive)');
                
                // Create HTML5 Audio element for the background music
                // "Life Ambient" by Serge Quadrado (CC BY-NC-SA, Free Music Archive)
                const audioUrl = 'https://www.novaspivack.com/wp-content/uploads/2025/11/Serge-Quadrado-Life-Ambient.mp3';
                this.backgroundAudio = new Audio(audioUrl);
                this.backgroundAudio.loop = true; // Loop the track automatically
                this.backgroundAudio.preload = 'auto'; // Preload the audio
                this.backgroundAudio.crossOrigin = 'anonymous'; // Allow CORS for Web Audio API
                
                // Create gain node for volume control
                this.backgroundGain = ctx.createGain();
                const mainVolume = Math.max(0.3, CONFIG.sfxVolume) * 0.8; // Increased volume level
                this.backgroundGain.gain.setValueAtTime(mainVolume, ctx.currentTime);
                
                // Connect HTML5 Audio to Web Audio API for volume control
                try {
                    this.backgroundAudioSource = ctx.createMediaElementSource(this.backgroundAudio);
                    this.backgroundAudioSource.connect(this.backgroundGain);
                    this.backgroundGain.connect(ctx.destination);
                    console.log('Audio connected to Web Audio API');
                } catch(e) {
                    console.error('Error connecting audio source to Web Audio API:', e);
                    // Fallback: use HTML5 Audio directly if Web Audio API connection fails
                    this.backgroundAudio.volume = mainVolume;
                    console.log('Using HTML5 Audio fallback with volume:', mainVolume);
                }
                
                // Function to attempt playback
                const attemptPlay = () => {
                    if (!this.backgroundAudio || !this.enabled) return;
                    
                    const playPromise = this.backgroundAudio.play();
                    if (playPromise !== undefined) {
                        playPromise.then(() => {
                            console.log('Background music started playing: "Life Ambient" by Serge Quadrado');
                            this.backgroundRunning = true;
                            
                            // Verify it's actually playing
                            setTimeout(() => {
                                if (this.backgroundAudio && !this.backgroundAudio.paused) {
                                    console.log('Background music confirmed playing');
                                } else {
                                    console.warn('Background music may not be playing - paused state:', this.backgroundAudio?.paused);
                                }
                            }, 500);
                        }).catch(e => {
                            console.error('Error playing background music:', e);
                            console.log('Note: Audio autoplay may be blocked by browser. User interaction may be required.');
                            // Try again after a short delay
                            setTimeout(() => {
                                if (this.enabled && !this.backgroundRunning) {
                                    console.log('Retrying background music playback...');
                                    attemptPlay();
                                }
                            }, 1000);
                        });
                    } else {
                        // Fallback for older browsers
                        this.backgroundAudio.play();
                        this.backgroundRunning = true;
                    }
                };
                
                // Handle audio loading and playback
                this.backgroundAudio.addEventListener('loadeddata', () => {
                    console.log('Background music loaded successfully');
                    attemptPlay();
                });
                
                this.backgroundAudio.addEventListener('canplay', () => {
                    console.log('Background music can play');
                    if (!this.backgroundRunning) {
                        attemptPlay();
                    }
                });
                
                this.backgroundAudio.addEventListener('canplaythrough', () => {
                    console.log('Background music can play through');
                    if (!this.backgroundRunning) {
                        attemptPlay();
                    }
                });
                
                // Ensure track restarts when it ends (backup to loop property)
                this.backgroundAudio.addEventListener('ended', () => {
                    console.log('Background music ended, restarting...');
                    if (this.enabled && this.backgroundRunning) {
                        this.backgroundAudio.currentTime = 0;
                        this.backgroundAudio.play().catch(e => {
                            console.error('Error restarting background music:', e);
                        });
                    }
                });
                
                this.backgroundAudio.addEventListener('error', (e) => {
                    console.error('Error loading background music:', e);
                    // Check if backgroundAudio still exists and is not null before accessing properties
                    if (this.backgroundAudio && this.backgroundAudio.error) {
                        console.error('Audio error details:', {
                            error: this.backgroundAudio.error,
                            code: this.backgroundAudio.error?.code,
                            message: this.backgroundAudio.error?.message,
                            networkState: this.backgroundAudio.networkState,
                            readyState: this.backgroundAudio.readyState
                        });
                    } else {
                        console.error('Audio element is null or error property unavailable');
                    }
                    this.backgroundRunning = false;
                });
                
                // Start loading the audio
                this.backgroundAudio.load();
                
                // Also try playing after a short delay (in case events don't fire)
                setTimeout(() => {
                    if (!this.backgroundRunning && this.enabled && this.backgroundAudio) {
                        console.log('Attempting delayed playback...');
                        attemptPlay();
                    }
                }, 2000);
            }
            
            // Method to ensure audio plays (call after user interaction)
            ensureAudioPlaying() {
                if (!this.enabled || !this.initialized) return;
                
                const ctx = this.audioContext;
                if (!ctx) return;
                
                // Resume audio context if suspended
                if (ctx.state === 'suspended') {
                    ctx.resume().then(() => {
                        console.log('Audio context resumed via ensureAudioPlaying');
                        if (this.backgroundAudio && this.backgroundAudio.paused) {
                            this.backgroundAudio.play().then(() => {
                                console.log('Background audio started via ensureAudioPlaying');
                                this.backgroundRunning = true;
                            }).catch(e => {
                                console.error('Error playing audio in ensureAudioPlaying:', e);
                            });
                        }
                    }).catch(e => {
                        console.error('Error resuming audio context:', e);
                    });
                } else if (this.backgroundAudio && this.backgroundAudio.paused) {
                    // Audio context is running, try to play directly
                    this.backgroundAudio.play().then(() => {
                        console.log('Background audio started via ensureAudioPlaying');
                        this.backgroundRunning = true;
                    }).catch(e => {
                        console.error('Error playing audio:', e);
                    });
                }
            }
            
            startNestHeartbeat(nestId, baseFreq, baseInterval) {
                return; // DISABLED - not working
                if (!this.enabled || !this.initialized || this.nestHeartbeats.has(nestId)) return;
                
                const ctx = this.audioContext;
                if (!ctx) return;
                
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                const pulseGain = ctx.createGain();
                
                // Each nest has its own very low-frequency heartbeat - extremely slow wave
                osc.type = 'sine';
                osc.frequency.setValueAtTime(baseFreq, ctx.currentTime);
                
                pulseGain.gain.setValueAtTime(0.03, ctx.currentTime); // Very quiet base
                
                osc.connect(pulseGain);
                pulseGain.connect(gain);
                gain.connect(ctx.destination);
                
                gain.gain.setValueAtTime(CONFIG.sfxVolume * 0.08, ctx.currentTime); // Quiet per-nest but audible
                
                const scheduleNestHeartbeat = (startTime, interval) => {
                    // EXTREMELY long, slow wave - 20+ second wave evolution
                    const waveTime = 20.0; // 20 second wave duration
                    const peakGain = 0.12; // Quiet peak
                    const baseGain = 0.03; // Very quiet base
                    
                    // Extremely slow, gentle wave up (10 seconds to peak)
                    pulseGain.gain.setValueAtTime(baseGain, startTime);
                    pulseGain.gain.linearRampToValueAtTime(peakGain, startTime + waveTime / 2); // 10 second ramp up
                    // Extremely slow, gentle wave down (10 seconds back to base)
                    pulseGain.gain.linearRampToValueAtTime(baseGain, startTime + waveTime); // 10 second ramp down
                    
                    // Check if nest is at war and adjust interval - calculate BEFORE setTimeout
                    let currentInterval = interval;
                    if (typeof sim !== 'undefined' && sim.nests) {
                        const nest = sim.nests.find(n => n.id === nestId);
                        if (nest && sim.tribes && sim.tribes.tribes[nest.tribeId]) {
                            const tribe = sim.tribes.tribes[nest.tribeId];
                            const isAtWar = Object.values(tribe.atWarWith || {}).some(w => w);
                            if (isAtWar) {
                                currentInterval = interval * 0.5; // 2X faster during war (but still slow)
                            }
                        }
                    }
                    
                    // Store interval in const for setTimeout closure
                    const delayMs = currentInterval * 1000;
                    
                    setTimeout(() => {
                        if (this.nestHeartbeats.has(nestId) && this.audioContext) {
                            scheduleNestHeartbeat(this.audioContext.currentTime, currentInterval);
                        }
                    }, delayMs);
                };
                
                osc.start(ctx.currentTime);
                this.nestHeartbeats.set(nestId, { osc, gain, pulseGain, baseInterval });
                scheduleNestHeartbeat(ctx.currentTime, baseInterval);
            }
            
            stopNestHeartbeat(nestId) {
                const heartbeat = this.nestHeartbeats.get(nestId);
                if (heartbeat) {
                    heartbeat.osc.stop();
                    heartbeat.gain.disconnect();
                    heartbeat.pulseGain.disconnect();
                    this.nestHeartbeats.delete(nestId);
                }
            }
            
            stopBackgroundSound() {
                this.backgroundRunning = false;
                
                // Stop and clean up background audio
                if (this.backgroundAudio) {
                    try {
                        this.backgroundAudio.pause();
                        this.backgroundAudio.currentTime = 0;
                        this.backgroundAudio.src = ''; // Clear source to free memory
                    } catch(e) {
                        console.error('Error stopping background audio:', e);
                    }
                    this.backgroundAudio = null;
                }
                
                // Disconnect Web Audio API nodes
                if (this.backgroundAudioSource) {
                    try {
                        this.backgroundAudioSource.disconnect();
                    } catch(e) {
                        console.error('Error disconnecting audio source:', e);
                    }
                    this.backgroundAudioSource = null;
                }
                
                if (this.backgroundGain) {
                    try {
                        this.backgroundGain.disconnect();
                    } catch(e) {
                        console.error('Error disconnecting gain node:', e);
                    }
                    this.backgroundGain = null;
                }
                
                // Stop all nest heartbeats
                for (let nestId of this.nestHeartbeats.keys()) {
                    this.stopNestHeartbeat(nestId);
                }
            }
            
            disable() {
                this.enabled = false;
                this.stopBackgroundSound();
            }
            
            play(type, frequency = 440, duration = 0.1, volume = 1.0) {
                if (!this.enabled || !this.initialized || CONFIG.sfxVolume === 0) return;
                
                const ctx = this.audioContext;
                // Resume audio context if suspended (browser autoplay policy)
                if (ctx.state === 'suspended') {
                    ctx.resume().then(() => {
                        // Retry playing after resume
                        this._playSound(type, frequency, duration, volume);
                    }).catch(e => {
                        console.log('Audio resume failed:', e);
                    });
                    return; // Exit early, will retry after resume
                }
                this._playSound(type, frequency, duration, volume);
            }
            
            _playSound(type, frequency = 440, duration = 0.1, volume = 1.0) {
                if (!this.enabled || !this.initialized || CONFIG.sfxVolume === 0) return;
                
                // CENTRALIZED SOUND CONTROL - Check if this sound type is enabled
                // If not in the config, default to disabled (safe default)
                if (this.soundEnabled.hasOwnProperty(type) && !this.soundEnabled[type]) {
                    return; // Sound type is disabled, don't play
                }
                // If sound type is not in config, also disable it (safe default)
                if (!this.soundEnabled.hasOwnProperty(type)) {
                    console.warn('Unknown sound type:', type, '- disabling by default');
                    return;
                }
                
                // Log all sound calls to identify what's being triggered
                console.log('SOUND CALLED:', type, 'freq:', frequency, 'dur:', duration, 'vol:', volume);
                
                // Create audio nodes only if sound is enabled
                const ctx = this.audioContext;
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                
                osc.connect(gain);
                gain.connect(ctx.destination);
                
                const finalVolume = Math.min(1.0, CONFIG.sfxVolume * volume);
                
                switch(type) {
                    case 'trade':
                        // TEMPORARILY DISABLED FOR TESTING
                        return; // Don't play any sound
                        break;
                    
                    case 'bond':
                        // TEMPORARILY DISABLED FOR TESTING - was 0.8x duration
                        return; // Don't play any sound
                        break;
                    
                    case 'attack':
                        // TEMPORARILY DISABLED FOR TESTING
                        return; // Don't play any sound
                        break;
                    
                    case 'birth':
                        // TEMPORARILY DISABLED FOR TESTING
                        return; // Don't play any sound
                        break;
                    
                    case 'death':
                        // TEMPORARILY DISABLED FOR TESTING
                        return; // Don't play any sound
                        break;
                    
                    case 'eat':
                        // TEMPORARILY DISABLED FOR TESTING
                        return; // Don't play any sound
                        break;
                    
                    case 'heal':
                        // TEMPORARILY DISABLED FOR TESTING
                        return; // Don't play any sound
                        break;
                    
                    case 'diplomacy':
                        // TEMPORARILY DISABLED FOR TESTING
                        return; // Don't play any sound
                        break;
                    
                    case 'jealousy':
                        // TEMPORARILY DISABLED FOR TESTING - was 0.8x duration with modulation
                        return; // Don't play any sound
                        break;
                    
                    case 'merge':
                        // TEMPORARILY DISABLED FOR TESTING - was 0.6x duration with modulation
                        return; // Don't play any sound
                        break;
                    
                    case 'split':
                        // TEMPORARILY DISABLED FOR TESTING - was full duration with modulation
                        return; // Don't play any sound
                        break;
                    
                    case 'transaction':
                        // TEMPORARILY DISABLED FOR TESTING
                        return; // Don't play any sound
                        break;
                    
                    case 'link_formed':
                        // TEMPORARILY DISABLED FOR TESTING - was 0.7x duration with modulation
                        return; // Don't play any sound
                        break;
                    
                    case 'link_broken':
                        // TEMPORARILY DISABLED FOR TESTING
                        return; // Don't play any sound
                        break;
                    
                    case 'spawn':
                        // TEMPORARILY DISABLED FOR TESTING
                        return; // Don't play any sound
                        break;
                    
                    case 'aquatic':
                        // TEMPORARILY DISABLED FOR TESTING
                        return; // Don't play any sound
                        break;
                    
                    case 'bloop':
                        // TEMPORARILY DISABLED FOR TESTING
                        return; // Don't play any sound
                        break;
                    
                    case 'bleep':
                        // TEMPORARILY DISABLED FOR TESTING
                        return; // Don't play any sound
                        break;
                    
                    case 'water_drop':
                        // TEMPORARILY DISABLED FOR TESTING
                        return; // Don't play any sound
                        break;
                    
                    case 'bubble':
                        // TEMPORARILY DISABLED FOR TESTING
                        return; // Don't play any sound
                        break;
                    
                    case 'artisan_tone':
                        // TEMPORARILY DISABLED FOR TESTING - was full duration with modulation
                        return; // Don't play any sound
                        break;
                    
                    case 'collect':
                        // TEMPORARILY DISABLED FOR TESTING
                        return; // Don't play any sound
                        break;
                    
                    case 'ranged_attack':
                        // NO SOUND - projectiles are silent
                        return; // Don't play any sound
                        break;
                    
                    case 'static':
                        // TEMPORARILY DISABLED FOR TESTING
                        return; // Don't play any sound
                        break;
                    
                    case 'love':
                        // TEMPORARILY DISABLED FOR TESTING - was long with delay/reverb
                        return; // Don't play any sound
                        break;
                    
                    case 'mating':
                        // TEMPORARILY DISABLED FOR TESTING - was long with delay/reverb
                        return; // Don't play any sound
                        break;
                    
                    default:
                        // Log unhandled sound types to identify what's playing
                        console.log('UNHANDLED SOUND TYPE:', type, 'frequency:', frequency, 'duration:', duration, 'volume:', volume);
                        // Default: Ultra short generic soft electronic beep
                        osc.frequency.setValueAtTime(frequency * 0.7, ctx.currentTime);
                        osc.type = 'sine';
                        gain.gain.setValueAtTime(0, ctx.currentTime);
                        gain.gain.linearRampToValueAtTime(finalVolume * 0.12, ctx.currentTime + duration * 0.05);
                        gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + duration * 0.15);
                        duration *= 0.15;
                }
                
                // Start and stop the oscillator
                osc.start(ctx.currentTime);
                osc.stop(ctx.currentTime + duration);
            }
            
            // Helper method to enable/disable sounds from one place
            setSoundEnabled(soundType, enabled) {
                if (this.soundEnabled.hasOwnProperty(soundType)) {
                    this.soundEnabled[soundType] = enabled;
                    console.log(`Sound '${soundType}' ${enabled ? 'enabled' : 'disabled'}`);
                } else {
                    console.warn(`Unknown sound type: ${soundType}`);
                }
            }
            
            // Helper method to enable/disable multiple sounds at once
            setSoundsEnabled(soundTypes, enabled) {
                soundTypes.forEach(type => this.setSoundEnabled(type, enabled));
            }
            
            // Helper method to disable all sounds
            disableAllSounds() {
                Object.keys(this.soundEnabled).forEach(type => {
                    this.soundEnabled[type] = false;
                });
                console.log('All sounds disabled');
            }
            
            // Helper method to enable all sounds
            enableAllSounds() {
                Object.keys(this.soundEnabled).forEach(type => {
                    this.soundEnabled[type] = true;
                });
                console.log('All sounds enabled');
            }
        }
        
        const sfx = new SFXEngine();
        
        // Harmonic frequency constants (A=440Hz standard tuning)
        // Major scale harmonics - all in A major key for tonal coherence
        const HARMONICS = {
            A3: 220,      // Low A (root)
            C4: 261.63,   // C (major third below E4)
            E4: 330,      // E (perfect fifth above A3)
            A4: 440,      // Standard A (root)
            C5: 523.25,   // C (major third above A4)
            C5_SHARP: 554.37,  // C# (major third in A major)
            D5: 587.33,   // D (fourth in A major)
            E5: 659.25,   // E (perfect fifth above A4)
            G5: 783.99,   // G (major seventh in A major)
            A5: 880,      // High A (octave above A4)
            C6: 1046.50   // C (octave above C5)
        };
        
        // Battle sounds: A major chord tones (A, C#, E) - strong, stable
        const BATTLE_TONES = [
            HARMONICS.A3,      // 220 Hz - Low A
            HARMONICS.E4,      // 330 Hz - E (perfect fifth)
            HARMONICS.A4,      // 440 Hz - A (root)
            HARMONICS.C5_SHARP, // 554.37 Hz - C# (major third)
            HARMONICS.E5       // 659.25 Hz - E (perfect fifth)
        ];
        
        // Love/Mating sounds: C major chord tones (C, E, G) - separated by major third from A
        // C is a major third above A, creating harmonic separation
        const LOVE_TONES = [
            HARMONICS.C4,      // 261.63 Hz - C (major third above A3)
            HARMONICS.C5,      // 523.25 Hz - C (major third above A4)
            HARMONICS.E5,      // 659.25 Hz - E (shared with battle but higher)
            HARMONICS.G5,      // 783.99 Hz - G (major third above E5)
            HARMONICS.C6       // 1046.50 Hz - C (octave)
        ];
        
        // Helper function to get random harmonic frequency from a set
        function getHarmonicFreq(tones, variance = 0) {
            let freq = tones[Math.floor(Math.random() * tones.length)];
            if (variance > 0) {
                freq += (Math.random() - 0.5) * variance;
            }
            return freq;
        }
        
        // Global sound throttling for high-intensity sounds (love, mating, battle) to prevent buzzing
        // Only ONE sound of each type can play per frame globally
        const soundThrottle = {
            lastLoveSoundFrame: -9999, // Initialize to allow first sound
            lastBattleSoundFrame: -9999, // Initialize to allow first sound
            loveSoundCooldown: 150, // Increased: Minimum frames between love sounds
            battleSoundCooldown: 150, // Increased: Minimum frames between battle sounds
            loveSoundPlayedThisFrame: false, // Only one love sound per frame
            battleSoundPlayedThisFrame: false // Only one battle sound per frame
        };

        const RES_TYPES = {
            FOOD: { color: '#4ade80', val: 40, type: 'food', radius: 4 },
            MAT: { color: '#facc15', val: 1, type: 'mat', radius: 6 }, 
            STIM: { color: '#a855f7', val: 300, type: 'stim', radius: 4 },
            SEED: { color: '#f472b6', val: 0, type: 'seed', radius: 3 },
            TREASURE: { color: '#22d3ee', val: 10, type: 'treasure', radius: 5 },
            HERB: { color: '#e879f9', val: 0, type: 'herb', radius: 4 }, 
            ORE: { color: '#94a3b8', val: 10, type: 'ore', radius: 5 }, 
            RELIC: { color: '#67e8f9', val: 50, type: 'relic', radius: 6 },
            UNIQUE: { color: '#a78bfa', val: 150, type: 'unique', radius: 5 }, // Unique resources give random boons to tribes
            BLOCK: { color: '#ffffff', val: 0, type: 'block', radius: 8 } // Blocks are solid white structures that decay
        };

        class Resource {
            constructor(x, y, typeStr, isNestSpawned = false, creatorTribeId = -1) {
                this.pos = new Vector(x, y);
                this.config = RES_TYPES[typeStr];
                // Safety: if type not found, use a default config
                if (!this.config) {
                    console.warn('Unknown resource type:', typeStr, '- using default config');
                    this.config = { color: '#ffffff', val: 1, type: 'unknown', radius: 5 };
                }
                this.type = typeStr;
                this.active = true;
                this.carrier = null;
                this.age = 0; 
                let baseDecay = (CONFIG.resourceDecayTimers && CONFIG.resourceDecayTimers[typeStr]) || CONFIG.matDecay;
                this.decayTimer = baseDecay;
                this.creatorTribe = creatorTribeId;
                if (creatorTribeId !== -1) this.nestId = creatorTribeId;
                
                // Food life system - food dies if not eaten/fertilized
                if (typeStr === 'FOOD' || typeStr === 'SEED') {
                    this.life = CONFIG.foodMinLife + Math.random() * (CONFIG.foodMaxLife - CONFIG.foodMinLife);
                    // Nest-spawned food has shorter lifespan
                    if (isNestSpawned) {
                        this.life *= CONFIG.foodNearNestLifeMultiplier; // 50% lifespan
                    }
                    this.maxLife = this.life;
                } else if (typeStr === 'BLOCK') {
                    // Blocks decay gradually over time
                    this.life = 3840000000; // Blocks last 40,000x longer (was 96,000, now 3.84 billion)
                    this.maxLife = this.life;
                } else {
                    this.life = Infinity; // Non-food resources don't decay naturally
                }
            }
            draw(ctx) {
                if (this.carrier) return; 
                // Safety check: ensure config exists
                if (!this.config || !this.config.color) {
                    console.warn('Resource missing config:', this.type, this);
                    return; // Skip drawing if config is missing
                }
                ctx.fillStyle = this.config.color;
                ctx.beginPath();
                if (this.type === 'MAT') {
                    ctx.globalAlpha = Math.max(0.2, this.decayTimer / CONFIG.matDecay);
                    let s = this.config.radius * 2;
                    ctx.fillRect(this.pos.x - s/2, this.pos.y - s/2, s, s);
                    ctx.strokeStyle = '#b45309';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(this.pos.x - s/2, this.pos.y - s/2, s, s);
                    ctx.globalAlpha = 1.0;
                } else if (this.type === 'TREASURE') {
                    ctx.moveTo(this.pos.x, this.pos.y - 6);
                    ctx.lineTo(this.pos.x + 6, this.pos.y);
                    ctx.lineTo(this.pos.x, this.pos.y + 6);
                    ctx.lineTo(this.pos.x - 6, this.pos.y);
                    ctx.fill();
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                } else if (this.type === 'ORE') {
                    ctx.fillStyle = '#94a3b8';
                    ctx.beginPath();
                    ctx.moveTo(this.pos.x - 4, this.pos.y + 4);
                    ctx.lineTo(this.pos.x + 4, this.pos.y - 4);
                    ctx.lineTo(this.pos.x + 6, this.pos.y);
                    ctx.lineTo(this.pos.x - 2, this.pos.y + 6);
                    ctx.fill();
                    ctx.strokeStyle = '#cbd5e1';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                } else if (this.type === 'RELIC') {
                    ctx.fillStyle = '#67e8f9';
                    ctx.fillRect(this.pos.x - 4, this.pos.y - 4, 8, 8);
                    ctx.strokeStyle = '#fff';
                    ctx.strokeRect(this.pos.x - 4, this.pos.y - 4, 8, 8);
                } else if (this.type === 'SEED') {
                    ctx.arc(this.pos.x, this.pos.y, this.config.radius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = 'rgba(255,255,255,0.5)';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    let progress = this.age / CONFIG.seedGrowthTime;
                    ctx.arc(this.pos.x, this.pos.y, this.config.radius + 2, 0, Math.PI * 2 * progress);
                    ctx.stroke();
                } else if (this.type === 'BLOCK') {
                    // Draw blocks as solid white squares with decay opacity
                    ctx.globalAlpha = Math.max(0.3, this.life / this.maxLife);
                    ctx.fillStyle = '#ffffff'; // White
                    let s = this.config.radius * 2;
                    ctx.fillRect(this.pos.x - s/2, this.pos.y - s/2, s, s);
                    ctx.strokeStyle = '#cccccc'; // Light gray border for visibility
                    ctx.lineWidth = 1;
                    ctx.strokeRect(this.pos.x - s/2, this.pos.y - s/2, s, s);
                    ctx.globalAlpha = 1.0;
                } else {
                    ctx.arc(this.pos.x, this.pos.y, this.config.radius, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        class Plague {
            constructor(x, y) {
                this.pos = new Vector(x, y);
                this.radius = 30; // Reduced from 60 (50% reduction) - smaller range
                this.life = 1800; // 30 seconds at 60 fps (30 * 60 = 1800 frames)
            }
            update() {
                this.life--;
                this.pos.x += (Math.random()-0.5) * 4.0; 
                this.pos.y += (Math.random()-0.5) * 4.0;
            }
            draw(ctx) {
                ctx.fillStyle = '#22c55e';
                ctx.globalAlpha = Math.max(0, (this.life/5000) * 0.4);
                ctx.beginPath();
                ctx.arc(this.pos.x, this.pos.y, this.radius, 0, Math.PI*2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
            }
        }

        class SpawnPoint {
            constructor(x, y, tribeId) {
                this.pos = new Vector(x, y);
                this.tribeId = tribeId;
                this.life = 1500; // 1500 steps lifetime
                this.maxLife = 1500;
                this.nextSpawn = 0; // Frame when next spawn should occur
                this.spawnInterval = 20; // 1 spawn per 20 steps
                this.radius = 15; // Visual size
            }
            update(sim) {
                this.life--;
                
                // Cost energy to tribe while spawn point exists
                if (typeof sim !== 'undefined' && sim.tribes) {
                    let tribe = sim.tribes.tribes[this.tribeId];
                    if (tribe) {
                        let nest = sim.tribes.nests.find(n => n.tribeId === this.tribeId);
                        if (nest && nest.wealth > 0) {
                            // Low to moderate energy cost per frame
                            nest.wealth -= 0.05; // Small ongoing cost
                        }
                    }
                }
                
                // Spawn agents
                if (this.life > 0 && typeof sim !== 'undefined' && sim.frame >= this.nextSpawn) {
                    // Check for scientist boost (double spawn rate)
                    // PERFORMANCE: Cache scientist count check - only check every 60 frames (1 second)
                    let spawnRateMultiplier = 1.0;
                    if (typeof sim !== 'undefined' && sim.agents) {
                        let tribe = sim.tribes.tribes[this.tribeId];
                        if (tribe) {
                            // Cache scientist count per tribe - update every 60 frames
                            if (!tribe._cachedScientistCount || (sim.frame % 60 === 0)) {
                                tribe._cachedScientistCount = sim.agents.filter(a => 
                                    a.tribeId === this.tribeId && 
                                    a.role === 'Scientist' && 
                                    !a.dead
                                ).length;
                            }
                            if (tribe._cachedScientistCount > 0) {
                                spawnRateMultiplier = 2.0; // Double spawn rate
                            }
                        }
                    }
                    
                    // Adjust spawn interval based on multiplier (lower interval = faster spawning)
                    let effectiveInterval = Math.floor(this.spawnInterval / spawnRateMultiplier);
                    // Check if tribe has required tech tier (at least tier 1 for spawn points)
                    let tribe = sim.tribes.tribes[this.tribeId];
                    if (tribe && tribe.techTier >= 1) { // Medium-high tech requires at least tier 1
                        // Get available roles (filter to tier 1+ roles only for spawn points)
                        let allRoles = getAvailableRoles(tribe.techTier);
                        let mediumHighTechRoles = allRoles.filter(role => getRequiredTechTier(role) >= 1);
                        
                        if (mediumHighTechRoles.length > 0) {
                            let currentCounts = getRoleCounts(sim.agents, this.tribeId);
                            let roleCaps = CONFIG.agentRoleCaps || {};
                            let spawnRates = CONFIG.agentSpawnRates || {};
                            let role = weightedRandomRole(mediumHighTechRoles, currentCounts, roleCaps, spawnRates, { targetPerRole: 5 });
                            
                            if (role) {
                                // Check if at cap
                                let cap = roleCaps[role] || Infinity;
                                let current = currentCounts[role] || 0;
                                if (current < cap) {
                                    let agent = sim.spawnAgent(role, null);
                                    if (agent) {
                                        agent.role = role;
                                        agent.determineRole();
                                        agent.tribeId = this.tribeId;
                                        if (tribe) {
                                            agent.color = tribe.color;
                                        }
                                        // Spawn near the spawn point
                                        let angle = Math.random() * Math.PI * 2;
                                        let offset = 10 + Math.random() * 10;
                                        agent.pos.x = this.pos.x + Math.cos(angle) * offset;
                                        agent.pos.y = this.pos.y + Math.sin(angle) * offset;
                                        agent.createInitialResources();
                                        // Green spatter effect when spawning
                                        for (let i = 0; i < 8; i++) {
                                            let spatterAngle = (i / 8) * Math.PI * 2;
                                            let spatterDist = 5 + Math.random() * 10;
                                            sim.particles.push(new Particle(
                                                this.pos.x + Math.cos(spatterAngle) * spatterDist,
                                                this.pos.y + Math.sin(spatterAngle) * spatterDist,
                                                '#22c55e', 'spark'
                                            ));
                                        }
                                        sim.particles.push(new Particle(this.pos.x, this.pos.y, '#10b981', 'explosion')); // Green explosion
                                    }
                                }
                            }
                        }
                    }
                    
                    this.nextSpawn = sim.frame + effectiveInterval;
                }
            }
            draw(ctx) {
                // Draw as triangle
                ctx.save();
                ctx.globalAlpha = Math.max(0.3, this.life / this.maxLife);
                ctx.fillStyle = '#06b6d4';
                ctx.strokeStyle = '#22d3ee';
                ctx.lineWidth = 2;
                
                ctx.beginPath();
                // Draw upward-pointing triangle
                let size = this.radius;
                ctx.moveTo(this.pos.x, this.pos.y - size);
                ctx.lineTo(this.pos.x - size * 0.866, this.pos.y + size * 0.5);
                ctx.lineTo(this.pos.x + size * 0.866, this.pos.y + size * 0.5);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                
                ctx.globalAlpha = 1.0;
                ctx.restore();
            }
        }

        class Nest {
            constructor(x, y, tribeId) {
                this.pos = new Vector(x, y);
                this.tribeId = tribeId;
                this.wealth = 500; // Start with substantial wealth (was 0!)
                this.hp = 1000;
                this.defenseLevel = 0; 
                this.radius = 20;
                this.creationFrame = typeof sim !== 'undefined' ? sim.frame : 0;
                
                // Unique resource: each nest amplifies a specific random gene
                const geneOptions = ['aggression', 'defense', 'botany', 'manufacturing', 'intelligence', 
                                     'commerce', 'curiosity', 'social', 'altruism', 'speed'];
                this.uniqueGene = geneOptions[Math.floor(Math.random() * geneOptions.length)];
                this.resourceColor = `hsl(${Math.random() * 360}, 80%, 60%)`;
                
                this.maxHealth = 1000;
                this.health = 1000;
                this.driftMomentum = new Vector(0, 0);
                this.tools = [];
                this.lastToolSpawnFrame = 0;
                this.toolIdCounter = 0;
                this.babyBoom = 0; // Post-war baby boom counter (0 = inactive, >0 = active)
                
                // Track tethered agents for regeneration
                this.tetheredSoldierIds = []; // IDs of soldiers tethered to this nest
                this.tetheredGuardianIds = []; // IDs of guardians tethered to this nest
                this.lastTetheredCheckFrame = 0; // Frame when we last checked tethered agents
            }
            update() {
                // Check if nest is in baby boom (post-war reconstruction period)
                let isInBabyBoom = this.babyBoom > 0;
                
                // Check if nest is at war - war increases resource consumption by 10%
                // COUNT ACTIVE WARS - Costs are additive for each war
                let warCount = 0;
                if (typeof sim !== 'undefined' && sim.tribes) {
                    let tribe = sim.tribes.tribes[this.tribeId];
                    if (tribe && tribe.atWarWith) {
                        // Count how many wars the tribe is actively engaged in
                        for (let otherId in tribe.atWarWith) {
                            if (tribe.atWarWith[otherId] === true) {
                                warCount++;
                            }
                        }
                    }
                }
                // War costs are additive: 80% per war (1 war = 1.8x, 2 wars = 2.6x, 3 wars = 3.4x, etc.)
                // REDUCED during baby boom - winners have lower costs during reconstruction
                let warConsumptionMultiplier = (1.0 + (warCount * 0.8)) * (isInBabyBoom ? 0.5 : 1.0); // 50% reduction during baby boom
                
                // DIRECT WAR HP DAMAGE - War causes direct structural damage (wear and tear)
                // PAUSED during baby boom - war winners need to recover without ongoing damage
                // REDUCED damage to prevent both parties from dying - war should be costly but survivable
                if (warCount > 0 && !isInBabyBoom) {
                    // Only apply war damage if NOT in baby boom (winners need recovery time)
                    let warHpDamage = Math.pow(warCount, 1.2) * 0.3; // Reduced from 1.0 to 0.3, and lower exponent (1.2 vs 1.5)
                    // Lower frequency: 30% chance per frame instead of 50%
                    if (Math.random() < 0.3) { // 30% chance per frame (was 50%)
                        this.hp = Math.max(200, this.hp - warHpDamage);
                    }
                }
                
                // HP MAINTENANCE COSTS - High HP requires resources to maintain!
                // REDUCED during baby boom - war winners have reduced maintenance costs during reconstruction
                let maintenanceCostMultiplier = isInBabyBoom ? 0.3 : 1.0; // 70% reduction during baby boom
                
                let maintenanceCost = Math.max(0, (this.hp - 500) / 100); // Cost increases above 500 HP
                
                if (this.wealth > maintenanceCost * 2) {
                    // Can afford maintenance - pay the cost (scaled by war, reduced during baby boom)
                    this.wealth -= maintenanceCost * 0.1 * warConsumptionMultiplier * maintenanceCostMultiplier; // Reduced cost during baby boom
                } else {
                    // Can't afford maintenance - HP slowly decays (INCREASED during war, but REDUCED during baby boom)
                    if (Math.random() < 0.3) { // 30% chance per frame
                        this.hp -= Math.ceil((maintenanceCost / 8) * warConsumptionMultiplier * maintenanceCostMultiplier); // Reduced decay during baby boom
                    }
                }
                
                // ACCELERATED STRUCTURAL DECAY DURING WAR - Much faster decay when at war
                // PAUSED during baby boom - war winners need time to recover without decay pressure
                if (!isInBabyBoom) {
                    // Only apply decay if NOT in baby boom (winners need recovery time)
                    let baseDecayRate = CONFIG.nestHpDecayRate || 0.005; // Further reduced from 0.00825 (40% reduction)
                    // Much slower war acceleration: warCount^1.2 * 0.02 (reduced from 0.04 and lower exponent)
                    // 1 war = +0.02, 2 wars = +0.05, 3 wars = +0.09, 4 wars = +0.14 (much more sustainable)
                    let warDecayAcceleration = Math.pow(warCount, 1.2) * 0.02; // Further reduced from 0.04 (50% reduction)
                    let decayRate = baseDecayRate + warDecayAcceleration; // Exponential acceleration
                    if (Math.random() < decayRate) {
                        // War causes decay bursts, but much smaller and more sustainable
                        let decayAmount = warCount > 0 ? Math.ceil(0.5 + (Math.pow(warCount, 1.1) * 0.3)) : 0.5; // Reduced from 0.5 and lower exponent
                        this.hp = Math.max(200, this.hp - decayAmount);
                    }
                }
                
                // DELICATE NEST GROWTH/DECAY MECHANISM - Nests grow when thriving, decay when struggling
                // PAUSED during baby boom - war winners need to recover without decay pressure
                // This creates dynamic nest health based on conditions without killing nests too fast
                if (typeof sim !== 'undefined' && sim.frame % 60 === 0 && !isInBabyBoom) { // Check every 60 frames, PAUSED during baby boom
                    let tribe = sim.tribes && sim.tribes.tribes[this.tribeId];
                    if (tribe) {
                        // Count active wars for thriving score calculation
                        let warCountForThriving = 0;
                        if (tribe.atWarWith) {
                            for (let otherId in tribe.atWarWith) {
                                if (tribe.atWarWith[otherId] === true) {
                                    warCountForThriving++;
                                }
                            }
                        }
                        
                        // Calculate nest "thriving" score (0.0 to 1.0+)
                        // Positive values = thriving (should grow), Negative values = struggling (should decay)
                        let thrivingScore = 0;
                        
                        // 1. Wealth factor (0 to +0.4)
                        // Wealthy nests (above 500) should grow, poor nests (below 200) should decay
                        if (this.wealth > 500) {
                            thrivingScore += 0.4 * Math.min(1.0, (this.wealth - 500) / 1000); // Up to +0.4 for very wealthy
                        } else if (this.wealth < 200) {
                            thrivingScore -= 0.3 * (1.0 - this.wealth / 200); // Up to -0.3 for very poor
                        }
                        
                        // 2. HP health factor (0 to +0.3)
                        // Healthy nests (above 70% HP) should grow, damaged nests (below 40%) should decay
                        let hpRatio = this.hp / this.maxHealth;
                        if (hpRatio > 0.7) {
                            thrivingScore += 0.3 * ((hpRatio - 0.7) / 0.3); // Up to +0.3 for very healthy
                        } else if (hpRatio < 0.4) {
                            thrivingScore -= 0.2 * ((0.4 - hpRatio) / 0.4); // Up to -0.2 for very damaged
                        }
                        
                        // 3. Agent count factor (0 to +0.2)
                        // Nests with many agents should grow, nests with few agents should decay
                        // PERFORMANCE: Cache agent count per tribe (update every 30 frames)
                        let agentCount = 0;
                        if (sim && sim.agents) {
                            let cached = sim._cachedTribeAgentCounts[this.tribeId];
                            if (!cached || (sim.frame - cached.lastUpdate > 30)) {
                                agentCount = sim.agents.filter(a => a.tribeId === this.tribeId && !a.dead).length;
                                sim._cachedTribeAgentCounts[this.tribeId] = { count: agentCount, lastUpdate: sim.frame };
                            } else {
                                agentCount = cached.count;
                            }
                        }
                        let optimalAgentCount = 15; // Optimal number of agents per nest
                        if (agentCount > optimalAgentCount) {
                            thrivingScore += 0.2 * Math.min(1.0, (agentCount - optimalAgentCount) / 10); // Up to +0.2 for many agents
                        } else if (agentCount < optimalAgentCount * 0.4) {
                            thrivingScore -= 0.15 * (1.0 - agentCount / (optimalAgentCount * 0.4)); // Up to -0.15 for very few agents
                        }
                        
                        // 4. War penalty (-0.4 per war, additive) - Doubled for 2x war cost
                        // Nests at war should decay - more wars = more decay
                        if (warCountForThriving > 0) {
                            thrivingScore -= 0.4 * warCountForThriving; // Each war adds -0.4 penalty (doubled)
                        }
                        
                        // 5. Economic bonds structural increase (+0.08 per bond, stacking)
                        // Nests with commercial bonds experience moderate structural growth
                        let commercialBondCountForGrowth = 0;
                        if (tribe.commercialBonds) {
                            for (let otherId in tribe.commercialBonds) {
                                if (tribe.commercialBonds[otherId] > 10) { // Meaningful bond threshold
                                    commercialBondCountForGrowth++;
                                }
                            }
                        }
                        if (commercialBondCountForGrowth > 0) {
                            // Moderate structural increase: +0.08 per bond, stacking
                            // This growth can partially offset war decay if bonds are strong
                            thrivingScore += 0.08 * commercialBondCountForGrowth; // Stacking bonus per bond
                        }
                        
                        // 6. Under attack penalty (-0.15)
                        // Nests under attack should decay slightly
                        if (tribe.underAttack) {
                            thrivingScore -= 0.15;
                        }
                        
                        // BUILDER REPAIR BOOST: Builders increase structural decay recovery rate
                        let builderRepairMultiplier = 1.0;
                        if (typeof sim !== 'undefined' && sim.agents && sim.spatialGrid && sim.gridCols > 0) {
                            // PERFORMANCE: Use spatial grid to find builders near nest
                            let nearby = sim.getNearbyEntities(this.pos.x, this.pos.y, this.radius);
                            let buildersInNest = nearby.agents.filter(a => 
                                a.role === 'Builder' && 
                                a.tribeId === this.tribeId && 
                                !a.dead &&
                                Vector.dist(a.pos, this.pos) < this.radius
                            );
                            if (buildersInNest.length > 0) {
                                // Each builder increases repair rate by 50% (stacking)
                                builderRepairMultiplier = 1.0 + (buildersInNest.length * 0.5); // 1 builder = 1.5x, 2 builders = 2.0x, etc.
                            }
                        } else if (typeof sim !== 'undefined' && sim.agents) {
                            // Fallback: direct filter if spatial grid not available
                            let buildersInNest = sim.agents.filter(a => 
                                a.role === 'Builder' && 
                                a.tribeId === this.tribeId && 
                                !a.dead &&
                                Vector.dist(a.pos, this.pos) < this.radius
                            );
                            if (buildersInNest.length > 0) {
                                builderRepairMultiplier = 1.0 + (buildersInNest.length * 0.5);
                            }
                        }
                        
                        // Apply growth/decay based on thriving score
                        // IMPORTANT: During war, decay and repair are both applied
                        // Economic bond growth can help offset war decay, but war decay is applied first
                        // Very delicate: 0.5 to 1.5 HP per check, based on thriving score
                        // Positive score ‚Üí grow, Negative score ‚Üí decay
                        // BUILDERS DOUBLE THE RECOVERY RATE (apply multiplier to growth)
                        if (thrivingScore > 0.05) {
                            // Growing: Very slow HP growth (delicate) - BUILDER BOOSTED
                            let growthAmount = Math.min(1.5, thrivingScore * 2.0) * builderRepairMultiplier; // Max 1.5 HP per check, multiplied by builder boost
                            this.hp = Math.min(this.maxHealth, this.hp + growthAmount);
                            // Also regenerate wealth slightly when thriving
                            if (this.wealth < 1000 && Math.random() < 0.1) {
                                this.wealth += 1;
                            }
                            
                            // BLOCKS GENERATE ONGOING WEALTH: Each block owned by this nest generates small wealth
                            if (typeof sim !== 'undefined' && sim.resources && sim.frame % 60 === 0) {
                                let blockCount = 0;
                                if (sim.spatialGrid && sim.gridCols > 0) {
                                    // Use spatial grid for performance
                                    let nearby = sim.getNearbyEntities(this.pos.x, this.pos.y, this.radius * 5);
                                    blockCount = nearby.resources.filter(r => 
                                        r.type === 'BLOCK' && 
                                        r.active && 
                                        r.creatorTribe === this.tribeId
                                    ).length;
                                } else {
                                    // Fallback: direct filter
                                    blockCount = sim.resources.filter(r => 
                                        r.type === 'BLOCK' && 
                                        r.active && 
                                        r.creatorTribe === this.tribeId
                                    ).length;
                                }
                                // Each block generates 0.1 wealth per 60 frames (0.1 wealth per second at 60 FPS)
                                this.wealth += blockCount * 0.1;
                            }
                        } else if (thrivingScore < -0.05) {
                            // Decaying: Very slow HP decay (delicate)
                            // BUILDERS REDUCE DECAY RATE (apply inverse multiplier to decay)
                            let decayAmount = Math.min(1.5, Math.abs(thrivingScore) * 2.0) / builderRepairMultiplier; // Max 1.5 HP per check, reduced by builder boost
                            this.hp = Math.max(200, this.hp - decayAmount); // Never go below 200 HP from this
                        }
                        // If thrivingScore is between -0.05 and +0.05, no change (stable)
                    }
                }
                
                // NEST AGENT SPAWNING - Randomly spawn agents up to tech level
                // New nests are more fertile - 10% higher spawn rate for first 1000 frames
                // Tech-based spawn bonus: 50% more spawning based on tech level
                if (typeof sim !== 'undefined' && sim.agents && sim.frame % 50 === 0) {
                    let nestAge = sim.frame - this.creationFrame;
                    let isNewNest = nestAge < 1000;
                    let spawnRate = CONFIG.nestAgentSpawnRate || 0.003;
                    if (isNewNest) {
                        spawnRate *= 1.1; // 10% boost for new nests
                        // Apply UNIQUE resource spawn boost if active
                        if (this.uniqueSpawnBoost && this.uniqueSpawnBoost > 0) {
                            spawnRate *= 1.5; // 50% spawn boost from UNIQUE resource
                            this.uniqueSpawnBoost--; // Decrement boost timer
                        }
                    }
                    
                    // TECH-BASED SPAWN BONUS: 50% more spawning per tech tier (ongoing)
                    let tribe = sim.tribes && sim.tribes.tribes[this.tribeId];
                    if (tribe && tribe.techTier !== undefined) {
                        let techSpawnBonus = 1.0 + (tribe.techTier * 0.5); // +50% per tech tier (1.0x, 1.5x, 2.0x, etc.)
                        spawnRate *= techSpawnBonus;
                    }
                    
                    // Check for POST-WAR BABY BOOM - 10x spawning of all agent types
                    let isInBabyBoom = this.babyBoom > 0;
                    
                    if (isInBabyBoom) {
                        // BABY BOOM - Massive spawning of ALL agent types
                        // Wealth factor is more generous - full rate at lower wealth threshold
                        let wealthFactor = Math.min(1.0, this.wealth / 200); // Full rate at 200+ wealth
                        let festivalSpawnRate = (CONFIG.nestAgentSpawnRate || 0.02) * 10.0; // 10x normal rate
                        
                        // Only spawn if nest has enough wealth to support new agents
                        // Lower threshold - winners can spawn even with less wealth (baby boom is strong!)
                        let minWealthForSpawn = 30; // REDUCED: 30 wealth minimum (was 50)
                        if (this.wealth >= minWealthForSpawn && Math.random() < festivalSpawnRate) {
                            let tribe = sim.tribes && sim.tribes.tribes[this.tribeId];
                            if (tribe && tribe.techTier !== undefined) {
                                // Use centralized function to get available roles
                                let allAvailableRoles = getAvailableRoles(tribe.techTier);
                                let currentCounts = getRoleCounts(sim.agents, this.tribeId);
                                let roleCaps = CONFIG.agentRoleCaps || {};
                                let spawnRates = CONFIG.agentSpawnRates || {};
                                
                                // Spawn multiple agents during baby boom (celebration!)
                                // More generous wealth limits - baby boom should be strong!
                                let maxAffordableAgents = Math.floor(this.wealth / 30); // REDUCED: 30 wealth per agent (was 50)
                                let numToSpawn = Math.min(3 + Math.floor(Math.random() * 5), maxAffordableAgents, 5); // INCREASED: 3-5 agents (was 2-3), limited by wealth
                                let spawnedCount = 0;
                                
                                // Lower wealth threshold - allow spawning with less wealth during baby boom
                                // Use weighted random selection respecting spawn rates and caps
                                for (let i = 0; i < numToSpawn && spawnedCount < 5 && this.wealth >= 20; i++) { // INCREASED: 5 max (was 3), 20 wealth minimum (was 30)
                                    let role = weightedRandomRole(allAvailableRoles, currentCounts, roleCaps, spawnRates, { targetPerRole: 5 });
                                    if (!role) break; // No more roles available
                                    
                                    // Check if at cap
                                    let cap = roleCaps[role] || Infinity;
                                    let current = currentCounts[role] || 0;
                                    if (current >= cap) continue; // Skip if at cap
                                    
                                    let agent = sim.spawnAgent(role, this);
                                    if (agent) {
                                        agent.role = role;
                                        agent.determineRole();
                                        // Update counts
                                        currentCounts[role] = (currentCounts[role] || 0) + 1;
                                        
                                        let angle = (spawnedCount / numToSpawn) * Math.PI * 2;
                                        let offset = 20 + Math.random() * 15;
                                        agent.pos.x += Math.cos(angle) * offset;
                                        agent.pos.y += Math.sin(angle) * offset;
                                        // Celebration VFX - golden stars for baby boom
                                        sim.particles.push(new Particle(agent.pos.x, agent.pos.y, '#fbbf24', 'star'));
                                        // Green spatter effect at nest position when spawning (only once per spawn event)
                                        if (spawnedCount === 0) {
                                            for (let i = 0; i < 8; i++) {
                                                let spatterAngle = (i / 8) * Math.PI * 2;
                                                let spatterDist = 5 + Math.random() * 10;
                                                sim.particles.push(new Particle(
                                                    this.pos.x + Math.cos(spatterAngle) * spatterDist,
                                                    this.pos.y + Math.sin(spatterAngle) * spatterDist,
                                                    '#22c55e', 'spark'
                                                ));
                                            }
                                            sim.particles.push(new Particle(this.pos.x, this.pos.y, '#10b981', 'explosion')); // Green explosion
                                        }
                                        // Celebration SFX for baby boom
                                        if (spawnedCount === 0) { // Play once per spawn event
                                            // Vary birth tone - wider range
                                            // TEMPORARILY DISABLED FOR TESTING
                                            // sfx.play('birth', getHarmonicFreq([HARMONICS.C4, HARMONICS.E4, HARMONICS.A4, HARMONICS.C5, HARMONICS.E5, HARMONICS.G5, HARMONICS.A5], 12), 0.08);
                                        }
                                        spawnedCount++;
                                    }
                                }
                            }
                        }
                    }
                    
                    // Check if tribe is at war - massively increase fighting role spawn rate
                    let isAtWar = false;
                    let warCount = 0;
                    if (typeof sim.tribes !== 'undefined' && sim.tribes.tribes) {
                        let tribe = sim.tribes.tribes[this.tribeId];
                        if (tribe && tribe.atWarWith) {
                            for (let otherId in tribe.atWarWith) {
                                if (tribe.atWarWith[otherId] === true) {
                                    isAtWar = true;
                                    warCount++;
                                }
                            }
                    }
                    
                    // Check for COMMERCIAL BONDS - Economic benefits for trading nests
                    let hasCommercialBonds = false;
                    let commercialBondCount = 0;
                    if (typeof sim.tribes !== 'undefined' && sim.tribes.tribes) {
                        let tribe = sim.tribes.tribes[this.tribeId];
                        if (tribe && tribe.commercialBonds) {
                            for (let otherId in tribe.commercialBonds) {
                                if (tribe.commercialBonds[otherId] > 10) { // Meaningful bond threshold
                                    hasCommercialBonds = true;
                                    commercialBondCount++;
                                }
                            }
                        }
                    }
                    
                    // ECONOMIC BOND BENEFITS - Increased spawning of money-making roles
                    if (hasCommercialBonds && !isInBabyBoom) {
                        let moneyMakingRoles = ['Merchant', 'Artisan', 'Miner', 'Builder', 'Farmer'];
                        let economicSpawnBonus = 1.0 + (commercialBondCount * 0.15); // 15% per bond, modest increase
                        let economicSpawnRate = (CONFIG.nestAgentSpawnRate || 0.003) * economicSpawnBonus;
                        
                        if (Math.random() < economicSpawnRate) {
                            let tribe = sim.tribes && sim.tribes.tribes[this.tribeId];
                            if (tribe && tribe.techTier !== undefined) {
                                let availableMoneyRoles = moneyMakingRoles.filter(role => {
                                    let requiredTier = getRequiredTechTier(role);
                                    return tribe.techTier >= requiredTier || isBasicRole(role);
                                });
                                
                                if (availableMoneyRoles.length > 0) {
                                    let currentCounts = getRoleCounts(sim.agents, this.tribeId);
                                    let roleCaps = CONFIG.agentRoleCaps || {};
                                    let spawnRates = CONFIG.agentSpawnRates || {};
                                    let role = weightedRandomRole(availableMoneyRoles, currentCounts, roleCaps, spawnRates, { economic: true, targetPerRole: 5 });
                                    if (!role) return; // No roles available
                                    
                                    // Check if at cap
                                    let cap = roleCaps[role] || Infinity;
                                    let current = currentCounts[role] || 0;
                                    if (current >= cap) return; // At cap, skip
                                    
                                    let agent = sim.spawnAgent(role, this);
                                    if (agent) {
                                        agent.role = role;
                                        agent.determineRole();
                                        let angle = Math.random() * Math.PI * 2;
                                        let offset = 20 + Math.random() * 10;
                                        agent.pos.x += Math.cos(angle) * offset;
                                        agent.pos.y += Math.sin(angle) * offset;
                                        sim.particles.push(new Particle(agent.pos.x, agent.pos.y, '#10b981', 'coin')); // Green for economic spawn
                                        // Green spatter effect at nest position when spawning
                                        for (let i = 0; i < 8; i++) {
                                            let spatterAngle = (i / 8) * Math.PI * 2;
                                            let spatterDist = 5 + Math.random() * 10;
                                            sim.particles.push(new Particle(
                                                this.pos.x + Math.cos(spatterAngle) * spatterDist,
                                                this.pos.y + Math.sin(spatterAngle) * spatterDist,
                                                '#22c55e', 'spark'
                                            ));
                                        }
                                        sim.particles.push(new Particle(this.pos.x, this.pos.y, '#10b981', 'explosion')); // Green explosion
                                        // SFX for economic bond spawning
                                        // Vary spawn tone - use wider range of notes
                                        let spawnNotes = [HARMONICS.C4, HARMONICS.E4, HARMONICS.A4, HARMONICS.C5, HARMONICS.D5, HARMONICS.E5];
                                        // TEMPORARILY DISABLED FOR TESTING
                                        // sfx.play('spawn', getHarmonicFreq(spawnNotes, 8), 0.08);
                                    }
                                }
                            }
                        }
                    }
                    
                    // WAR-TIME FIGHTING ROLE SPAWNING - 10x spawn rate for fighting roles during war (skip during baby boom)
                    if (isAtWar && !isInBabyBoom) {
                        let fightingRoleSpawnRate = (CONFIG.nestAgentSpawnRate || 0.003) * 10.0; // 10x normal rate
                        let fightingRoles = ['Soldier', 'Raider', 'Guardian'];
                        
                        // Check tech tier for fighting roles using centralized function
                        let tribeForWar = sim.tribes && sim.tribes.tribes[this.tribeId];
                        let availableFightingRoles = [];
                        if (tribeForWar && tribeForWar.techTier !== undefined) {
                            availableFightingRoles = fightingRoles.filter(role => {
                                let requiredTier = getRequiredTechTier(role);
                                return tribeForWar.techTier >= requiredTier || isBasicRole(role);
                            });
                        } else {
                            // Fallback: at least spawn Soldiers
                            availableFightingRoles = ['Soldier'];
                        }
                        
                        // Spawn fighting roles at 10x rate during war
                        if (availableFightingRoles.length > 0 && Math.random() < fightingRoleSpawnRate) {
                            let currentCounts = getRoleCounts(sim.agents, this.tribeId);
                            let roleCaps = CONFIG.agentRoleCaps || {};
                            let spawnRates = CONFIG.agentSpawnRates || {};
                            let role = weightedRandomRole(availableFightingRoles, currentCounts, roleCaps, spawnRates, { war: true, targetPerRole: 5 });
                            if (!role) return; // No roles available
                            
                            // Check if at cap
                            let cap = roleCaps[role] || Infinity;
                            let current = currentCounts[role] || 0;
                            if (current >= cap) return; // At cap, skip
                            
                            let agent = sim.spawnAgent(role, this);
                            if (agent) {
                                agent.role = role;
                                agent.determineRole();
                                // Offset spawn position
                                let angle = Math.random() * Math.PI * 2;
                                let offset = 15 + Math.random() * 10;
                                agent.pos.x += Math.cos(angle) * offset;
                                agent.pos.y += Math.sin(angle) * offset;
                                sim.particles.push(new Particle(agent.pos.x, agent.pos.y, '#dc2626', 'spark')); // Red for war spawns
                                // Green spatter effect at nest position when spawning
                                for (let i = 0; i < 8; i++) {
                                    let spatterAngle = (i / 8) * Math.PI * 2;
                                    let spatterDist = 5 + Math.random() * 10;
                                    sim.particles.push(new Particle(
                                        this.pos.x + Math.cos(spatterAngle) * spatterDist,
                                        this.pos.y + Math.sin(spatterAngle) * spatterDist,
                                        '#22c55e', 'spark'
                                    ));
                                }
                                sim.particles.push(new Particle(this.pos.x, this.pos.y, '#10b981', 'explosion')); // Green explosion
                            }
                        }
                    }
                    
                    // Normal agent spawning (reduced priority during war, but still happens)
                    if (Math.random() < spawnRate) {
                        let tribe = sim.tribes && sim.tribes.tribes[this.tribeId];
                        if (tribe && tribe.techTier !== undefined) {
                            // Use centralized function to get available roles
                            let allAvailableRoles = getAvailableRoles(tribe.techTier);
                            
                            // Check for modifiers (used in weighted selection)
                            let hasTeachersScientists = false;
                            let hasNearbyBlocks = false;
                            
                            // Check for Teachers/Scientists
                            if (sim && sim.agents) {
                                let tribeMembers = sim.agents.filter(a => a.tribeId === this.tribeId && !a.dead);
                                hasTeachersScientists = tribeMembers.some(a => a.role === 'Teacher') || 
                                                       tribeMembers.some(a => a.role === 'Scientist');
                            }
                            
                            // Check for nearby blocks
                            if (typeof sim !== 'undefined' && sim.spatialGrid && sim.gridCols > 0) {
                                let nearby = sim.getNearbyEntities(this.pos.x, this.pos.y, this.radius + 100);
                                hasNearbyBlocks = nearby.resources.some(r => 
                                    r.type === 'BLOCK' && r.active && r.creatorTribe === this.tribeId
                                );
                            }
                            
                            // WORKFORCE MANAGEMENT: Use weighted random selection based on spawn rates
                            // Get current agent counts by role for this tribe
                            let currentCounts = getRoleCounts(sim.agents, this.tribeId);
                            let roleCaps = CONFIG.agentRoleCaps || {};
                            let spawnRates = CONFIG.agentSpawnRates || {};
                            
                            // Define target workforce: 5 agents of each available role type (increased from 3)
                            let targetPerRole = 5;
                            
                            // Build modifiers object
                            let modifiers = {
                                war: isAtWar,
                                economic: hasCommercialBonds,
                                hasTeachersScientists: hasTeachersScientists,
                                hasNearbyBlocks: hasNearbyBlocks,
                                targetPerRole: targetPerRole
                            };
                            
                            // Spawn agents using weighted random selection (respects spawn rates and caps)
                            let spawnedCount = 0;
                            let maxSpawnPerEvent = 6; // Reduced from 18 - spawn fewer but smarter
                            
                            // Organize roles by tech tier for spawning order
                            let rolesByTier = { 0: [], 1: [], 2: [] };
                            allAvailableRoles.forEach(role => {
                                let tier = getRequiredTechTier(role);
                                if (rolesByTier[tier] === undefined) rolesByTier[tier] = [];
                                rolesByTier[tier].push(role);
                            });
                            
                            // Spawn in tier order: 0, then 1, then 2
                            for (let tier = 0; tier <= 2; tier++) {
                                if (spawnedCount >= maxSpawnPerEvent) break;
                                if (!rolesByTier[tier] || rolesByTier[tier].length === 0) continue;
                                
                                // Spawn 1-2 agents per tier, using weighted selection
                                let tierSpawns = tier === 0 ? 2 : 1; // More basic roles, fewer advanced
                                for (let i = 0; i < tierSpawns && spawnedCount < maxSpawnPerEvent; i++) {
                                    let role = weightedRandomRole(rolesByTier[tier], currentCounts, roleCaps, spawnRates, modifiers);
                                    if (role) {
                                        // Check if we're at cap
                                        let cap = roleCaps[role] || Infinity;
                                        let current = currentCounts[role] || 0;
                                        if (current >= cap) continue; // Skip if at cap
                                        
                                        let agent = sim.spawnAgent(role, this);
                                        if (agent) {
                                            agent.role = role;
                                            agent.determineRole();
                                            // Slightly offset spawn positions so they don't overlap
                                            let angle = (spawnedCount / maxSpawnPerEvent) * Math.PI * 2;
                                            let offset = 15 + Math.random() * 10;
                                            agent.pos.x += Math.cos(angle) * offset;
                                            agent.pos.y += Math.sin(angle) * offset;
                                            
                                            // Update counts
                                            currentCounts[role] = (currentCounts[role] || 0) + 1;
                                            
                                            sim.particles.push(new Particle(agent.pos.x, agent.pos.y, '#60a5fa', 'spark'));
                                            // Green spatter effect at nest position when spawning
                                            if (spawnedCount === 0) { // Only add spatter once per spawn event
                                                for (let i = 0; i < 8; i++) {
                                                    let spatterAngle = (i / 8) * Math.PI * 2;
                                                    let spatterDist = 5 + Math.random() * 10;
                                                    sim.particles.push(new Particle(
                                                        this.pos.x + Math.cos(spatterAngle) * spatterDist,
                                                        this.pos.y + Math.sin(spatterAngle) * spatterDist,
                                                        '#22c55e', 'spark'
                                                    ));
                                                }
                                                sim.particles.push(new Particle(this.pos.x, this.pos.y, '#10b981', 'explosion')); // Green explosion
                                                // SFX for normal spawning
                                                // Vary spawn tone - use wider range of notes
                                                let spawnNotes2 = [HARMONICS.C4, HARMONICS.E4, HARMONICS.A4, HARMONICS.C5, HARMONICS.D5, HARMONICS.E5];
                                                // TEMPORARILY DISABLED FOR TESTING
                                                // sfx.play('spawn', getHarmonicFreq(spawnNotes2, 8), 0.06);
                                            }
                                            spawnedCount++;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                
                this.health = this.hp; // Sync health with hp
                this.defenseLevel = Math.floor(this.hp / 500); 
                
                // Decrement baby boom counter and maintain prosperity bonus
                if (this.babyBoom > 0) {
                    this.babyBoom--;
                    
                    // CONTINUOUS HP REGENERATION during baby boom - Winners recover from war damage
                    // War winners heal continuously during baby boom to survive the reconstruction period
                    if (typeof sim !== 'undefined' && sim.frame % 20 === 0) { // Every 20 frames
                        // Regenerate HP (post-war reconstruction and healing)
                        let hpRegen = Math.min(5, (this.maxHealth - this.hp) * 0.02); // Up to 5 HP per check, 2% of missing HP
                        this.hp = Math.min(this.maxHealth, this.hp + hpRegen);
                        this.health = Math.min(this.maxHealth, this.hp); // Sync health property
                    }
                    
                    // CONTINUOUS WEALTH GENERATION during baby boom to support workforce (INCREASED)
                    // Baby boom nests generate wealth continuously to afford the larger population
                    if (typeof sim !== 'undefined' && sim.frame % 10 === 0) { // Every 10 frames
                        // Base wealth generation increases with agent count (agents work to support the nest)
                        // PERFORMANCE: Use cached agent count
                        let agentCount = 0;
                        if (sim && sim.agents) {
                            let cached = sim._cachedTribeAgentCounts[this.tribeId];
                            if (!cached || (sim.frame - cached.lastUpdate > 30)) {
                                agentCount = sim.agents.filter(a => a.tribeId === this.tribeId && !a.dead).length;
                                sim._cachedTribeAgentCounts[this.tribeId] = { count: agentCount, lastUpdate: sim.frame };
                            } else {
                                agentCount = cached.count;
                            }
                        }
                        let baseGeneration = 4 + (agentCount * 0.5); // INCREASED: 4 base (was 2) + 0.5 per agent (was 0.3)
                        this.wealth += baseGeneration;
                        
                        // Spawn resources frequently during baby boom (victory spoils continue to flow in)
                        if (Math.random() < 0.35) { // INCREASED: 35% chance per check (was 25%)
                            let resourceTypes = ['FOOD', 'MAT', 'ORE', 'TREASURE'];
                            let resourceType = resourceTypes[Math.floor(Math.random() * resourceTypes.length)];
                            sim.spawnResource(null, 
                                this.pos.x + (Math.random() * 50 - 25),
                                this.pos.y + (Math.random() * 50 - 25),
                                resourceType, false, this.tribeId
                            );
                        }
                    }
                    
                    // MAINTAIN WEALTH AND PROSPERITY BONUS during baby boom (INCREASED TARGET)
                    // Replenish coffers to 80% of max health periodically (every 50 frames, increased from 70%)
                    if (this.babyBoom % 50 === 0) {
                        let prosperityWealthTarget = this.maxHealth * 0.8; // INCREASED: 80% of max health (was 70%)
                        if (this.wealth < prosperityWealthTarget) {
                            // Replenish to prosperity target
                            let replenishAmount = prosperityWealthTarget - this.wealth;
                            this.wealth += replenishAmount;
                            
                            // Occasional prosperity VFX
                            if (Math.random() < 0.3) {
                                sim.particles.push(new Particle(this.pos.x, this.pos.y, '#fbbf24', 'coin'));
                            }
                        }
                    }
                    
                    // MAINTAIN HP DURING BABY BOOM - Ensure winners don't die from accumulated war damage
                    // Restore HP if it drops below safe threshold during baby boom
                    if (typeof sim !== 'undefined' && sim.frame % 100 === 0) { // Every 100 frames
                        let safeHpThreshold = this.maxHealth * 0.6; // 60% of max health
                        if (this.hp < safeHpThreshold) {
                            // Restore HP to safe threshold (post-war reconstruction ensures structural integrity)
                            let hpRestore = safeHpThreshold - this.hp;
                            this.hp += hpRestore;
                            this.health = Math.min(this.maxHealth, this.hp);
                            
                            // VFX for HP restoration
                            if (Math.random() < 0.4) {
                                sim.particles.push(new Particle(this.pos.x, this.pos.y, '#3b82f6', 'spark'));
                            }
                        }
                    }
                }
                
                // SURVIVAL MECHANISM - Dying nests raise taxes and increase workforce
                // When a nest is in distress, it takes emergency measures to survive
                if (typeof sim !== 'undefined' && sim.frame % 30 === 0) { // Check every 30 frames
                    let isInDistress = this.hp < this.maxHealth * 0.5 || this.wealth < 200;
                    
                    if (isInDistress) {
                        let distressLevel = Math.max(
                            (1.0 - (this.hp / this.maxHealth * 2)), // HP distress (0-1)
                            (1.0 - (this.wealth / 200)) // Wealth distress (0-1)
                        );
                        distressLevel = Math.min(1.0, distressLevel); // Cap at 1.0
                        
                        // 1. RAISE TAXES - Extract more wealth from agents (emergency taxation)
                        // TRIBES TAX POPULATIONS ON ALL FORMS OF VALUE AND CONVERT TO WHAT TRIBE NEEDS
                        // PERFORMANCE: Use spatial grid to find tribe members near nest (within reasonable range)
                        let tribeMembers = [];
                        if (sim && sim.spatialGrid && sim.gridCols > 0) {
                            // Get agents within 2x nest radius (reasonable tax collection range)
                            let nearby = sim.getNearbyEntities(this.pos.x, this.pos.y, this.radius * 2);
                            tribeMembers = nearby.agents.filter(a => a.tribeId === this.tribeId && !a.dead);
                        } else if (sim && sim.agents) {
                            // Fallback: direct filter if spatial grid not available
                            tribeMembers = sim.agents.filter(a => a.tribeId === this.tribeId && !a.dead);
                        }
                        if (tribeMembers.length > 0) {
                            // Tax rate increases with distress level (10-30% of agent energy/wealth)
                            let taxRate = 0.1 + (distressLevel * 0.2); // 10-30% tax
                            
                            // Determine what tribe needs most (wealth, HP, or resources)
                            let needsWealth = this.wealth < this.maxHealth * 0.3; // Need wealth if below 30% of max health
                            let needsHp = this.hp < this.maxHealth * 0.5; // Need HP if below 50%
                            let needsResources = this.wealth < 100; // Need resources if very poor
                            
                            let totalTaxed = 0;
                            tribeMembers.forEach(agent => {
                                // TAX ENERGY - Convert to what tribe needs
                                if (agent.energy > 20) {
                                    let taxAmount = Math.min(agent.energy * taxRate, agent.energy * 0.3); // Max 30% of energy
                                    agent.energy -= taxAmount;
                                    
                                    if (needsHp && this.hp < this.maxHealth) {
                                        // Convert energy to HP (tribe needs health)
                                        let hpGain = taxAmount * 0.1; // 10% efficiency
                                        this.hp = Math.min(this.maxHealth, this.hp + hpGain);
                                        this.health = Math.min(this.maxHealth, this.hp);
                                    } else {
                                        // Convert energy to wealth (tribe needs money)
                                        let wealthGain = taxAmount * 0.5; // 50% efficiency
                                        this.wealth += wealthGain;
                                        totalTaxed += wealthGain;
                                    }
                                    
                                    // VFX for tax collection (occasional)
                                    if (Math.random() < 0.15) {
                                        sim.particles.push(new Particle(agent.pos.x, agent.pos.y, '#f59e0b', 'coin'));
                                    }
                                }
                                
                                // TAX WEALTH - Direct wealth transfer
                                if (agent.wealth > 10) {
                                    let wealthTax = Math.min(agent.wealth * taxRate, agent.wealth * 0.25); // Max 25% of wealth
                                    agent.wealth -= wealthTax;
                                    this.wealth += wealthTax;
                                    totalTaxed += wealthTax;
                                }
                                
                                // TAX RESOURCES - Extract from agents carrying resources and convert to what tribe needs
                                if (agent.carrying) {
                                    let resourceType = agent.carrying.type;
                                    let resourceValue = weightedResourceEnergy(resourceType) || 30;
                                    
                                    // Convert resource to what tribe needs
                                    if (needsHp && (resourceType === 'HERB' || resourceType === 'STIM')) {
                                        // Herbs/Stims can heal nest
                                        let hpGain = resourceValue * 0.2;
                                        this.hp = Math.min(this.maxHealth, this.hp + hpGain);
                                        this.health = Math.min(this.maxHealth, this.hp);
                                        // Remove resource after taxing
                                        agent.carrying.active = false;
                                        agent.carrying = null;
                                    } else {
                                        // Convert resource value to wealth
                                        let resourceTax = resourceValue * taxRate * 0.3; // 30% of resource value
                                        this.wealth += resourceTax;
                                        totalTaxed += resourceTax;
                                    }
                                }
                            });
                            
                            // SFX for emergency taxation (if significant amount collected)
                            if (totalTaxed > 5 && Math.random() < 0.3) {
                                // Vary transaction tone
                                let transactionNotes = [HARMONICS.E4, HARMONICS.A4, HARMONICS.C5, HARMONICS.D5, HARMONICS.E5];
                                sfx.play('transaction', getHarmonicFreq(transactionNotes, 8), 0.08);
                                // VFX at nest for tax collection
                                sim.particles.push(new Particle(this.pos.x, this.pos.y, '#f59e0b', 'coin'));
                            }
                        }
                        
                        // 2. INCREASE WORKFORCE - Spawn more resource-gathering agents
                        // Distressed nests spawn workers at 3-5x normal rate
                        let emergencySpawnRate = (CONFIG.nestAgentSpawnRate || 0.02) * (3 + distressLevel * 2); // 3-5x
                        if (Math.random() < emergencySpawnRate) {
                            let workerRoles = ['Gatherer', 'Miner', 'Farmer', 'Builder'];
                            let role = workerRoles[Math.floor(Math.random() * workerRoles.length)];
                            let newAgent = sim.spawnAgent(role, this);
                            if (newAgent) {
                                newAgent.role = role;
                                newAgent.determineRole();
                                // VFX for emergency worker spawn
                                sim.particles.push(new Particle(newAgent.pos.x, newAgent.pos.y, '#f59e0b', 'spark'));
                                // Green spatter effect at nest position when spawning
                                for (let i = 0; i < 8; i++) {
                                    let spatterAngle = (i / 8) * Math.PI * 2;
                                    let spatterDist = 5 + Math.random() * 10;
                                    sim.particles.push(new Particle(
                                        this.pos.x + Math.cos(spatterAngle) * spatterDist,
                                        this.pos.y + Math.sin(spatterAngle) * spatterDist,
                                        '#22c55e', 'spark'
                                    ));
                                }
                                sim.particles.push(new Particle(this.pos.x, this.pos.y, '#10b981', 'explosion')); // Green explosion
                                // SFX for emergency spawning
                                // Vary spawn tone - use wider range of notes
                                let spawnNotes3 = [HARMONICS.C4, HARMONICS.E4, HARMONICS.A4, HARMONICS.C5, HARMONICS.D5, HARMONICS.E5, HARMONICS.G5];
                                // TEMPORARILY DISABLED FOR TESTING
                                // sfx.play('spawn', getHarmonicFreq(spawnNotes3, 10), 0.1);
                            }
                        }
                        
                        // 3. INCREASE RESOURCE PRODUCTION - Spawn resources directly
                        // Distressed nests produce resources at 2-4x normal rate
                        if (Math.random() < (0.15 * (1 + distressLevel * 2))) { // 15-45% chance
                            let resourceTypes = ['FOOD', 'MAT', 'ORE'];
                            let resourceType = resourceTypes[Math.floor(Math.random() * resourceTypes.length)];
                            sim.spawnResource(null, 
                                this.pos.x + (Math.random() * 60 - 30),
                                this.pos.y + (Math.random() * 60 - 30),
                                resourceType, false, this.tribeId
                            );
                            // VFX for emergency resource production
                            if (Math.random() < 0.3) {
                                sim.particles.push(new Particle(this.pos.x, this.pos.y, '#ef4444', 'spark'));
                                // SFX for emergency resource production
                                // Vary collect tone
                                let collectNotes = [HARMONICS.C4, HARMONICS.E4, HARMONICS.A4, HARMONICS.C5, HARMONICS.D5, HARMONICS.E5];
                                sfx.play('collect', getHarmonicFreq(collectNotes, 8), 0.08);
                            }
                        }
                    }
                }
                
                // CHECK FOR NEST DEATH - If HP reaches minimum, nest dies and spoils are distributed
                if (this.hp <= 200 && typeof sim !== 'undefined') {
                    // Calculate total nest value: wealth + structural health (HP) + energy from agents + resources
                    let totalWealth = this.wealth;
                    let structuralHealth = this.maxHealth; // Structural health represented as treasure
                    let totalEnergy = 0;
                    let totalResources = [];
                    
                    // Collect energy and resources from all tribe members
                    // PERFORMANCE: Use spatial grid to find tribe members near nest
                    let tribeMembers = [];
                    if (sim && sim.spatialGrid && sim.gridCols > 0) {
                        let nearby = sim.getNearbyEntities(this.pos.x, this.pos.y, this.radius * 2);
                        tribeMembers = nearby.agents.filter(a => a.tribeId === this.tribeId && !a.dead);
                    } else if (sim && sim.agents) {
                        tribeMembers = sim.agents.filter(a => a.tribeId === this.tribeId && !a.dead);
                    }
                    tribeMembers.forEach(agent => {
                        // Collect energy (convert to wealth/resources)
                        if (agent.energy > 50) {
                            totalEnergy += agent.energy * 0.3; // 30% of agent energy
                        }
                        // Collect resources they're carrying
                        if (agent.carrying && agent.carrying.active) {
                            totalResources.push(agent.carrying.type);
                            agent.carrying.active = false;
                            agent.carrying = null;
                        }
                    });
                    
                    // Convert energy to wealth
                    totalWealth += totalEnergy * 0.5; // 50% efficiency
                    
                    // Nest's structural health becomes treasure (represents accumulated infrastructure)
                    let treasureFromStructure = Math.floor(structuralHealth / 10); // 1 treasure per 10 HP
                    
                    // Find all nests at war with this nest
                    let warringNests = [];
                    if (typeof sim.tribes !== 'undefined' && sim.tribes.tribes) {
                        let deadTribe = sim.tribes.tribes[this.tribeId];
                        if (deadTribe && deadTribe.atWarWith) {
                            for (let otherId in deadTribe.atWarWith) {
                                if (deadTribe.atWarWith[otherId] === true) {
                                    let enemyNests = sim.tribes.nests.filter(n => n.tribeId == otherId && n !== this && n.hp > 0);
                                    warringNests.push(...enemyNests);
                                }
                            }
                        }
                        
                        // Also check reverse - nests that are at war with this nest
                        for (let tid in sim.tribes.tribes) {
                            let otherTribe = sim.tribes.tribes[tid];
                            if (otherTribe && otherTribe.atWarWith && otherTribe.atWarWith[this.tribeId] === true) {
                                let enemyNests = sim.tribes.nests.filter(n => n.tribeId == tid && n !== this && n.hp > 0);
                                warringNests.push(...enemyNests);
                            }
                        }
                    }
                    
                    // DISTRIBUTE ALL VALUE TO WAR WINNERS OR SCATTER IF NO WINNERS
                    if (warringNests.length > 0) {
                        // CONVERT ALL LOSING TRIBE MEMBERS TO WINNERS - Divide citizens among winning nests
                        // PERFORMANCE: Use cached agent count if available, otherwise filter
                        let losingTribeMembers = [];
                        if (sim && sim.agents) {
                            // For war conversion, we need all members, so use direct filter (war is rare)
                            losingTribeMembers = sim.agents.filter(a => a.tribeId === this.tribeId && !a.dead);
                        }
                        
                        // DISTRIBUTE TO WAR WINNERS - Handle quantities of 1 and remainders randomly
                        // Wealth distribution
                        let wealthRemainder = totalWealth;
                        let wealthPerNest = totalWealth > 0 ? Math.floor(totalWealth / warringNests.length) : 0;
                        wealthRemainder = totalWealth - (wealthPerNest * warringNests.length);
                        
                        // If total wealth is less than number of nests, randomly assign to one nest
                        if (totalWealth > 0 && totalWealth < warringNests.length) {
                            let randomNestIndex = Math.floor(Math.random() * warringNests.length);
                            wealthPerNest = 0; // Reset base amount
                            wealthRemainder = totalWealth; // All goes to one random nest
                        }
                        
                        // Treasure distribution
                        let treasureRemainder = treasureFromStructure;
                        let treasurePerNest = Math.floor(treasureFromStructure / warringNests.length);
                        treasureRemainder = treasureFromStructure - (treasurePerNest * warringNests.length);
                        
                        // If treasure is less than number of nests, randomly assign to one nest
                        if (treasureFromStructure > 0 && treasureFromStructure < warringNests.length) {
                            let randomNestIndex = Math.floor(Math.random() * warringNests.length);
                            treasurePerNest = 0; // Reset base amount
                            treasureRemainder = treasureFromStructure; // All goes to one random nest
                        }
                        
                        // Resources distribution - shuffle and randomly assign remainders
                        let resourcesRemainder = totalResources.length;
                        let resourcesPerNest = Math.floor(totalResources.length / warringNests.length);
                        resourcesRemainder = totalResources.length - (resourcesPerNest * warringNests.length);
                        
                        // If resources count is less than number of nests, randomly assign to one nest
                        if (totalResources.length > 0 && totalResources.length < warringNests.length) {
                            let randomNestIndex = Math.floor(Math.random() * warringNests.length);
                            resourcesPerNest = 0; // Reset base amount
                            resourcesRemainder = totalResources.length; // All goes to one random nest
                        }
                        
                        // Shuffle resources for random distribution
                        let shuffledResources = [...totalResources];
                        for (let i = shuffledResources.length - 1; i > 0; i--) {
                            let j = Math.floor(Math.random() * (i + 1));
                            [shuffledResources[i], shuffledResources[j]] = [shuffledResources[j], shuffledResources[i]];
                        }
                        
                        // Members distribution
                        let membersRemainder = losingTribeMembers.length;
                        let membersPerNest = Math.floor(losingTribeMembers.length / warringNests.length);
                        membersRemainder = losingTribeMembers.length - (membersPerNest * warringNests.length);
                        
                        // If members count is less than number of nests, randomly assign to one nest
                        if (losingTribeMembers.length > 0 && losingTribeMembers.length < warringNests.length) {
                            let randomNestIndex = Math.floor(Math.random() * warringNests.length);
                            membersPerNest = 0; // Reset base amount
                            membersRemainder = losingTribeMembers.length; // All goes to one random nest
                        }
                        
                        // Shuffle members for random distribution
                        let shuffledMembers = [...losingTribeMembers];
                        for (let i = shuffledMembers.length - 1; i > 0; i--) {
                            let j = Math.floor(Math.random() * (i + 1));
                            [shuffledMembers[i], shuffledMembers[j]] = [shuffledMembers[j], shuffledMembers[i]];
                        }
                        
                        // Randomly assign remainders to nests
                        let remainderAssignments = {
                            wealth: [],
                            treasure: [],
                            resources: [],
                            members: []
                        };
                        
                        // Create array of nest indices and shuffle for random remainder assignment
                        let nestIndices = warringNests.map((_, i) => i);
                        for (let i = nestIndices.length - 1; i > 0; i--) {
                            let j = Math.floor(Math.random() * (i + 1));
                            [nestIndices[i], nestIndices[j]] = [nestIndices[j], nestIndices[i]];
                        }
                        
                        // Assign remainders randomly
                        for (let i = 0; i < wealthRemainder; i++) {
                            remainderAssignments.wealth.push(nestIndices[i % nestIndices.length]);
                        }
                        for (let i = 0; i < treasureRemainder; i++) {
                            remainderAssignments.treasure.push(nestIndices[i % nestIndices.length]);
                        }
                        for (let i = 0; i < resourcesRemainder; i++) {
                            remainderAssignments.resources.push(nestIndices[i % nestIndices.length]);
                        }
                        for (let i = 0; i < membersRemainder; i++) {
                            remainderAssignments.members.push(nestIndices[i % nestIndices.length]);
                        }
                        
                        let resourceIndex = 0;
                        let memberIndex = 0;
                        
                        warringNests.forEach((winnerNest, nestIndex) => {
                            // POST-WAR RECONSTRUCTION: Double the winner's wealth immediately
                            winnerNest.wealth = winnerNest.wealth * 2;
                            
                            // Add spoils from defeated nest (wealth, energy converted to wealth, structural treasure)
                            let thisNestWealth = wealthPerNest + remainderAssignments.wealth.filter(i => i === nestIndex).length;
                            if (thisNestWealth > 0) {
                                winnerNest.wealth += thisNestWealth;
                            }
                            
                            // Distribute structural treasure (represents infrastructure value)
                            let thisNestTreasure = treasurePerNest + remainderAssignments.treasure.filter(i => i === nestIndex).length;
                            for (let i = 0; i < thisNestTreasure; i++) {
                                let angle = Math.random() * Math.PI * 2;
                                let dist = 20 + Math.random() * 30;
                                sim.spawnResource(null,
                                    winnerNest.pos.x + Math.cos(angle) * dist,
                                    winnerNest.pos.y + Math.sin(angle) * dist,
                                    'TREASURE', false, winnerNest.tribeId
                                );
                            }
                            
                            // Distribute resources from defeated nest
                            let thisNestResources = resourcesPerNest + remainderAssignments.resources.filter(i => i === nestIndex).length;
                            for (let i = 0; i < thisNestResources; i++) {
                                if (shuffledResources[resourceIndex]) {
                                    let angle = Math.random() * Math.PI * 2;
                                    let dist = 20 + Math.random() * 30;
                                    sim.spawnResource(null,
                                        winnerNest.pos.x + Math.cos(angle) * dist,
                                        winnerNest.pos.y + Math.sin(angle) * dist,
                                        shuffledResources[resourceIndex], false, winnerNest.tribeId
                                    );
                                    resourceIndex++;
                                }
                            }
                            
                            // CONVERT LOSING TRIBE MEMBERS TO WINNER'S TRIBE
                            // Assign citizens to this winning nest (divide equally, with random remainder assignment)
                            let thisNestMembers = membersPerNest + remainderAssignments.members.filter(i => i === nestIndex).length;
                            let membersToConvert = shuffledMembers.slice(memberIndex, memberIndex + thisNestMembers);
                            
                            membersToConvert.forEach(member => {
                                let oldTribeId = member.tribeId;
                                member.tribeId = winnerNest.tribeId;
                                member.nest = winnerNest;
                                
                                // Update loyalty to new tribe
                                member.loyalty[winnerNest.tribeId] = 50; // Initial loyalty
                                member.loyalty[oldTribeId] = (member.loyalty[oldTribeId] || 0) * 0.5; // Reduce old loyalty
                                
                                // VFX for conversion
                                sim.particles.push(new Particle(member.pos.x, member.pos.y, '#10b981', 'spark'));
                            });
                            
                            memberIndex += thisNestMembers;
                            
                            // START BABY BOOM - 10x spawning for 750 frames (reduced from 1500 for graphics stability)
                            winnerNest.babyBoom = 750;
                            
                            // IMMEDIATE HP RESTORATION - War winners need full health to survive post-war
                            // Restore HP to 85% of max (gives buffer but not instant full recovery)
                            let hpRestoreTarget = winnerNest.maxHealth * 0.85; // 85% of max health
                            if (winnerNest.hp < hpRestoreTarget) {
                                winnerNest.hp = hpRestoreTarget;
                            }
                            // Also restore health property for consistency
                            winnerNest.health = Math.min(winnerNest.maxHealth, winnerNest.hp);
                            
                            // WEALTH AND PROSPERITY BONUS - Replenish coffers to 80% of full health during baby boom (INCREASED from 70%)
                            // This represents the prosperity and economic boost from victory
                            let prosperityWealthTarget = winnerNest.maxHealth * 0.8; // 80% of max health (increased from 70%)
                            if (winnerNest.wealth < prosperityWealthTarget) {
                                // Boost wealth to prosperity target if below it
                                winnerNest.wealth = Math.max(winnerNest.wealth, prosperityWealthTarget);
                            } else {
                                // If already above, add a prosperity bonus (15% of max health as extra prosperity, increased from 10%)
                                winnerNest.wealth += winnerNest.maxHealth * 0.15;
                            }
                            
                            // Massive celebration VFX
                            for (let i = 0; i < 10; i++) {
                                let angle = (i / 10) * Math.PI * 2;
                                let dist = 30 + Math.random() * 20;
                                sim.particles.push(new Particle(
                                    winnerNest.pos.x + Math.cos(angle) * dist,
                                    winnerNest.pos.y + Math.sin(angle) * dist,
                                    '#fbbf24', 'star'
                                ));
                            }
                            sim.particles.push(new Particle(winnerNest.pos.x, winnerNest.pos.y, '#10b981', 'explosion')); // Green for victory
                        });
                        
                        // DIPLOMATIC BOON - All diplomatic partners of winners get resources and economy boost
                        warringNests.forEach((winnerNest) => {
                            if (typeof sim !== 'undefined' && sim.tribes && sim.tribes.tribes[winnerNest.tribeId]) {
                                let winnerTribe = sim.tribes.tribes[winnerNest.tribeId];
                                
                                // Find all diplomatic partners of the winner
                                if (winnerTribe.diplomaticBonds) {
                                    for (let partnerId in winnerTribe.diplomaticBonds) {
                                        let bondStrength = winnerTribe.diplomaticBonds[partnerId];
                                        if (bondStrength > 10) { // Meaningful bond threshold
                                            // Find the partner nest
                                            let partnerNest = sim.tribes.nests.find(n => n.tribeId === parseInt(partnerId) && n.hp > 0);
                                            if (partnerNest) {
                                                // Diplomatic boon: Wealth and resources boost
                                                // Bond strength determines boon size (scaled by bond strength / 100)
                                                let boonMultiplier = bondStrength / 100; // 0.1 to 1.0
                                                let wealthBoon = winnerNest.maxHealth * 0.15 * boonMultiplier; // 15% of winner's max health, scaled by bond
                                                let hpBoon = partnerNest.maxHealth * 0.1 * boonMultiplier; // 10% HP boost, scaled by bond
                                                
                                                // Apply boon
                                                partnerNest.wealth += wealthBoon;
                                                partnerNest.hp = Math.min(partnerNest.maxHealth, partnerNest.hp + hpBoon);
                                                partnerNest.health = Math.min(partnerNest.maxHealth, partnerNest.hp);
                                                
                                                // Strengthen diplomatic bond (reward for alliance)
                                                winnerTribe.diplomaticBonds[partnerId] = Math.min(100, bondStrength + 5);
                                                if (sim.tribes.tribes[partnerId]) {
                                                    sim.tribes.tribes[partnerId].diplomaticBonds[winnerNest.tribeId] = Math.min(100, (sim.tribes.tribes[partnerId].diplomaticBonds[winnerNest.tribeId] || 0) + 5);
                                                }
                                                
                                                // Spawn resources near partner nest (victory spoils shared with allies)
                                                for (let i = 0; i < Math.floor(3 * boonMultiplier); i++) {
                                                    let angle = (i / 3) * Math.PI * 2;
                                                    let dist = 20 + Math.random() * 30;
                                                    let resourceTypes = ['FOOD', 'MAT', 'ORE', 'TREASURE'];
                                                    let resourceType = resourceTypes[Math.floor(Math.random() * resourceTypes.length)];
                                                    sim.spawnResource(null,
                                                        partnerNest.pos.x + Math.cos(angle) * dist,
                                                        partnerNest.pos.y + Math.sin(angle) * dist,
                                                        resourceType, false, partnerNest.tribeId
                                                    );
                                                }
                                                
                                                // VFX for diplomatic boon
                                                sim.particles.push(new Particle(partnerNest.pos.x, partnerNest.pos.y, '#3b82f6', 'star')); // Blue for diplomatic
                                                sim.particles.push(new Particle(partnerNest.pos.x, partnerNest.pos.y, '#fbbf24', 'coin')); // Gold for wealth
                                                
                                                console.log(`Diplomatic boon: Tribe ${partnerId} received ${wealthBoon.toFixed(1)} wealth and ${hpBoon.toFixed(1)} HP from ally ${winnerNest.tribeId}'s victory!`);
                                            }
                                        }
                                    }
                                }
                            }
                        });
                        
                        console.log(`Nest of tribe ${this.tribeId} destroyed! ${losingTribeMembers.length} citizens converted to ${warringNests.length} winning tribes. Post-war reconstruction: doubled wealth + spoils + 750-frame baby boom!`);
                    } else {
                        // NO WAR WINNERS - SCATTER ALL VALUE WIDELY AROUND NEST IN RANDOM FORMS
                        // Scatter wealth, energy, resources, and structural treasure as random resources
                        let totalValue = totalWealth + (totalEnergy * 0.5) + (structuralHealth / 2);
                        let scatterCount = Math.min(50, Math.floor(totalValue / 20)); // Scatter up to 50 resources
                        
                        let resourceTypes = ['FOOD', 'MAT', 'ORE', 'TREASURE', 'HERB', 'STIM', 'RELIC', 'UNIQUE'];
                        
                        for (let i = 0; i < scatterCount; i++) {
                            let angle = Math.random() * Math.PI * 2;
                            let dist = 50 + Math.random() * 150; // Wide scatter (50-200 pixels from nest)
                            let resourceType = resourceTypes[Math.floor(Math.random() * resourceTypes.length)];
                            
                            // Weighted random - more valuable resources are rarer
                            let rand = Math.random();
                            if (rand < 0.4) resourceType = 'FOOD'; // 40% food
                            else if (rand < 0.6) resourceType = 'MAT'; // 20% materials
                            else if (rand < 0.75) resourceType = 'ORE'; // 15% ore
                            else if (rand < 0.85) resourceType = 'HERB'; // 10% herbs
                            else if (rand < 0.92) resourceType = 'STIM'; // 7% stims
                            else if (rand < 0.97) resourceType = 'TREASURE'; // 5% treasure
                            else if (rand < 0.99) resourceType = 'RELIC'; // 2% relics
                            else resourceType = 'UNIQUE'; // 1% unique
                            
                            sim.spawnResource(null,
                                this.pos.x + Math.cos(angle) * dist,
                                this.pos.y + Math.sin(angle) * dist,
                                resourceType, false, -1 // Unaffiliated resources
                            );
                        }
                        
                        // Also scatter remaining resources from agents
                        totalResources.forEach(resourceType => {
                            let angle = Math.random() * Math.PI * 2;
                            let dist = 50 + Math.random() * 150;
                            sim.spawnResource(null,
                                this.pos.x + Math.cos(angle) * dist,
                                this.pos.y + Math.sin(angle) * dist,
                                resourceType, false, -1
                            );
                        });
                        
                        console.log(`Nest of tribe ${this.tribeId} destroyed! No war winners - ${scatterCount} resources scattered widely around nest location.`);
                    }
                    
                    // Mark nest for removal
                    this.hp = 0;
                    this.wealth = 0;
                    
                    // Trigger aggressive cleanup after nest death
                    if (typeof sim !== 'undefined' && sim._cleanupAfterLargeDieOff) {
                        sim._cleanupAfterLargeDieOff();
                    }
                    
                    // VFX
                    sim.particles.push(new Particle(this.pos.x, this.pos.y, '#dc2626', 'explosion'));
                    sim.particles.push(new Particle(this.pos.x, this.pos.y, '#9ca3af', 'smoke'));
                } 
                
                // Nest drift based on tribal relations, diplomatic and commercial bonds
                if (typeof sim !== 'undefined' && sim.tribes) {
                    let targetDrift = this.computeDriftForce();
                    let smoothing = Math.max(0.01, CONFIG.nestDriftSmoothing || 0.05);
                    let driftDelta = Vector.sub(targetDrift, this.driftMomentum).mult(smoothing);
                    this.driftMomentum.add(driftDelta);

                    let driftForce = this.driftMomentum.copy();

                    if (driftForce.mag() < 0.5) {
                        let randomDrift = new Vector(
                            (Math.random() - 0.5) * CONFIG.nestBaseDriftRate * 0.5,
                            (Math.random() - 0.5) * CONFIG.nestBaseDriftRate * 0.5
                        );
                        this.driftMomentum.add(randomDrift);
                        driftForce.add(randomDrift);
                    }

                    if (driftForce.mag() > 0.001) {
                        // Massively slow down nest motion (multiply by 0.005 = 99.5% reduction)
                        driftForce.mult(0.005);
                        // Apply drift and wrap position directly using Vector method
                        this.pos.add(driftForce);
                        this.pos.wrap(sim.width, sim.height);
                        
                        let newX = this.pos.x;
                        let newY = this.pos.y;
                        
                        // NEST COLLISION DETECTION AND BOUNCING
                        let minDist = this.radius + 20; // Minimum separation distance
                        let collisionForce = new Vector(0, 0);
                        let collisionCount = 0;
                        
                        for (let otherNest of sim.tribes.nests) {
                            if (otherNest === this) continue;
                            
                            // Use toroidal distance for collision detection
                            let dx = otherNest.pos.x - newX;
                            let dy = otherNest.pos.y - newY;
                            
                            // Wrap to shortest path
                            if (dx > sim.width / 2) dx -= sim.width;
                            else if (dx < -sim.width / 2) dx += sim.width;
                            if (dy > sim.height / 2) dy -= sim.height;
                            else if (dy < -sim.height / 2) dy += sim.height;
                            
                            let d = Math.sqrt(dx * dx + dy * dy);
                            let minSeparation = this.radius + otherNest.radius + minDist;
                            
                            if (d < minSeparation && d > 0.001) {
                                // Collision detected - apply bounce force
                                let overlap = minSeparation - d;
                                let bounceDir = new Vector(-dx, -dy);
                                bounceDir.normalize();
                                
                                // Bounce strength proportional to overlap and relative velocity
                                let bounceStrength = overlap * 0.15; // Bounce coefficient
                                collisionForce.add(bounceDir.mult(bounceStrength));
                                collisionCount++;
                                
                                // Also apply opposite force to other nest
                                let otherBounceDir = new Vector(dx, dy);
                                otherBounceDir.normalize();
                                otherNest.driftMomentum.add(otherBounceDir.mult(bounceStrength * 0.5));
                            }
                        }
                        
                        // Apply collision forces
                        if (collisionCount > 0) {
                            collisionForce.div(collisionCount);
                            this.driftMomentum.add(collisionForce);
                            // Dampen momentum after collision
                            this.driftMomentum.mult(0.85);
                            
                            // Recalculate position with bounce and wrap
                            this.pos.add(this.driftMomentum);
                            this.pos.wrap(sim.width, sim.height);
                            
                            newX = this.pos.x;
                            newY = this.pos.y;
                        }
                    }
                    }
                }
                this.updateTools(sim);
                this.attemptSpawnTool(sim);
            }
            computeDriftForce() {
                    let driftForce = new Vector(0, 0);
                if (typeof sim === 'undefined' || !sim.tribes) return driftForce;
                    let tribe = sim.tribes.tribes[this.tribeId];
                if (!tribe) return driftForce;
                let contributionCount = 0;
                    
                    let totalBonds = 0;
                    for (let otherId in tribe.diplomaticBonds) totalBonds += tribe.diplomaticBonds[otherId];
                    for (let otherId in tribe.commercialBonds) totalBonds += tribe.commercialBonds[otherId];
                    
                let isAffiliated = totalBonds > 10;
                    
                    if (!isAffiliated && CONFIG.nestUnaffiliatedDriftRate > 0) {
                    let nestGroups = {};
                        for (let nest of sim.tribes.nests) {
                            if (!nestGroups[nest.tribeId]) nestGroups[nest.tribeId] = [];
                            nestGroups[nest.tribeId].push(nest);
                        }
                        
                        let largestGroupId = null;
                        let largestSize = 0;
                        for (let tribeId in nestGroups) {
                            if (nestGroups[tribeId].length > largestSize && Number(tribeId) !== this.tribeId) {
                                largestGroupId = Number(tribeId);
                                largestSize = nestGroups[tribeId].length;
                            }
                        }
                        
                        if (largestGroupId !== null) {
                            let centerX = 0, centerY = 0;
                            for (let nest of nestGroups[largestGroupId]) {
                                centerX += nest.pos.x;
                                centerY += nest.pos.y;
                            }
                            centerX /= largestSize;
                            centerY /= largestSize;
                            
                            let toCenter = new Vector(centerX - this.pos.x, centerY - this.pos.y);
                            toCenter.normalize();
                            toCenter.mult(CONFIG.nestUnaffiliatedDriftRate);
                            driftForce.add(toCenter);
                        contributionCount++;
                        }
                    }
                    
                    for (let otherNest of sim.tribes.nests) {
                        if (otherNest === this || otherNest.tribeId === this.tribeId) continue;
                        
                    // Calculate direction FROM this nest TO other nest (for attraction)
                    let direction = Vector.subTorus(otherNest.pos, this.pos, sim.width, sim.height);
                        let distance = direction.mag();
                        
                    if (distance < 1) continue;
                        
                    // Normalize direction - points TOWARDS other nest
                        direction.normalize();
                        
                    let dipBond = (sim.tribes.tribes[this.tribeId] && sim.tribes.tribes[this.tribeId].diplomaticBonds && sim.tribes.tribes[this.tribeId].diplomaticBonds[otherNest.tribeId]) || 0;
                    let comBond = (sim.tribes.tribes[this.tribeId] && sim.tribes.tribes[this.tribeId].commercialBonds && sim.tribes.tribes[this.tribeId].commercialBonds[otherNest.tribeId]) || 0;
                    // Lower threshold to detect bonds earlier (was 20)
                    let hasBond = dipBond > 10 || comBond > 10;
                    let isEnemy = tribe.atWarWith && tribe.atWarWith[otherNest.tribeId];
                    let relation = sim.tribes.getOpinion(this.tribeId, otherNest.tribeId);

                    let strength = 0;
                    
                    // BONDED NESTS: Only attraction, never repulsion
                    if (hasBond) {
                        // PULL TOWARDS EACH OTHER - Bond attraction overrides enemy repulsion
                        let bondStrength = 0;
                        if (dipBond > 10) {
                            // Use bond value directly (0-100) scaled by multiplier - moderate attraction
                            bondStrength += (dipBond / 100) * CONFIG.nestDiplomaticDriftMultiplier * 2.0;
                        }
                        if (comBond > 10) {
                            // Use bond value directly (0-100) scaled by multiplier - moderate attraction
                            bondStrength += (comBond / 100) * CONFIG.nestCommercialDriftMultiplier * 2.0;
                        }
                        
                        // Base attraction strength - moderate to avoid fast motion
                        strength = bondStrength * CONFIG.nestBaseDriftRate * 1.5;
                        
                        // If also enemies, reduce attraction slightly but keep it positive (bonds win)
                        if (isEnemy) {
                            strength *= 0.7; // Reduce attraction by 30% if enemies, but still attract
                        }
                        
                        // Ensure minimum attraction even for weak bonds (but not too strong)
                        if (strength < CONFIG.nestBaseDriftRate * 1.0) {
                            strength = CONFIG.nestBaseDriftRate * 1.0;
                        }
                        
                        // Distance factor - stronger pull when closer (but still pull when far)
                        let distanceFactor = 1.0;
                            if (distance < 300) {
                            distanceFactor = 2.0; // Strong pull when close
                            } else if (distance < 600) {
                            distanceFactor = 1.5;
                            } else if (distance < 900) {
                            distanceFactor = 1.2;
                            } else {
                            distanceFactor = 1.0; // Still pull when far
                            }
                        strength *= distanceFactor;
                        
                        // Ensure strength is always positive (attraction only) when bonds exist
                        // NO REPULSION - bonded nests only attract, never repel
                        strength = Math.max(0, strength); // Force positive (attraction only)
                        
                        // Direction already points TOWARDS the other nest (from subTorus calculation)
                        // Positive strength with this direction = attraction (moving towards each other)
                    } else {
                        // UNBONDED NESTS: Gentle attraction and repulsion based on distance
                        // Close range: gentle repulsion (avoid crowding)
                        // Medium range: gentle attraction (form loose groups)
                        // Far range: very gentle attraction (tendency to cluster)
                        
                        let attractionStrength = 0;
                        let repulsionStrength = 0;
                        
                        // Gentle attraction - stronger at medium distances
                        if (distance > 200 && distance < 800) {
                            // Medium distance: gentle attraction
                            attractionStrength = CONFIG.nestBaseDriftRate * 0.4;
                        } else if (distance >= 800) {
                            // Far distance: very gentle attraction
                            attractionStrength = CONFIG.nestBaseDriftRate * 0.2;
                        }
                        
                        // Gentle repulsion - stronger when close
                        if (distance < 300) {
                            // Close distance: gentle repulsion to avoid crowding
                            repulsionStrength = CONFIG.nestBaseDriftRate * 0.6;
                        } else if (distance < 500) {
                            // Medium-close: very gentle repulsion
                            repulsionStrength = CONFIG.nestBaseDriftRate * 0.2;
                    }
                    
                        // Adjust based on relations
                        if (isEnemy) {
                            // Enemies: stronger repulsion, weaker attraction
                            repulsionStrength *= 1.5;
                            attractionStrength *= 0.5;
                        } else if (relation < 0) {
                            // Unfriendly: moderate repulsion, reduced attraction
                            repulsionStrength *= 1.2;
                            attractionStrength *= 0.7;
                        } else if (relation > 0) {
                            // Friendly: stronger attraction, weaker repulsion
                            attractionStrength *= 1.3;
                            repulsionStrength *= 0.8;
                        }
                        
                        // Combine attraction and repulsion
                        // Net force = attraction (towards) - repulsion (away)
                        let netStrength = attractionStrength - repulsionStrength;
                        
                        if (netStrength > 0) {
                            // Net attraction: move TOWARDS other nest
                            // Direction already points towards (from subTorus calculation)
                            strength = netStrength; // Positive = attraction
                            // direction stays as-is (points towards)
                        } else if (netStrength < 0) {
                            // Net repulsion: move AWAY from other nest
                            direction.mult(-1); // Reverse to point away
                            strength = Math.abs(netStrength); // Positive magnitude
                        } else {
                            // Balanced: no movement
                            strength = 0;
                        }
                    }

                    // Apply the force (direction already set correctly above)
                    if (strength > 0) {
                        direction.mult(strength);
                        driftForce.add(direction);
                        contributionCount++;
                    }
                }

                // Average all forces for smooth motion (necessary for smooth movement)
                // Bond forces are made stronger before averaging so they remain effective after averaging
                if (contributionCount > 0) {
                    driftForce.div(contributionCount); // Normal averaging for smooth motion
                }

                return driftForce;
            }
            updateTools(sim) {
                this.tools = this.tools.filter(tool => tool.update(sim));
            }
            attemptSpawnTool(sim) {
                if (typeof sim === 'undefined' || !CONFIG.nestToolConfig) return;
                let config = CONFIG.nestToolConfig;
                if (this.tools.length >= config.maxPerNest) return;
                let currentFrame = sim.frame || 0;
                if (currentFrame - this.lastToolSpawnFrame < config.spawnCooldown) return;
                let tribe = sim.tribes && sim.tribes.tribes[this.tribeId];
                let candidates = Object.entries(config.toolTypes).filter(([type, def]) => this.canSpawnTool(def, tribe));
                if (candidates.length === 0) return;
                if (Math.random() < 0.08) {
                    let [type, def] = candidates[Math.floor(Math.random() * candidates.length)];
                    this.wealth = Math.max(0, this.wealth - def.wealthCost);
                    let tool = new NestTool(type, this, def);
                    this.tools.push(tool);
                    this.lastToolSpawnFrame = currentFrame;
                    if (this.tools.length > config.maxPerNest) {
                        this.tools.shift();
                    }
                            }
                        }
            canSpawnTool(def, tribe) {
                if (this.hp < def.minHp) return false;
                if (this.wealth < def.wealthCost) return false;
                let tier = tribe ? tribe.techTier || 0 : 0;
                if (tier < (def.techTier || 0)) return false;
                return true;
            }
            draw(ctx) {
                let tColor = (sim.tribes.tribes[this.tribeId] && sim.tribes.tribes[this.tribeId].color) || '#888888';
                
                // Nest radius directly reflects nest health and stats (no random variations)
                // Base size from wealth
                let wealthSize = 20 + (this.wealth / 40);
                // HP-based size (healthier nests are larger)
                let hpRatio = this.hp / this.maxHealth; // 0.0 to 1.0
                let hpSize = 15 + (hpRatio * 25); // Range from 15 to 40 pixels based on HP
                // Defense level adds to size
                let defenseSize = this.defenseLevel * 2;
                
                // Combined size based on health, wealth, and defense (direct reflection, no randomness)
                let size = Math.max(wealthSize, hpSize) + defenseSize;
                this.radius = Math.min(Math.max(15, size), 80); // Clamp between 15 and 80
                
                // Additional wealth rings (concentric circles showing prosperity)
                let wealthRings = Math.min(5, Math.floor(this.wealth / 150));
                for(let i = 0; i < wealthRings; i++) {
                    ctx.strokeStyle = `rgba(251, 191, 36, ${0.3 - i * 0.05})`; // Gold, fading outward
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(this.pos.x, this.pos.y, this.radius + 15 + (i * 12), 0, Math.PI*2);
                    ctx.stroke();
                }

                // Draw Wealth Hoard (more piles, bigger radius)
                let piles = Math.min(15, Math.floor(this.wealth / 40)); // More piles, easier to earn
                for(let i=0; i<piles; i++) {
                    let angle = (i / piles) * Math.PI * 2;
                    let rx = this.pos.x + Math.cos(angle) * (this.radius + 12);
                    let ry = this.pos.y + Math.sin(angle) * (this.radius + 12);
                    ctx.fillStyle = '#fbbf24';
                    ctx.beginPath();
                    ctx.arc(rx, ry, 4, 0, Math.PI*2); // Bigger piles (3->4)
                    ctx.fill();
                    ctx.strokeStyle = '#f59e0b';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }

                // Draw Defense Rings (Thick Gold Rings) - MORE VISIBLE
                for(let i=0; i<this.defenseLevel; i++) {
                    ctx.strokeStyle = '#a16207'; 
                    ctx.lineWidth = 8; // Increased from 6 to 8
                    ctx.beginPath();
                    ctx.arc(this.pos.x, this.pos.y, this.radius + 15 + (i*10), 0, Math.PI*2); // More spacing
                    ctx.stroke();
                }

                ctx.fillStyle = tColor;
                ctx.globalAlpha = 0.3;
                ctx.beginPath();
                ctx.arc(this.pos.x, this.pos.y, this.radius + 5, 0, Math.PI*2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
                
                ctx.fillStyle = '#1f2937';
                ctx.strokeStyle = tColor;
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.arc(this.pos.x, this.pos.y, this.radius, 0, Math.PI*2);
                ctx.fill();
                ctx.stroke();

                ctx.fillStyle = '#fff';
                ctx.font = "10px monospace";
                ctx.textAlign = "center";
                ctx.fillText(`HP: ${Math.floor(this.hp)}`, this.pos.x, this.pos.y + this.radius + 15);
                ctx.fillText(`DEF: ${this.defenseLevel}`, this.pos.x, this.pos.y + this.radius + 25);
                this.tools.forEach(tool => tool.draw(ctx));
            }
        }

        class NestTool {
            constructor(type, nest, def) {
                this.type = type;
                this.nest = nest;
                this.definition = def;
                this.angle = Math.random() * Math.PI * 2;
                this.orbitRadius = nest.radius + 25 + Math.random() * 30;
                this.angularSpeed = 0.01 + Math.random() * 0.02;
                this.health = CONFIG.nestToolConfig && CONFIG.nestToolConfig.toolLifetime ? CONFIG.nestToolConfig.toolLifetime : 1200;
                this.effectTimer = 0;
                this.active = true;
                this.isNestTool = true;
            }
            getPosition() {
                let tether = new Vector(Math.cos(this.angle) * this.orbitRadius, Math.sin(this.angle) * this.orbitRadius);
                return new Vector(this.nest.pos.x + tether.x, this.nest.pos.y + tether.y);
            }
            getResourceNeedDirection(sim) {
                if (!sim) return Vector.random2D();
                let nest = this.nest;
                let tribe = sim.tribes && sim.tribes.tribes[nest.tribeId];
                let needs = (tribe && tribe.resourceNeeds) ? tribe.resourceNeeds : {};
                const priority = { FOOD: 3.5, SEED: 2.7, HERB: 2.6, MAT: 2.4, ORE: 2.2, TREASURE: 1.8, UNIQUE: 1.6, STIM: 1.2 };
                let best = null;
                let bestScore = -Infinity;
                for (let r of sim.resources) {
                    if (!r.active) continue;
                    let dist = Vector.dist(nest.pos, r.pos);
                    if (dist < 1) dist = 1;
                    let weight = priority[r.type] || 1.0;
                    let needBonus = needs[r.type] || 0;
                    let score = weight + needBonus - dist * 0.003;
                    if (score > bestScore) {
                        bestScore = score;
                        best = r;
                    }
                }
                if (!best) return Vector.random2D();
                return Vector.sub(best.pos, nest.pos).normalize();
            }
            update(sim) {
                this.angle += this.angularSpeed;
                this.effectTimer++;
                this.health -= 1;
                if (this.health <= 0) return false;
                switch (this.type) {
                    case 'propulsion':
                        this.applyPropulsion(sim);
                        break;
                    case 'foodGrabber':
                        this.applyFoodGrabber(sim);
                        break;
                    case 'resourceGrabber':
                        this.applyResourceGrabber(sim);
                        break;
                    case 'venom':
                        this.applyVenom(sim);
                        break;
                    case 'nestGrabber':
                        this.applyNestGrabber(sim);
                        break;
                    case 'nestRepeller':
                        this.applyNestRepeller(sim);
                        break;
                    case 'spawner':
                        this.applySpawner(sim);
                        break;
                    default:
                        break;
                }
                return true;
            }
            applyPropulsion(sim) {
                if (!sim || sim.frame % 35 !== 0) return;
                let dir = this.getResourceNeedDirection(sim);
                if (dir.mag() === 0) dir = Vector.random2D();
                let strength = 0.35 + (this.definition.pullStrength || 0) * 0.1;
                let push = dir.copy().mult(strength);
                this.nest.driftMomentum.add(push);
            }
            applyFoodGrabber(sim) {
                if (!sim || sim.frame % 30 !== 0) return;
                let range = CONFIG.nestToolConfig.resourceHarvestRange || 140;
                let candidate = sim.resources.find(r => {
                    if (!r.active || r.carrier) return false;
                    if (r.creatorTribe === this.nest.tribeId) return true;
                    return ['FOOD', 'HERB', 'SEED'].includes(r.type);
                });
                if (candidate && Vector.dist(candidate.pos, this.getPosition()) < range) {
                    candidate.active = false;
                    this.nest.wealth += candidate.type === 'HERB' ? 6 : 4;
                    sim.particles.push(new Particle(candidate.pos.x, candidate.pos.y, '#84cc16', 'spark'));
                }
            }
            applyResourceGrabber(sim) {
                if (!sim || sim.frame % 45 !== 0) return;
                let range = CONFIG.nestToolConfig.resourceHarvestRange || 150;
                let candidate = sim.resources.find(r => {
                    if (!r.active || r.carrier) return false;
                    return ['MAT', 'ORE', 'TREASURE'].includes(r.type);
                });
                if (candidate && Vector.dist(candidate.pos, this.getPosition()) < range) {
                    candidate.active = false;
                    this.nest.wealth += candidate.type === 'TREASURE' ? 10 : 5;
                    sim.particles.push(new Particle(candidate.pos.x, candidate.pos.y, '#f97316', 'spark'));
                }
            }
            applyVenom(sim) {
                if (!sim || sim.frame % 20 !== 0) return;
                let range = CONFIG.nestToolConfig.tetherRange || 200;
                for (let agent of sim.agents) {
                    if (!agent || agent.dead || agent.tribeId === this.nest.tribeId) continue;
                    if (Vector.dist(agent.pos, this.nest.pos) > range) continue;
                    // Agents inside nests are 1.5x harder to kill
                    let damage = agent.isInsideNest() ? (this.definition.damageOutput || 3) / 1.5 : (this.definition.damageOutput || 3);
                    agent.health -= damage;
                    agent.health = Math.max(0, agent.health);
                    if (agent.health <= 0) {
                        agent.dead = true;
                        // Only create blood particle if particle count is reasonable
                        if (sim.particles.length < 200) {
                            // Only create blood particle if particle count is reasonable
                            if (sim.particles.length < 200) {
                                sim.particles.push(new Particle(agent.pos.x, agent.pos.y, '#dc2626', 'blood'));
                            }
                        }
                    }
                }
            }
            applyNestGrabber(sim) {
                if (!sim || sim.frame % 25 !== 0) return;
                let range = CONFIG.nestToolConfig ? CONFIG.nestToolConfig.tetherRange : 220;
                // PERFORMANCE: Nests array is usually small, but we can still optimize by checking tribeId first
                let defenders = sim.tribes.nests.filter(n => 
                    n !== this.nest && 
                    n.tribeId !== this.nest.tribeId && 
                    Vector.dist(n.pos, this.nest.pos) < range
                );
                if (defenders.length === 0) return;
                let target = defenders.sort((a, b) => Vector.dist(a.pos, this.nest.pos) - Vector.dist(b.pos, this.nest.pos))[0];
                let pullDir = Vector.sub(this.nest.pos, target.pos).normalize().mult((this.definition.pullStrength || 0.6) + 0.2);
                let resourceDir = this.getResourceNeedDirection(sim).mult(0.25);
                target.driftMomentum.add(pullDir.add(resourceDir));
            }
            applyNestRepeller(sim) {
                if (!sim || sim.frame % 25 !== 0) return;
                let range = CONFIG.nestToolConfig ? CONFIG.nestToolConfig.tetherRange : 220;
                // PERFORMANCE: Check tribeId first before distance calculation
                let threats = sim.tribes.nests.filter(n => 
                    n !== this.nest && 
                    n.tribeId !== this.nest.tribeId && 
                    Vector.dist(n.pos, this.nest.pos) < range
                );
                if (threats.length === 0) return;
                for (let target of threats) {
                    let pushDir = Vector.sub(target.pos, this.nest.pos).normalize().mult(this.definition.pushStrength || 0.8);
                    target.driftMomentum.add(pushDir);
                }
            }
            applySpawner(sim) {
                if (!sim || sim.frame % (this.definition.cooldown || 40) !== 0) return;
                let spawnType = this.definition.spawnOptions[Math.floor(Math.random() * this.definition.spawnOptions.length)];
                let agent = sim.spawnAgent(spawnType, this.nest);
                if (agent) {
                    sim.particles.push(new Particle(agent.pos.x, agent.pos.y, '#f87171', 'spark'));
                }
            }
            draw(ctx) {
                let pos = this.getPosition();
                ctx.save();
                ctx.translate(pos.x, pos.y);
                let color = '#38bdf8';
                switch (this.type) {
                    case 'propulsion':
                        color = '#22d3ee';
                        break;
                    case 'foodGrabber':
                        color = '#bef264';
                        break;
                    case 'resourceGrabber':
                        color = '#facc15';
                        break;
                    case 'venom':
                        color = '#ef4444';
                        break;
                }
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(0, 0, 6, 0, Math.PI * 2);
                ctx.stroke();
                ctx.fillStyle = color;
                ctx.globalAlpha = 0.5;
                ctx.fill();
                ctx.globalAlpha = 1.0;
                ctx.restore();
            }
        }

        /* --- GLOBAL TRIBE MANAGER --- */
        class TribeManager {
            constructor() {
                this.tribes = {};
                this.nextId = 0;
                this.nests = [];
                this.createDefaultTribes(CONFIG.tribeCount);
            }

            // Find a valid position for a nest that's not too close to other nests
            findValidNestPosition(preferredX, preferredY, minDistance = 200) {
                let maxAttempts = 50;
                let bestX = preferredX;
                let bestY = preferredY;
                let bestMinDist = 0;
                
                for (let attempt = 0; attempt < maxAttempts; attempt++) {
                    let x = preferredX + (Math.random() - 0.5) * 200;
                    let y = preferredY + (Math.random() - 0.5) * 200;
                    
                    // Keep within bounds
                    x = Math.max(100, Math.min(window.innerWidth - 100, x));
                    y = Math.max(100, Math.min(window.innerHeight - 100, y));
                    
                    // Check distance to all existing nests
                    let minDistToNest = Infinity;
                    for (let nest of this.nests) {
                        let d = Math.sqrt((x - nest.pos.x)**2 + (y - nest.pos.y)**2);
                        if (d < minDistToNest) minDistToNest = d;
                    }
                    
                    // If far enough, use this position
                    if (minDistToNest >= minDistance) {
                        return { x, y };
                    }
                    
                    // Track best attempt
                    if (minDistToNest > bestMinDist) {
                        bestMinDist = minDistToNest;
                        bestX = x;
                        bestY = y;
                    }
                }
                
                // Return best attempt even if not ideal
                return { x: bestX, y: bestY };
            }

            createDefaultTribes(count) {
                const colors = ['#ef4444', '#3b82f6', '#10b981', '#eab308', '#d946ef'];
                const bases = ['Red', 'Blue', 'Green', 'Gold', 'Void'];
                const suffixes = ['Claw', 'Fin', 'Leaf', 'Spear', 'Walkers'];
                
                for(let i=0; i<count; i++) {
                    let tid = this.createTribe(bases[i%bases.length] + ' ' + suffixes[i%suffixes.length], colors[i%colors.length]);
                    let preferredX = 100 + Math.random() * (window.innerWidth - 200);
                    let preferredY = 100 + Math.random() * (window.innerHeight - 200);
                    let pos = this.findValidNestPosition(preferredX, preferredY);
                    let newNest = new Nest(pos.x, pos.y, tid);
                    this.nests.push(newNest);
                    
                    // NEST BIRTH SOUND - Play birth-like tone when nest is created (SOFTER)
                    if (typeof sfx !== 'undefined' && sfx.enabled) {
                        // Vary birth tone - wider range
                        // TEMPORARILY DISABLED FOR TESTING
                        // sfx.play('birth', getHarmonicFreq([HARMONICS.C4, HARMONICS.E4, HARMONICS.A4, HARMONICS.C5, HARMONICS.E5, HARMONICS.G5, HARMONICS.A5], 12), 0.1);
                        
                        // Start nest heartbeat - each nest has unique frequency based on its ID
                        // DISABLED - not working
                        // const baseFreq = 18 + ((tid % 10) * 1.0); // 18-28 Hz range (very low)
                        // const baseInterval = 35.0 + (Math.random() * 20.0); // 35-55 seconds (extremely slow)
                        // sfx.startNestHeartbeat(newNest.id || `nest_${tid}_${this.nests.length}`, baseFreq, baseInterval);
                    }
                }
            }

            createTribe(name, color) {
                let id = this.nextId++;
                this.tribes[id] = {
                    id: id,
                    name: name || `Clan ${id}`,
                    color: color || `hsl(${Math.random()*360}, 70%, 50%)`,
                    relations: {},
                    diplomaticBonds: {}, // Strength of diplomatic bonds with other tribes (0-100)
                    commercialBonds: {}, // Strength of commercial bonds with other tribes (0-100)
                    wealth: 0,
                    leaderId: null,
                    leaderUnderAttack: false,
                    leaderUnderAttackTargetId: null,
                    leaderUnderAttackTimer: 0,
                    underAttack: false,
                    roles: {},
                    techTier: 0,
                    // TECH TREE SYSTEM
                    techPoints: 0, // Accumulated tech points for advancement
                    techTree: {
                        // Tier 0: Basic survival (always available)
                        survival: { level: 1, maxLevel: 5 }, // Gathering, basic resource use
                        // Tier 1: Early civilization
                        agriculture: { level: 0, maxLevel: 5 }, // Farming, food cultivation
                        construction: { level: 0, maxLevel: 5 }, // Building, nest improvements
                        combat: { level: 0, maxLevel: 5 }, // Basic warfare
                        energy_production: { level: 0, maxLevel: 5 }, // Energy efficiency, reduces energy burn
                        // Tier 2: Advanced civilization
                        manufacturing: { level: 0, maxLevel: 5 }, // Resource transformation
                        medicine: { level: 0, maxLevel: 5 }, // Healing, infant mortality
                        commerce: { level: 0, maxLevel: 5 }, // Trade networks
                        defense: { level: 0, maxLevel: 5 }, // Shields, damage reduction, attack boost
                        resource_manufacturing: { level: 0, maxLevel: 5 }, // Spawn raw materials near nest
                        // Tier 3: High civilization
                        diplomacy: { level: 0, maxLevel: 5 }, // International relations
                        science: { level: 0, maxLevel: 5 }, // Research, innovation
                        education: { level: 0, maxLevel: 5 }, // Knowledge transfer
                        // Tier 4: Advanced
                        warfare: { level: 0, maxLevel: 5 }, // Advanced combat
                        cultivation: { level: 0, maxLevel: 5 } // Prey farming, resource cultivation
                    },
                    // TRIBAL SELF-REGULATION
                    roleNeeds: {}, // Tracks what roles tribe needs more/less of
                    resourceNeeds: {}, // Tracks what resources tribe needs more/less of
                    techDecay: 0.001, // Tech slowly decays if not maintained
                    // WAR SYSTEM
                    atWarWith: {}, // Set of tribe IDs at war with this tribe
                    warExhaustion: {}, // How tired each war makes the tribe (0-100)
                    surrenderThreshold: 80, // War exhaustion level to consider surrender
                    // PROFIT-BASED BOND TRACKING
                    tradeProfit: {}, // Profit from trade with each tribe (rolling window)
                    tradeProfitHistory: {}, // Array of recent profits per tribe
                    diplomaticBenefits: {}, // Benefits from diplomatic bonds (resources shared, defense, etc.)
                    lastTradeTime: {}, // Last time trade happened with each tribe
                    lastDiplomacyTime: {}, // Last time diplomacy happened with each tribe
                    // PERFORMANCE: Cached tribe composition flags (updated every 60 frames)
                    _compositionCache: {
                        hasArtisans: false,
                        hasScientists: false,
                        hasTechnologists: false,
                        hasTeachers: false,
                        lastUpdateFrame: -1
                    }
                };
                for(let otherId in this.tribes) {
                    this.tribes[id].relations[otherId] = 0;
                    this.tribes[otherId].relations[id] = 0;
                    this.tribes[id].diplomaticBonds[otherId] = 0;
                    this.tribes[otherId].diplomaticBonds[id] = 0;
                    this.tribes[id].commercialBonds[otherId] = 0;
                    this.tribes[otherId].commercialBonds[id] = 0;
                    this.tribes[id].atWarWith[otherId] = false;
                    this.tribes[otherId].atWarWith[id] = false;
                    this.tribes[id].warExhaustion[otherId] = 0;
                    this.tribes[otherId].warExhaustion[id] = 0;
                    // Initialize profit tracking
                    this.tribes[id].tradeProfit[otherId] = 0;
                    this.tribes[otherId].tradeProfit[id] = 0;
                    this.tribes[id].tradeProfitHistory[otherId] = [];
                    this.tribes[otherId].tradeProfitHistory[id] = [];
                    this.tribes[id].diplomaticBenefits[otherId] = 0;
                    this.tribes[otherId].diplomaticBenefits[id] = 0;
                    this.tribes[id].lastTradeTime[otherId] = 0;
                    this.tribes[otherId].lastTradeTime[id] = 0;
                    this.tribes[id].lastDiplomacyTime[otherId] = 0;
                    this.tribes[otherId].lastDiplomacyTime[id] = 0;
                }
                this.tribes[id].relations[id] = 100;
                return id;
            }

            fractureTribe(oldId, agentsInTribe) {
                this.nests = this.nests.filter(n => n.tribeId !== oldId);
                if (agentsInTribe.length < 2) return; 
                let newId = this.createTribe(`Refugees ${oldId}`, null); 
                let center = agentsInTribe[0].pos;
                let pos = this.findValidNestPosition(center.x, center.y);
                let newNest2 = new Nest(pos.x, pos.y, newId);
                this.nests.push(newNest2);
                
                // Start nest heartbeat for new nest
                // DISABLED - not working
                // if (typeof sfx !== 'undefined' && sfx.enabled) {
                //     const baseFreq = 30 + ((newId % 20) * 1.0); // 30-50 Hz range
                //     const baseInterval = 6.0 + (Math.random() * 2.0); // 6-8 seconds
                //     sfx.startNestHeartbeat(newNest2.id || `nest_${newId}_${this.nests.length}`, baseFreq, baseInterval);
                // }
                
                // NEST BIRTH SOUND - Play birth-like tone when nest is created (tribe split) (SOFTER)
                if (typeof sfx !== 'undefined' && sfx.enabled) {
                    // TEMPORARILY DISABLED FOR TESTING
                    // sfx.play('birth', getHarmonicFreq([HARMONICS.C5, HARMONICS.E5, HARMONICS.G5, HARMONICS.A5], 10), 0.1); // Harmonic birth tone
                }
                agentsInTribe.forEach(a => a.tribeId = newId);
            }

            updateRoles(agents) {
                for(let tid in this.tribes) {
                    this.tribes[tid].roles = {};
                }
                agents.forEach(a => {
                    if(a.tribeId !== -1) {
                        if(!this.tribes[a.tribeId].roles[a.role]) this.tribes[a.tribeId].roles[a.role] = 0;
                        this.tribes[a.tribeId].roles[a.role]++;
                    }
                });

                // Clean up dead tribes (0 agents)
                for(let tid in this.tribes) {
                    let count = agents.filter(a => a.tribeId == tid).length;
                    if (count === 0) {
                        this.nests = this.nests.filter(n => n.tribeId != tid);
                    }
                }

                // Calculate Tech Levels
                for(let tid in this.tribes) {
                    let t = this.tribes[tid];
                    t.techTier = 0;
                    if ((t.roles['Builder']||0) > 4 && (t.roles['Guardian']||0) > 4) t.techTier = 1;
                    if (t.techTier >= 1 && (t.roles['Soldier']||0) > 4 && (t.roles['Artisan']||0) > 2) t.techTier = 2;
                    if (t.techTier >= 2 && t.wealth > 5000 && (t.roles['Healer']||0) > 1) t.techTier = 3;
                }
            }

            getDesiredRole(tribeId) {
                let t = this.tribes[tribeId];
                if (!t) return null;
                
                // BASE ROLES (always available - EXPANDED!)
                let allowedRoles = ['Builder', 'Botanist', 'Miner', 'Guardian', 'Garbage Collector'];
                
                // TECH-GATED ROLES based on tech tree levels (LOWERED REQUIREMENTS!)
                if (t.techTree.agriculture.level >= 1) allowedRoles.push('Farmer');
                if (t.techTree.combat.level >= 1) allowedRoles.push('Soldier');
                if (t.techTree.manufacturing.level >= 1) allowedRoles.push('Artisan');
                if (t.techTree.commerce.level >= 1) allowedRoles.push('Merchant');
                if (t.techTree.medicine.level >= 1) allowedRoles.push('Healer');
                if (t.techTree.warfare.level >= 1) allowedRoles.push('Raider');
                if (t.techTree.science.level >= 1) allowedRoles.push('Scientist');
                if (t.techTree.diplomacy.level >= 1) allowedRoles.push('Diplomat');
                if (t.techTree.education.level >= 1) allowedRoles.push('Teacher');
                
                // SCOUT is always available too
                allowedRoles.push('Scout');
                
                // Prioritize roles with lower counts (fill gaps)
                let counts = allowedRoles.map(r => ({ r: r, c: t.roles[r] || 0 }));
                counts.sort((a, b) => a.c - b.c);
                let pick = counts[Math.floor(Math.random() * Math.min(3, counts.length))];
                return pick ? pick.r : null;
            }

            getOpinion(fromTribe, toTribe) {
                if (!this.tribes[fromTribe] || !this.tribes[toTribe]) return 0;
                return this.tribes[fromTribe].relations[toTribe];
            }
            
            // Tech tree progression - accumulate points and level up techs
            progressTech(tribeId, activity, points = 1) {
                let tribe = this.tribes[tribeId];
                if (!tribe) return;
                
                // Apply researchSpeed multiplier to tech point generation
                let effectivePoints = points * (CONFIG.researchSpeed || 1.0);
                // Boost tech point generation significantly - tribes need to progress faster
                effectivePoints *= 2.5; // 2.5x multiplier to help tribes advance tech faster
                tribe.techPoints += effectivePoints;
                
                // Level up specific tech based on activity
                if (tribe.techTree[activity]) {
                    let tech = tribe.techTree[activity];
                    if (tech.level < tech.maxLevel) {
                        // Reduced upgrade cost - tech advances faster
                        let costToUpgrade = (tech.level + 1) * 60; // Reduced from 100 to 60
                        if (tribe.techPoints >= costToUpgrade) {
                            tribe.techPoints -= costToUpgrade;
                            tech.level++;
                        }
                    }
                }
            }
            
            // Get tech bonuses for a tribe
            getTechBonus(tribeId, techType) {
                let tribe = this.tribes[tribeId];
                if (!tribe || !tribe.techTree[techType]) return 1.0;
                
                // Each level provides 10% bonus (multiplicative)
                return 1.0 + (tribe.techTree[techType].level * 0.1);
            }
            
            // Get energy efficiency multiplier (LOWER is better - reduces energy burn)
            getEnergyEfficiency(tribeId) {
                let tribe = this.tribes[tribeId];
                if (!tribe) return 1.0;
                
                // Each level reduces energy burn by 10%
                let level = tribe.techTree.energy_production.level;
                return Math.max(0.5, 1.0 - (level * 0.1)); // Max 50% reduction at level 5
            }
            
            // Get defense bonus (damage reduction)
            getDefenseBonus(tribeId) {
                let tribe = this.tribes[tribeId];
                if (!tribe) return 0;
                
                // Each level provides 5% damage reduction (max 25% at level 5)
                return tribe.techTree.defense.level * 0.05;
            }
            
            // Get attack damage multiplier
            getAttackBonus(tribeId) {
                let tribe = this.tribes[tribeId];
                if (!tribe) return 1.0;
                
                // Each level increases damage by 15%
                return 1.0 + (tribe.techTree.defense.level * 0.15);
            }
            
            // Tech decay ONLY happens in crisis conditions (not random!)
            decayTech(tribeId) {
                let tribe = this.tribes[tribeId];
                if (!tribe) return;
                
                // Get tribe members to assess health
                let nest = this.nests.find(n => n.tribeId == tribeId);
                if (!nest) return;
                
                // CRISIS CONDITIONS for tech decay:
                // 1. Very low wealth (< 100) = tribe can't support specialists
                // 2. Very low nest health (< 200) = infrastructure failing
                // 3. Very few members (< 3) = knowledge loss
                
                // PERFORMANCE: Use cached agent count for quick check, but still need to filter for actual check
                let memberCount = 0;
                if (typeof sim !== 'undefined' && sim.agents) {
                    let cached = sim._cachedTribeAgentCounts[tribeId];
                    if (cached && (sim.frame - cached.lastUpdate < 30)) {
                        memberCount = cached.count;
                    } else {
                        // Update cache
                        let members = sim.agents.filter(a => a.tribeId == tribeId && !a.dead);
                        memberCount = members.length;
                        sim._cachedTribeAgentCounts[tribeId] = { count: memberCount, lastUpdate: sim.frame };
                    }
                }
                let isInCrisis = (nest.wealth < 100) || (nest.hp < 200) || (memberCount < 3);
                
                if (!isInCrisis) return; // NO DECAY if tribe is healthy!
                
                // Only decay in crisis, and only slowly
                for (let techType in tribe.techTree) {
                    let tech = tribe.techTree[techType];
                    if (tech.level > 0 && Math.random() < 0.01) { // 1% chance (was 0.1%)
                        tech.level = Math.max(0, tech.level - 0.05); // Lose 0.05 level (was 0.1)
                    }
                }
            }
            
            // WAR SYSTEM
            declareWar(tribe1Id, tribe2Id) {
                let t1 = this.tribes[tribe1Id];
                let t2 = this.tribes[tribe2Id];
                if (!t1 || !t2) return;
                
                t1.atWarWith[tribe2Id] = true;
                t2.atWarWith[tribe1Id] = true;
                
                // WAR BOND CREATED - Dark ominous sound
                if (typeof sfx !== 'undefined' && sfx.enabled) {
                    // TEMPORARILY DISABLED FOR TESTING
                    // sfx.play('death', HARMONICS.E4, 0.2); // Low, ominous war declaration sound
                }
                
                // Update HUD status message
                if (typeof sim !== 'undefined') {
                    sim.setStatusMessage(`‚öîÔ∏è WAR DECLARED: Tribe ${tribe1Id} vs Tribe ${tribe2Id}`, 300); // Show for 300 frames (~5 seconds)
                }
                
                
                // Break diplomatic and commercial bonds between the two warring parties
                t1.diplomaticBonds[tribe2Id] = 0;
                t2.diplomaticBonds[tribe1Id] = 0;
                t1.commercialBonds[tribe2Id] = 0;
                t2.commercialBonds[tribe1Id] = 0;
                
                // WAR BOND BREAKING: Break bonds with each other's bonded parties
                // Also handle shared bonded parties with random assignment
                
                // Get all tribes that have bonds with either warring party
                let t1BondedParties = new Set();
                let t2BondedParties = new Set();
                
                // Collect t1's bonded parties (diplomatic or commercial bonds > 10)
                for (let otherId in this.tribes) {
                    if (otherId == tribe1Id || otherId == tribe2Id) continue;
                    let dipBond = t1.diplomaticBonds[otherId] || 0;
                    let comBond = t1.commercialBonds[otherId] || 0;
                    if (dipBond > 10 || comBond > 10) {
                        t1BondedParties.add(otherId);
                    }
                }
                
                // Collect t2's bonded parties (diplomatic or commercial bonds > 10)
                for (let otherId in this.tribes) {
                    if (otherId == tribe1Id || otherId == tribe2Id) continue;
                    let dipBond = t2.diplomaticBonds[otherId] || 0;
                    let comBond = t2.commercialBonds[otherId] || 0;
                    if (dipBond > 10 || comBond > 10) {
                        t2BondedParties.add(otherId);
                    }
                }
                
                // Find shared bonded parties (both have bonds with the same third party)
                let sharedParties = [];
                for (let partyId of t1BondedParties) {
                    if (t2BondedParties.has(partyId)) {
                        sharedParties.push(partyId);
                    }
                }
                
                // Handle shared bonded parties: Random assignment (each party keeps bonds with some, loses with others)
                for (let sharedId of sharedParties) {
                    // Random: 50% chance t1 keeps the bond, 50% chance t2 keeps it
                    if (Math.random() < 0.5) {
                        // t1 keeps the bond, t2 loses it
                        t2.diplomaticBonds[sharedId] = 0;
                        t2.commercialBonds[sharedId] = 0;
                        if (this.tribes[sharedId]) {
                            this.tribes[sharedId].diplomaticBonds[tribe2Id] = 0;
                            this.tribes[sharedId].commercialBonds[tribe2Id] = 0;
                        }
                    } else {
                        // t2 keeps the bond, t1 loses it
                        t1.diplomaticBonds[sharedId] = 0;
                        t1.commercialBonds[sharedId] = 0;
                        if (this.tribes[sharedId]) {
                            this.tribes[sharedId].diplomaticBonds[tribe1Id] = 0;
                            this.tribes[sharedId].commercialBonds[tribe1Id] = 0;
                        }
                    }
                }
                
                // Break t1's bonds with t2's bonded parties (excluding shared parties already handled)
                for (let t2PartyId of t2BondedParties) {
                    if (!sharedParties.includes(t2PartyId)) {
                        // Break bonds between t1 and t2's bonded party
                        t1.diplomaticBonds[t2PartyId] = 0;
                        const prevBond1 = t1.commercialBonds[t2PartyId] || 0;
                        const prevBond2 = t1.diplomaticBonds[t2PartyId] || 0;
                        t1.commercialBonds[t2PartyId] = 0;
                        t1.diplomaticBonds[t2PartyId] = 0;
                        if (this.tribes[t2PartyId]) {
                            const prevBond3 = this.tribes[t2PartyId].diplomaticBonds[tribe1Id] || 0;
                            const prevBond4 = this.tribes[t2PartyId].commercialBonds[tribe1Id] || 0;
                            this.tribes[t2PartyId].diplomaticBonds[tribe1Id] = 0;
                            this.tribes[t2PartyId].commercialBonds[tribe1Id] = 0;
                            // Reduce relations when bonds are broken due to war
                            this.updateOpinion(tribe1Id, t2PartyId, -10);
                            this.updateOpinion(t2PartyId, tribe1Id, -10);
                            
                        }
                    }
                }
                
                // Break t2's bonds with t1's bonded parties (excluding shared parties already handled)
                for (let t1PartyId of t1BondedParties) {
                    if (!sharedParties.includes(t1PartyId)) {
                        // Break bonds between t2 and t1's bonded party
                        t2.diplomaticBonds[t1PartyId] = 0;
                        t2.commercialBonds[t1PartyId] = 0;
                        if (this.tribes[t1PartyId]) {
                            this.tribes[t1PartyId].diplomaticBonds[tribe2Id] = 0;
                            this.tribes[t1PartyId].commercialBonds[tribe2Id] = 0;
                            // Reduce relations when bonds are broken due to war
                            this.updateOpinion(tribe2Id, t1PartyId, -10);
                            this.updateOpinion(t1PartyId, tribe2Id, -10);
                        }
                    }
                }
                
                // Relations plummet between the two warring parties
                t1.relations[tribe2Id] = Math.min(-80, t1.relations[tribe2Id] - 50);
                t2.relations[tribe1Id] = Math.min(-80, t2.relations[tribe1Id] - 50);
            }
            
            endWar(tribe1Id, tribe2Id, peaceTreaty = false) {
                let t1 = this.tribes[tribe1Id];
                let t2 = this.tribes[tribe2Id];
                if (!t1 || !t2) return;
                
                t1.atWarWith[tribe2Id] = false;
                t2.atWarWith[tribe1Id] = false;
                
                // War bond is automatically removed when atWarWith is set to false (bond drawing checks this)
                
                // PERFORMANCE: Clean up war-related data structures
                // Clear any war-related cached data that might be accumulating
                if (t1.leaderUnderAttack && t1.leaderUnderAttackTargetId) {
                    // Reset leader attack state after war
                    t1.leaderUnderAttack = false;
                    t1.leaderUnderAttackTargetId = null;
                }
                if (t2.leaderUnderAttack && t2.leaderUnderAttackTargetId) {
                    t2.leaderUnderAttack = false;
                    t2.leaderUnderAttackTargetId = null;
                }
                
                // PERFORMANCE: Cleanup after war ends to recover performance
                if (typeof sim !== 'undefined' && sim._cleanupAfterWar) {
                    sim._cleanupAfterWar();
                }
                t1.warExhaustion[tribe2Id] = 0;
                t2.warExhaustion[tribe1Id] = 0;
                
                // Update HUD status message
                if (typeof sim !== 'undefined') {
                    sim.setStatusMessage(`üïäÔ∏è WAR ENDED: Tribe ${tribe1Id} and Tribe ${tribe2Id} made peace`, 300); // Show for 300 frames
                }
                
                // WAR END SOUND - Play peaceful ascending tone when war ends
                
                if (peaceTreaty) {
                    // Peace treaty: relations improve, diplomatic bonds start
                    t1.relations[tribe2Id] = Math.max(-20, t1.relations[tribe2Id] + 30);
                    t2.relations[tribe1Id] = Math.max(-20, t2.relations[tribe1Id] + 30);
                    let oldDip1 = t1.diplomaticBonds[tribe2Id] || 0;
                    let oldDip2 = t2.diplomaticBonds[tribe1Id] || 0;
                    t1.diplomaticBonds[tribe2Id] = 20;
                    t2.diplomaticBonds[tribe1Id] = 20;
                    
                    // DIPLOMATIC BOND CREATED - Nice harmonious sound
                    if ((oldDip1 < 10 || oldDip2 < 10) && typeof sfx !== 'undefined' && sfx.enabled) {
                        sfx.play('bond', getHarmonicFreq([HARMONICS.A4, HARMONICS.C5, HARMONICS.E5, HARMONICS.G5], 10), 0.15); // Harmonious diplomatic tone
                    }
                }
            }
            
            isAtWar(tribe1Id, tribe2Id) {
                let t1 = this.tribes[tribe1Id];
                if (!t1) return false;
                return t1.atWarWith[tribe2Id] === true;
            }
            
            // PROFIT-BASED BOND SYSTEM - Bonds persist as long as they're mutually beneficial!
            updateBonds(tribeId) {
                let tribe = this.tribes[tribeId];
                if (!tribe) return;
                
                let currentFrame = typeof sim !== 'undefined' ? sim.frame : 0;
                
                for (let otherId in this.tribes) {
                    if (otherId == tribeId) continue;
                    
                    // Skip if at war - war breaks all bonds immediately
                    if (tribe.atWarWith[otherId]) {
                        tribe.diplomaticBonds[otherId] = 0;
                        tribe.commercialBonds[otherId] = 0;
                        continue;
                    }
                    
                    // MUTUALLY REINFORCING: Strong commercial bonds strengthen diplomatic bonds
                    let comBond = tribe.commercialBonds[otherId] || 0;
                    let dipBond = tribe.diplomaticBonds[otherId] || 0;
                    
                    // Track previous values to detect threshold crossings
                    const prevDipBond = dipBond;
                    const prevComBond = comBond;
                    const STABLE_BOND_THRESHOLD = 30; // Bonds are considered "stable" above this
                    
                    if (comBond > 50 && dipBond < comBond) {
                        // Strong trade creates diplomatic ties
                        tribe.diplomaticBonds[otherId] = Math.min(100, dipBond + 0.2); // Faster growth
                    }
                    
                    if (dipBond > 50 && comBond < dipBond) {
                        // Strong diplomacy encourages trade
                        tribe.commercialBonds[otherId] = Math.min(100, comBond + 0.2); // Faster growth
                    }
                    
                    // MUTUALLY REINFORCING (strong bonds automatically maintain)
                    if (comBond > CONFIG.bondReinforcementThreshold && dipBond > CONFIG.bondReinforcementThreshold) {
                        // Both bonds strong - they reinforce each other (GROW instead of decay!)
                        tribe.diplomaticBonds[otherId] = Math.min(100, dipBond + 0.1);
                        tribe.commercialBonds[otherId] = Math.min(100, comBond + 0.1);
                    }
                    
                    // Check if bonds crossed stable threshold (formed)
                    const newDipBond = tribe.diplomaticBonds[otherId] || 0;
                    const newComBond = tribe.commercialBonds[otherId] || 0;
                    
                    // DIPLOMATIC BOND CREATED - Nice harmonious sound (when crossing threshold)
                    if (dipBond < 10 && newDipBond >= 10 && typeof sfx !== 'undefined' && sfx.enabled) {
                        sfx.play('bond', getHarmonicFreq([HARMONICS.A4, HARMONICS.C5, HARMONICS.E5, HARMONICS.G5], 10), 0.12); // Harmonious diplomatic tone
                    }
                    
                    // COMMERCIAL BOND CREATED - Nice harmonious sound (when crossing threshold)
                    if (comBond < 10 && newComBond >= 10 && typeof sfx !== 'undefined' && sfx.enabled) {
                        sfx.play('bond', getHarmonicFreq([HARMONICS.A4, HARMONICS.C5, HARMONICS.E5, HARMONICS.G5], 10), 0.12); // Harmonious commercial/trade tone
                    }
                    
                    // ============================================
                    // COMMERCIAL BONDS: Decay ONLY if UNPROFITABLE
                    // COMPETITIVE RELATIONSHIPS: Break if trading with enemy
                    // ============================================
                    if (comBond > 0) {
                        // COMPETITIVE COMMERCIAL RELATIONSHIPS
                        // If other tribe has commercial relationships with our enemies, break the bond
                        let otherTribe = this.tribes[otherId];
                        if (otherTribe) {
                            for (let enemyId in tribe.atWarWith) {
                                if (tribe.atWarWith[enemyId] && otherTribe.commercialBonds[enemyId] > 20) {
                                    // They're trading with our enemy - break commercial bond!
                                    tribe.commercialBonds[otherId] = 0;
                                    otherTribe.commercialBonds[tribeId] = 0;
                                    // Reduce relations as well
                                    this.updateOpinion(tribeId, otherId, -15);
                                    this.updateOpinion(otherId, tribeId, -15);
                                    continue; // Skip rest of processing for this bond
                                }
                            }
                            // Check if other tribe is at war with any of our commercial partners
                            for (let partnerId in tribe.commercialBonds) {
                                if (tribe.commercialBonds[partnerId] > 20 && otherTribe.atWarWith[partnerId]) {
                                    // They're at war with our commercial partner - break bond!
                                    tribe.commercialBonds[otherId] = 0;
                                    otherTribe.commercialBonds[tribeId] = 0;
                                    this.updateOpinion(tribeId, otherId, -15);
                                    this.updateOpinion(otherId, tribeId, -15);
                                    continue;
                                }
                            }
                        }
                        
                        let lastTrade = tribe.lastTradeTime[otherId] || 0;
                        let framesSinceLastTrade = currentFrame - lastTrade;
                        let tradeProfit = tribe.tradeProfit[otherId] || 0;
                        
                        // Calculate recent profit (rolling window)
                        let recentProfit = 0;
                        if (tribe.tradeProfitHistory[otherId]) {
                            tribe.tradeProfitHistory[otherId].forEach(entry => {
                                if (currentFrame - entry.frame < 500) { // Last 500 frames
                                    recentProfit += entry.profit;
                                }
                            });
                        }
                        
                        // BONDS PERSIST IF TRADE IS PROFITABLE!
                        if (recentProfit > 0) {
                            // Trade is profitable - MAINTAIN bond automatically!
                            // No decay needed - the bond is economically justified
                            // Optional: Small growth if very profitable
                            if (recentProfit > 100) {
                                tribe.commercialBonds[otherId] = Math.min(100, comBond + 0.05);
                            }
                        } else if (framesSinceLastTrade > 1000) {
                            // No trade for 1000 frames AND no recent profit - might decay
                            // But check if they CAN trade (do they have resources?)
                            let nest = this.nests.find(n => n.tribeId == tribeId);
                            let otherNest = this.nests.find(n => n.tribeId == otherId);
                            
                            if (nest && otherNest) {
                                // Both nests exist - check if they CAN trade
                                let canTrade = nest.wealth > 30 && otherNest.wealth > 30;
                                
                                if (!canTrade) {
                                    // Can't afford to trade - slow decay
                                    let newComBond = Math.max(0, comBond - CONFIG.bondDecayRate * 0.3); // Very slow
                                    tribe.commercialBonds[otherId] = newComBond;
                                    
                                    // UNPROFITABLE BOND BREAKS ‚Üí DISLIKE!
                                    if (comBond >= 10 && newComBond < 10) {
                                        // Reduce relations when bond breaks due to unprofitability
                                        this.updateOpinion(tribeId, otherId, -20); // Significant hit to relations!
                                        this.updateOpinion(otherId, tribeId, -20);
                                    }
                                    
                                    tribe.commercialBonds[otherId] = newComBond;
                                    
                                    // Cleanup if decayed to 0
                                    if (newComBond <= 0) {
                                        delete tribe.commercialBonds[otherId];
                                    }
                                } else if (framesSinceLastTrade > 2000) {
                                    // Can trade but haven't for 2000 frames - very slow decay
                                    let newComBond = Math.max(0, comBond - CONFIG.bondDecayRate * 0.1);
                                    
                                    // Long inactivity hurts relations slightly
                                    if (comBond >= 10 && newComBond < 10) {
                                        this.updateOpinion(tribeId, otherId, -10); // Smaller hit
                                        this.updateOpinion(otherId, tribeId, -10);
                                    }
                                    
                                    tribe.commercialBonds[otherId] = newComBond;
                                }
                            }
                        }
                    }
                    
                    // ============================================
                    // DIPLOMATIC BONDS: Decay ONLY if NO BENEFITS
                    // ============================================
                    if (dipBond > 0) {
                        let lastDiplomacy = tribe.lastDiplomacyTime[otherId] || 0;
                        let framesSinceLastDiplomacy = currentFrame - lastDiplomacy;
                        let diplomaticValue = tribe.diplomaticBenefits[otherId] || 0;
                        
                        // Bonds persist if there's been recent diplomatic activity OR ongoing benefits
                        if (framesSinceLastDiplomacy < 1000 || diplomaticValue > 0) {
                            // Active diplomacy or benefits - MAINTAIN bond
                            // Slow decay of benefit counter
                            if (diplomaticValue > 0) {
                                tribe.diplomaticBenefits[otherId] *= 0.99; // Slow decay of benefits
                            }
                        } else if (framesSinceLastDiplomacy > 2000) {
                            // No diplomacy for 2000 frames AND no benefits - very slow decay
                            let newDipBond = Math.max(0, dipBond - CONFIG.bondDecayRate * 0.2);
                            tribe.diplomaticBonds[otherId] = newDipBond;
                            // Cleanup if decayed to 0
                            if (newDipBond <= 0) {
                                delete tribe.diplomaticBonds[otherId];
                            }
                            
                            // DIPLOMATIC BOND BREAKS ‚Üí DISLIKE!
                            if (dipBond >= 10 && newDipBond < 10) {
                                // Reduce relations when diplomatic bond breaks
                                this.updateOpinion(tribeId, otherId, -15); // Diplomatic failure hurts relations
                                this.updateOpinion(otherId, tribeId, -15);
                            }
                            
                            tribe.diplomaticBonds[otherId] = newDipBond;
                            
                            // Cleanup if decayed to 0
                            if (newDipBond <= 0) {
                                delete tribe.diplomaticBonds[otherId];
                            }
                        }
                    }
                    
                    // AUTO-DECLARE WAR if relations are terrible and no bonds exist
                    let relation = tribe.relations[otherId] || 0;
                    if (relation < CONFIG.warDeclarationThreshold && dipBond === 0 && comBond === 0) {
                        // Relations very low, no bonds - MUCH HIGHER chance of war
                        if (Math.random() < 0.35) { // 35% chance per update (was 15%)
                            this.declareWar(tribeId, otherId);
                            console.log(`WAR DECLARED between tribe ${tribeId} and ${otherId}! Relations: ${relation}`);
                        }
                    }
                    
                    // ESCALATION: Even with bonds, terrible relations can lead to war
                    if (relation < CONFIG.warDeclarationThreshold * 1.3 && (dipBond < 20 || comBond < 20)) {
                        // Weak bonds, terrible relations - can still go to war
                        if (Math.random() < 0.2) { // 20% chance (was 8%)
                            this.declareWar(tribeId, otherId);
                            console.log(`WAR ESCALATED between tribe ${tribeId} and ${otherId}! Relations: ${relation.toFixed(1)}`);
                        }
                    }
                    
                    // RIVALRY: MORE AGGRESSIVE deterioration
                    if (Math.random() < 0.05 && dipBond < 30 && comBond < 30) { // 5% chance (was 2%)
                        this.updateOpinion(tribeId, otherId, -3); // Faster deterioration (was -2)
                        this.updateOpinion(otherId, tribeId, -3);
                    }
                }
            }

            updateOpinion(fromTribe, toTribe, amount) {
                if (!this.tribes[fromTribe] || !this.tribes[toTribe] || fromTribe === toTribe) return;
                this.tribes[fromTribe].relations[toTribe] += amount;
                if (this.tribes[fromTribe].relations[toTribe] > 100) this.tribes[fromTribe].relations[toTribe] = 100;
                if (this.tribes[fromTribe].relations[toTribe] < -100) this.tribes[fromTribe].relations[toTribe] = -100;
            }
        }

        /* --- CLASSES --- */

        class Particle {
            constructor(x, y, color, type) {
                this.pos = new Vector(x, y);
                this.vel = Vector.random2D().mult(Math.random() * 2);
                this.life = 1.0;
                this.color = color;
                this.type = type || 'circle'; 
            }
            update() {
                this.pos.add(this.vel);
                this.life -= 0.05;
            }
            draw(ctx) {
                ctx.globalAlpha = Math.max(0, this.life);
                ctx.fillStyle = this.color;
                
                if (this.type === 'heart') {
                    ctx.beginPath();
                    ctx.arc(this.pos.x, this.pos.y, 3, 0, Math.PI*2);
                    ctx.fill();
                } else if (this.type === 'spark') {
                    ctx.beginPath();
                    ctx.rect(this.pos.x-1, this.pos.y-1, 2, 2);
                    ctx.fill();
                } else if (this.type === 'lightning') {
                    ctx.strokeStyle = this.color;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(this.pos.x, this.pos.y - 10);
                    ctx.lineTo(this.pos.x + 5, this.pos.y);
                    ctx.lineTo(this.pos.x, this.pos.y + 10);
                    ctx.stroke();
                } else if (this.type === 'star') {
                    // Five-pointed star
                    ctx.beginPath();
                    for(let i = 0; i < 5; i++) {
                        let angle = (i * 4 * Math.PI / 5) - Math.PI / 2;
                        let x = this.pos.x + Math.cos(angle) * 4;
                        let y = this.pos.y + Math.sin(angle) * 4;
                        if(i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.fill();
                } else if (this.type === 'ring') {
                    // Expanding ring
                    ctx.strokeStyle = this.color;
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(this.pos.x, this.pos.y, 5 * (1 - this.life), 0, Math.PI*2);
                    ctx.stroke();
                } else if (this.type === 'plus') {
                    // Plus sign for healing
                    ctx.fillRect(this.pos.x - 3, this.pos.y - 1, 6, 2);
                    ctx.fillRect(this.pos.x - 1, this.pos.y - 3, 2, 6);
                } else if (this.type === 'dollar') {
                    // Dollar sign for wealth
                    ctx.font = '8px monospace';
                    ctx.fillText('$', this.pos.x - 3, this.pos.y + 3);
                } else if (this.type === 'skull') {
                    // Skull emoji-like
                    ctx.font = '10px monospace';
                    ctx.fillText('‚úï', this.pos.x - 3, this.pos.y + 3);
                } else if (this.type === 'blood') {
                    // Blood splatter
                    ctx.beginPath();
                    ctx.arc(this.pos.x, this.pos.y, 1 + Math.random() * 2, 0, Math.PI*2);
                    ctx.fill();
                } else {
                    ctx.beginPath();
                    ctx.arc(this.pos.x, this.pos.y, 2, 0, Math.PI*2);
                    ctx.fill();
                }
                ctx.globalAlpha = 1.0;
            }
        }
        
        // PROJECTILE CLASS FOR RANGED COMBAT
        class Projectile {
            constructor(x, y, targetX, targetY, shooter, damage, type='arrow') {
                this.pos = new Vector(x, y);
                this.target = new Vector(targetX, targetY);
                this.shooter = shooter; // Agent who shot it
                this.damage = damage;
                this.type = type; // 'arrow', 'bolt'
                this.speed = 8;
                this.active = true;
                this.life = 180; // Max frames before disappearing
                
                // Calculate velocity towards target
                let direction = Vector.sub(this.target, this.pos);
                direction.normalize();
                this.vel = direction.mult(this.speed);
            }
            
            update(agents, nests) {
                if (!this.active) return false;
                
                this.pos.add(this.vel);
                this.life--;
                
                if (this.life <= 0) {
                    this.active = false;
                    return false;
                }
                
                // Check collision with agents
                for (let agent of agents) {
                    if (agent.dead) continue;
                    if (agent === this.shooter) continue; // Can't hit self
                    
                    let d = Vector.dist(this.pos, agent.pos);
                    if (d < agent.radius + 5) {
                        // Hit! Agents inside nests are 1.5x harder to kill
                        let damage = agent.isInsideNest() ? this.damage / 1.5 : this.damage;
                        agent.health -= damage;
                        this.active = false;
                        
                        // VFX
                        if (typeof sim !== 'undefined') {
                            // Only create blood particle if particle count is reasonable
                        if (sim.particles.length < 200) {
                            // Only create blood particle if particle count is reasonable
                            if (sim.particles.length < 200) {
                            sim.particles.push(new Particle(agent.pos.x, agent.pos.y, '#dc2626', 'blood'));
                            }
                        }
                            // TEMPORARILY DISABLED FOR TESTING
                            // sfx.play('attack', 350, 0.1);
                            
                            // DETERIORATE RELATIONS when projectile hits
                            if (this.shooter && this.shooter.tribeId !== undefined && agent.tribeId !== undefined && 
                                this.shooter.tribeId !== -1 && agent.tribeId !== -1 && 
                                this.shooter.tribeId !== agent.tribeId) {
                                sim.tribes.updateOpinion(this.shooter.tribeId, agent.tribeId, -2); // Aggressor dislikes victim more
                                sim.tribes.updateOpinion(agent.tribeId, this.shooter.tribeId, -4); // Victim REALLY dislikes aggressor
                            }
                        }
                        return false;
                    }
                }
                
                return true;
            }
            
            draw(ctx) {
                if (!this.active) return;
                
                ctx.save();
                ctx.globalAlpha = Math.min(1.0, this.life / 60);
                
                    // Arrow/bolt - line with point
                    ctx.strokeStyle = this.type === 'bolt' ? '#60a5fa' : '#a8a29e';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(this.pos.x - this.vel.x, this.pos.y - this.vel.y);
                    ctx.lineTo(this.pos.x, this.pos.y);
                    ctx.stroke();
                    
                    // Arrowhead
                    ctx.fillStyle = this.type === 'bolt' ? '#3b82f6' : '#57534e';
                    ctx.beginPath();
                    ctx.arc(this.pos.x, this.pos.y, 2, 0, Math.PI * 2);
                    ctx.fill();
                
                ctx.restore();
            }
        }

        class Agent {
            constructor(x, y, dna, parents, tribeId) {
                this.pos = new Vector(x, y);
                this.vel = Vector.random2D();
                this.acc = new Vector(0, 0);
                this.wanderTheta = 0; 
                
                this.id = Math.random().toString(36).substr(2, 6).toUpperCase();
                this.age = 0;
                this.lifespan = (CONFIG.lifespanBase + (Math.random() * 1000)) * CONFIG.deathRate; 
                this.maxLifespan = this.lifespan * 2;
                
                // Roaming & oscillating movement state
                this.nextNestReturn = 0; // Frame when roamer should return to nest
                this.nextGrazerSpawn = 0; // Frame when farmer should spawn next grazer
                this.oscillatePhase = 0; // Current phase in oscillation cycle (0-3)
                
                this.dead = false;
                this.state = "Wander";
                this.isHero = false;
                
                // Food chain roles
                this.isGrazer = false;
                this.isPredator = false;
                this.isPrey = false;
                
                this.energy = 100;
                this.maxEnergy = 300;
                this.wealth = 0; 
                this.health = 100;
                this.maxHealth = 100;
                
                // Inherit Skills from Tribe Tech Level
                let startSkill = 0;
                if (parents && sim.tribes.tribes[tribeId]) {
                    let tier = sim.tribes.tribes[tribeId].techTier;
                    if ((sim.tribes.tribes[tribeId].roles['Scientist'] || 0) > 0) startSkill = 1;
                    
                    // Safe access to parent wealth (parents might not have p1/p2 or wealth)
                    let parentWealth = 0;
                    if (parents.p1 && typeof parents.p1.wealth !== 'undefined') parentWealth += parents.p1.wealth;
                    if (parents.p2 && typeof parents.p2.wealth !== 'undefined') parentWealth += parents.p2.wealth;
                    let healthBonus = Math.min(200, parentWealth / 10); 
                    this.maxHealth += healthBonus;
                    this.health = this.maxHealth;
                }
                
                this.charisma = 0; 
                this._baseCharisma = 0; // Initialize base charisma for artisan multiplier 
                this.carrying = null;
                this.home = null; 
                this.partners = []; 
                this.lastPos = new Vector(x, y);
                this.stuckCounter = 0;
                this.targetId = null;
                this.shootCooldown = 0;

                this.kills = 0;
                // Set generation: if parents provided and have valid gen, increment it; otherwise start at 1
                if (parents && typeof parents.gen === 'number' && !isNaN(parents.gen)) {
                    this.generation = parents.gen + 1;
                } else {
                    this.generation = 1;
                }
                this.mateCooldown = 0;
                this.loyalty = {}; 
                this.kin = []; 

                this.disease = 0; 
                this.immunity = 0; 
                
                // Rigid bond bonuses
                this.shieldBonus = 0;
                this.huntBonus = 1.0;
                this.gatherRangeBonus = 1.0;
                
                // Ranged combat
                this.shotCooldown = 0; // Frames until can shoot again
                this.canShootRanged = false; // Only soldiers can shoot (set in determineRole)
                
                // Diplomat/Merchant properties
                this.isSustainedByTribe = false; // Set true for diplomats/merchants
                this.canDefendSelf = true; // Set false for diplomats/merchants

                this.researchPoints = 0;
                this.skills = {
                    SPEED: startSkill,
                    ENERGY: startSkill,
                    HEALTH: startSkill,
                    MANUFACTURE: startSkill,
                    SENSE: startSkill,
                    SHIELD: startSkill,
                    FARMING: startSkill,
                    COMBAT: startSkill,
                    DIPLOMACY: startSkill
                };

                if (tribeId !== undefined) this.tribeId = tribeId;
                else if (parents && parents.tribeId !== undefined) this.tribeId = parents.tribeId;
                else this.tribeId = Math.floor(Math.random() * CONFIG.tribeCount);

                this.frenzyTimer = 0; 

                // DEFAULT DNA + MERGE (For Monsters)
                let defaults = {
                    aggression: Math.random(), social: Math.random(), builder: Math.random(),
                    speed: 0.3+Math.random()*0.7, size: 0.4+Math.random()*0.6, sense: 0.2+Math.random()*0.8,
                    botany: Math.random(), mining: Math.random(), defense: Math.random(),
                    raiding: Math.random(), defending: Math.random(), manufacturing: Math.random(),
                    intelligence: Math.random(), commerce: Math.random(), 
                    predator_target: Math.random(), prey_signal: Math.random(),
                    twitch: Math.random(), sociability: Math.random(),
                    altruism: Math.random(), curiosity: Math.random(),
                    // Movement genes (bias for compass directions)
                    move_n: Math.random(), move_s: Math.random(), move_e: Math.random(), move_w: Math.random(),
                    move_ne: Math.random(), move_se: Math.random(), move_nw: Math.random(), move_sw: Math.random(),
                    // Rigid bond gene (rare, low frequency, additive)
                    rigid_bond_preference: Math.random() * CONFIG.rigidBondChance,
                    // Bond type preference genes
                    family_bond_pref: Math.random(),
                    romantic_bond_pref: Math.random(),
                    alliance_bond_pref: Math.random(),
                    mentor_bond_pref: Math.random(),
                    friendship_bond_pref: Math.random(),
                    // Roaming gene (0 = stay near nest, 1 = roam freely)
                    roaming: Math.random(),
                    nest_return_frequency: Math.random(), // How often to return when roaming
                    // Oscillating movement pattern genes (up to 8-move cycles)
                    oscillate_cycle_speed: Math.random(), // How fast to cycle through pattern (frames per step)
                    oscillate_amplitude: Math.random() * 0.5, // How strongly to apply pattern (reduced to prevent sticking)
                    movement_tendency: 0.5 + Math.random() * 0.5, // Bias toward forward movement (0.5-1.0, prevents stasis)
                    movement_pattern: Math.floor(Math.random() * 6), // Movement behavior gene
                    // Movement pattern: array of 8 direction values (0-7 representing N,NE,E,SE,S,SW,W,NW)
                    // Each agent has a unique pattern that can mutate, with weighted probabilities
                    oscillate_pattern: Array(8).fill(0).map(() => Math.floor(Math.random() * 8)),
                    oscillate_weights: Array(8).fill(0).map(() => 0.5 + Math.random() * 0.5), // Weight for each direction (0.5-1.0)
                    resource_conversion_preference: Math.random(),
                    converter_special_gene: Math.random()
                };
                
                if (dna) this.dna = { ...defaults, ...dna };
                else this.dna = defaults;

                this.maxBonds = Math.max(1, Math.floor((this.dna && this.dna.sociability || 0.5) * 4)); 
                
                // Bond types: Each partner has a bond type with different effects
                this.bondTypes = {}; // Map from partner ID to bond type
                this.rigidBonds = {}; // Map from partner ID to rigid bond type ('shield', 'hunt', 'gather', 'swift', null) 

                this.prefs = {
                    hunt: 1.0,
                    social: 1.0,
                    build: 1.0,
                    flee: 1.0
                };

                this.determineRole(parents);
                this.baseRadius = (this.dna && this.dna.size || 1) * 5 + 3;
                this.radius = this.baseRadius;
                this.baseSpeed = (this.dna && this.dna.speed || 0.5) * 2 + 1 + ((this.dna && this.dna.agility) || 0.5) * 0.5; 
                this.maxSpeed = this.baseSpeed;
                this.baseMaxLifespan = this.maxLifespan;
                this.hasRigidLifespanBonus = false;
                this.structureStability = 0;
                this.lastPartnerHash = '';
                this.structureBandActive = false;
                this.structureStabilityGroupSize = 1;
                this.groupFormationFrame = typeof sim !== 'undefined' ? sim.frame : 0;
                // REMOVED CACHING - No longer using group cache to prevent doubling artifacts
                this.isGroupEntity = false;
                this.groupEntityMembers = [];
                this.groupAscendedFrame = -Infinity;
                this.groupEntityParent = null;
                this.converterBondGroups = [];
                this.lastBonderSpawnFrame = -Infinity;
                this.isConverterUnit = false;
                this.converterSource = null;
                this.converterTarget = null;
                this.converterOwner = null;
                this.isConverterBonder = false;
                this.lastBondAttempt = -Infinity;
                this.lastBonderSpawnFrame = 0;
                
                // MOMENTUM - agents have inertia based on size and health
                this.momentum = new Vector(0, 0);
                this.mass = this.baseRadius * (this.health / 100); // Mass = size √ó health factor
                this.maxForce = 0.3; 
                this.baseSense = 120 + ((this.dna && this.dna.sense || 0.5) * 150);
                this.senseRad = this.baseSense; 
                
                if (parents && parents.skills) {
                    for(let k in parents.skills) {
                        if (Math.random() < 0.5) this.learnSkill(k, parents.skills[k]);
                    }
                }

                // NEW: Start as child
                if (parents) {
                    this.radius *= 0.6;
                    this.maxSpeed *= 0.8;
                    if (parents.p1) { this.addPartner(parents.p1); this.kin.push(parents.p1.id); parents.p1.kin.push(this.id); }
                    if (parents.p2) { this.addPartner(parents.p2); this.kin.push(parents.p2.id); parents.p2.kin.push(this.id); }
                }
                
                // SOFT MUSICAL TONE WHEN AGENT IS BORN
                // Play a gentle, pleasant musical tone for agent birth
                if (typeof sfx !== 'undefined' && sfx.enabled) {
                    // Use pentatonic scale notes for pleasant, harmonious sound
                    // Musical scale frequencies: C, D, E, G, A (pentatonic - sounds pleasant)
                    let musicalNotes = [HARMONICS.C5, HARMONICS.D5, HARMONICS.E5, HARMONICS.G5, HARMONICS.A5]; // Harmonic pentatonic
                    let note = musicalNotes[Math.floor(Math.random() * musicalNotes.length)];
                    // Soft, gentle tone - lower volume and longer duration for pleasant effect
                    // TEMPORARILY DISABLED FOR TESTING
                    // sfx.play('birth', note, 0.15, 0.4); // 0.15s duration, 40% volume for softness
                }
            }

            determineRole(parents) {
                if (this.dna.monster) {
                    this.role = 'Monster';
                    this.color = '#581c87'; 
                    this.radius = 25;
                    this.maxEnergy = 2000;
                    this.energy = 2000;
                    this.health = 500;
                    this.lifespan = CONFIG.monsterLifespan; 
                    this.tribeId = -1; 
                    // Leaders/Guardians/Monsters get super stats
                    this.maxHealth = 2000;
                    this.health = 2000;
                    return;
                }

                // EMERGENCE: Use Tech Tree Logic
                if (typeof sim !== 'undefined' && parents && sim.tribes && sim.tribes.tribes[this.tribeId]) {
                    let mutationChance = 0.1;
                    if (parents.p1 && parents.p2 && parents.p1.role && parents.p2.role && parents.p1.role !== parents.p2.role) mutationChance = 0.5; 
                    
                    if (Math.random() < mutationChance) {
                        let desired = sim.tribes.getDesiredRole(this.tribeId);
                        if (desired) {
                            this.role = desired;
                            this.assignColor();
                            return;
                        }
                    }
                }

                // Calculate commercial bond bonus for merchant role
                let commerceBonus = 0.3; // Base bonus to ensure merchants spawn
                if (typeof sim !== 'undefined' && this.tribeId !== -1 && sim.tribes && sim.tribes.tribes[this.tribeId]) {
                    let myTribe = sim.tribes.tribes[this.tribeId];
                    let totalCommercial = 0;
                    for (let otherId in myTribe.commercialBonds) {
                        totalCommercial += myTribe.commercialBonds[otherId];
                    }
                    // Strong commercial ties boost merchant births even more
                    commerceBonus += totalCommercial / 100; // Up to +1.0 bonus for max bonds
                }
                
                // Calculate manufacturing bonus for artisan role (MASSIVELY BOOSTED!)
                let manufacturingBonus = commerceBonus * 2.0 + 0.5; // 4x increase + base bonus

                const dna = this.dna || {};
                const traits = [
                    { name: 'Garbage Collector', val: ((dna.mining || 0) + (dna.altruism || 0) + (dna.curiosity || 0)) / 2.0 + 0.2 }, // Early tech tree role
                    { name: 'Farmer', val: ((dna.botany || 0) + (dna.altruism || 0) + (dna.defense || 0)) / 2.0 + 0.15 }, // Spawns grazers, protects them
                    { name: 'Soldier', val: (dna.aggression || 0) * 1.8 + 0.3 }, // BOOSTED soldier spawning!
                    { name: 'Botanist', val: dna.botany || 0 },
                    { name: 'Builder', val: dna.builder || 0 },
                    { name: 'Guardian', val: ((dna.defense || 0) + (dna.defending || 0))/2 },
                    { name: 'Scout', val: dna.speed || 0 },
                    { name: 'Miner', val: (dna.mining || 0) + 0.2 }, // Small boost
                    { name: 'Raider', val: dna.raiding || 0 },
                    { name: 'Artisan', val: (dna.manufacturing || 0) * 2.0 + manufacturingBonus }, // DOUBLED base + huge bonus!
                    { name: 'Scientist', val: (dna.intelligence || 0) * 1.5 + 0.2 }, // Boosted from 1.2 to 1.5
                    { name: 'Merchant', val: (dna.commerce || 0) * 1.5 + commerceBonus }, // Boosted 1.5x plus bonus
                    { name: 'Healer', val: ((dna.altruism || 0) + (dna.botany || 0)) / 1.5 + 0.15 }, // Small boost
                    { name: 'Diplomat', val: ((dna.social || 0) + (dna.commerce || 0) + (dna.curiosity || 0)) / 2.5 },
                    { name: 'Teacher', val: ((dna.social || 0) + (dna.intelligence || 0)) / 2.0 + 0.2 } // Small boost
                ];
                traits.sort((a, b) => b.val - a.val);
                this.role = traits[0].name;
                this.assignColor();
                
                // Buff Guardians/Leaders
                if (this.role === 'Guardian') {
                    this.maxHealth = 500; 
                    this.health = 500;
                }
            }

            isInsideNest() {
                // Check if agent is inside any nest of their tribe
                if (!sim || this.tribeId === -1) return false;
                let myNest = sim.tribes.nests.find(n => n.tribeId === this.tribeId);
                if (!myNest) return false;
                let distToNest = Vector.dist(this.pos, myNest.pos);
                return distToNest < myNest.radius;
            }

            createInitialResources() {
                // Resource-creating/consuming agents immediately create appropriate resources when spawned
                if (!sim) return;
                
                if (this.role === 'Farmer') {
                    // Farmers create grazers (the resource they create)
                    // REDUCED: Initial burst reduced by 50% (from 10 to 5 grazers per farmer)
                    for (let i = 0; i < 5; i++) {
                        let spawnX = this.pos.x + (Math.random() * 100 - 50);
                        let spawnY = this.pos.y + (Math.random() * 100 - 50);
                        
                        let grazerDna = {
                            grazer_gene: 0.9,
                            speed: 0.5 + Math.random() * 0.3,
                            size: 0.4 + Math.random() * 0.2,
                            sociability: 0.7 + Math.random() * 0.3
                        };
                        
                        let grazer = new Agent(spawnX, spawnY, grazerDna, null, -1);
                        grazer.role = 'Grazer';
                        grazer.isGrazer = true;
                        sim.agents.push(grazer);
                    }
                } else if (this.role === 'Botanist') {
                    // Botanists create FOOD (the resource they create)
                    for (let i = 0; i < 10; i++) {
                        let plantX = this.pos.x + (Math.random() * 100 - 50);
                        let plantY = this.pos.y + (Math.random() * 100 - 50);
                        sim.spawnResource(null, plantX, plantY, 'FOOD', false, this.tribeId);
                    }
                } else if (this.role === 'Artisan') {
                    // Artisans create MAT (the resource they create)
                    for (let i = 0; i < 10; i++) {
                        let matX = this.pos.x + (Math.random() * 100 - 50);
                        let matY = this.pos.y + (Math.random() * 100 - 50);
                        sim.spawnResource(null, matX, matY, 'MAT', false, this.tribeId);
                    }
                } else if (this.role === 'Miner') {
                    // Miners consume ORE and MAT, so create ORE (their primary resource)
                    for (let i = 0; i < 10; i++) {
                        let oreX = this.pos.x + (Math.random() * 100 - 50);
                        let oreY = this.pos.y + (Math.random() * 100 - 50);
                        sim.spawnResource(null, oreX, oreY, 'ORE', false, this.tribeId);
                    }
                } else if (this.role === 'Builder') {
                    // Builders consume MAT, so create MAT
                    for (let i = 0; i < 10; i++) {
                        let matX = this.pos.x + (Math.random() * 100 - 50);
                        let matY = this.pos.y + (Math.random() * 100 - 50);
                        sim.spawnResource(null, matX, matY, 'MAT', false, this.tribeId);
                    }
                } else if (this.role === 'Merchant') {
                    // Merchants trade FOOD and MAT, so create FOOD (common trade good)
                    for (let i = 0; i < 10; i++) {
                        let foodX = this.pos.x + (Math.random() * 100 - 50);
                        let foodY = this.pos.y + (Math.random() * 100 - 50);
                        sim.spawnResource(null, foodX, foodY, 'FOOD', false, this.tribeId);
                    }
                } else if (this.role === 'Garbage Collector') {
                    // Garbage Collectors recycle various resources, so create MAT (common recycled material)
                    for (let i = 0; i < 10; i++) {
                        let matX = this.pos.x + (Math.random() * 100 - 50);
                        let matY = this.pos.y + (Math.random() * 100 - 50);
                        sim.spawnResource(null, matX, matY, 'MAT', false, this.tribeId);
                    }
                }
                // Other roles (Soldier, Guardian, Scout, Diplomat, Teacher, Scientist, Healer, Raider) don't create resources
            }

            assignColor() {
                // Reset ranged combat ability
                this.canShootRanged = false;
                
                switch(this.role) {
                    case 'Garbage Collector': this.color = '#78716c'; break; // Brown-grey
                    case 'Farmer': this.color = '#a3e635'; break; // Lime green
                    case 'Soldier': 
                        this.color = '#ef4444'; 
                        this.canShootRanged = true; // ONLY SOLDIERS CAN SHOOT
                        this.isSustainedByTribe = true; // Don't hunt food/resources
                        this.maxHealth = 150; // Higher health
                        this.health = Math.min(this.health, 150);
                        break; 
                    case 'Botanist': this.color = '#10b981'; break; 
                    case 'Builder': this.color = '#eab308'; break; 
                    case 'Guardian': this.color = '#64748b'; break; 
                    case 'Scout': this.color = '#22d3ee'; break; 
                    case 'Miner': 
                        this.color = '#ea580c'; 
                        this.isSoloActor = true; // Does not bond
                        break;
                    case 'Raider': this.color = '#6366f1'; break; 
                    case 'Artisan': 
                        this.color = '#a5f3fc'; 
                        this.isSustainedByTribe = true; // Tribe-sustained
                        this.canDefendSelf = false; // Defenseless
                        this.maxHealth = 120;
                        this.health = Math.min(this.health, 120);
                        break;
                    case 'Scientist': 
                        this.color = '#ffffff'; 
                        this.isSustainedByTribe = true; // Tribe-sustained
                        this.canDefendSelf = false; // Defenseless
                        this.maxHealth = 120;
                        this.health = Math.min(this.health, 120);
                        break; 
                    case 'Merchant': this.color = '#be123c'; break;
                    case 'Healer': this.color = '#fbcfe8'; break; 
                    case 'Diplomat': this.color = '#fde047'; break; 
                    case 'Spy': this.color = '#7c3aed'; break; // Purple
                    case 'Technologist': this.color = '#06b6d4'; break; // Cyan
                    case 'Teacher': 
                        this.color = '#c7d2fe'; 
                        this.isSustainedByTribe = true; // Tribe-sustained
                        this.canDefendSelf = false; // Defenseless
                        this.maxHealth = 120;
                        this.health = Math.min(this.health, 120);
                        break; 
                    default: this.color = '#fff';
                }
            }

            isAdult() {
                return this.age > CONFIG.adultAge;
            }
            
            getSpyWeaknessMultiplier() {
                // Returns attack multiplier based on nearby spies (spies weaken non-tribe agents)
                if (this.tribeId === -1) return 1.0; // Food chain agents not affected
                if (typeof sim === 'undefined' || !sim.agents) return 1.0;
                
                // PERFORMANCE: Cache spy weakness calculation per agent per frame to avoid expensive recalculations
                if (typeof sim !== 'undefined' && sim.frame !== undefined) {
                    if (this._spyWeaknessCache !== undefined && this._spyWeaknessCacheFrame === sim.frame) {
                        return this._spyWeaknessCache;
                    }
                }
                
                // PERFORMANCE: Use spatial grid to find nearby spies instead of filtering all agents
                let nearbyAgents = [];
                if (typeof sim !== 'undefined' && sim.spatialGrid && sim.gridCols > 0) {
                    let nearby = sim.getNearbyEntities(this.pos.x, this.pos.y, 150);
                    nearbyAgents = nearby.agents;
                } else {
                    // Fallback: filter only if spatial grid not available
                    nearbyAgents = sim.agents.filter(a => 
                        !a.dead && 
                        Vector.dist(a.pos, this.pos) < 150
                    );
                }
                
                // Count spies from other tribes nearby
                let spiesNearby = nearbyAgents.filter(a => 
                    a.role === 'Spy' && 
                    a.tribeId !== -1 && 
                    a.tribeId !== this.tribeId // Enemy spy
                ).length;
                
                let multiplier = 1.0;
                if (spiesNearby > 0) {
                    // Each spy reduces attack by 30% (stacking)
                    multiplier = Math.max(0.1, 1.0 - (spiesNearby * 0.3)); // Minimum 10% damage
                }
                
                // Cache the result for this frame
                if (typeof sim !== 'undefined' && sim.frame !== undefined) {
                    this._spyWeaknessCache = multiplier;
                    this._spyWeaknessCacheFrame = sim.frame;
                }
                
                return multiplier;
            }
            
            getBondedGroup() {
                // SUPERAGENTS: No partners, just return self (no expensive traversal)
                if (this.isSuperAgent) {
                    return [this];
                }
                
                // PERFORMANCE: Limit traversal depth and group size for large connected groups
                const MAX_GROUP_SIZE = 50; // Cap group size to prevent expensive traversals
                const MAX_DEPTH = 10; // Limit recursion depth
                
                let group = new Set([this]);
                let toCheck = [...this.partners];
                let checked = new Set([this]);
                let depth = 0;
                
                while (toCheck.length > 0 && group.size < MAX_GROUP_SIZE && depth < MAX_DEPTH) {
                    let agent = toCheck.pop();
                    if (!agent || agent.dead || checked.has(agent)) continue;
                    
                    checked.add(agent);
                    group.add(agent);
                    
                    // Stop if we've hit the size limit
                    if (group.size >= MAX_GROUP_SIZE) break;
                    
                    // Add this agent's partners to check (only if not too deep)
                    if (depth < MAX_DEPTH - 1) {
                        for (let partner of agent.partners) {
                            if (!checked.has(partner) && group.size < MAX_GROUP_SIZE) {
                                toCheck.push(partner);
                            }
                        }
                    }
                    depth++;
                }
                
                return Array.from(group);
            }

            invalidateGroupCache() {
                // Invalidate cached bonded group
                this._cachedBondedGroup = null;
                this._cachedBondedGroupFrame = undefined;
            }

            getCachedBondedGroup() {
                // SUPERAGENTS: No partners, just return self (no expensive traversal)
                if (this.isSuperAgent) {
                    return [this];
                }
                
                // PERFORMANCE: Cache group for a few frames to avoid expensive recursive traversal
                if (typeof sim !== 'undefined') {
                    let cacheInterval = 5; // Cache for 5 frames
                    if (this._cachedBondedGroup && this._cachedBondedGroupFrame !== undefined) {
                        let framesSinceCache = sim.frame - this._cachedBondedGroupFrame;
                        if (framesSinceCache < cacheInterval) {
                            // Validate cache - remove dead agents
                            this._cachedBondedGroup = this._cachedBondedGroup.filter(a => a && !a.dead);
                            return this._cachedBondedGroup;
                        }
                    }
                    
                    // Recalculate and cache
                    let group = this.getBondedGroup();
                    this._cachedBondedGroup = group;
                    this._cachedBondedGroupFrame = sim.frame;
                    return group;
                }
                
                return this.getBondedGroup();
            }
            
            getGroupSynergies() {
                // SUPERAGENTS: Return stored synergies (already calculated at creation)
                if (this.isSuperAgent) {
                    return {
                        size: this.originalGroupSize || 1,
                        multipliers: this.superAgentMultipliers || {},
                        capabilities: this.superAgentCapabilities || []
                    };
                }
                
                // Calculate emergent abilities from bonded group composition
                // Returns object with bonus multipliers and new capabilities
                
                let group = this.getBondedGroup();
                if (group.length <= 1) {
                    return { size: 1, multipliers: {}, capabilities: [] };
                }
                
                // Collect group DNA and roles
                let dnaAverages = {};
                let dnaVariances = {};
                let roles = {};
                let totalHealth = 0;
                let totalEnergy = 0;
                
                // Calculate averages
                for (let agent of group) {
                    if (agent.dead) continue;
                    
                    for (let gene in agent.dna) {
                        if (typeof agent.dna[gene] === 'number') {
                            dnaAverages[gene] = (dnaAverages[gene] || 0) + agent.dna[gene];
                        }
                    }
                    
                    roles[agent.role] = (roles[agent.role] || 0) + 1;
                    totalHealth += agent.health / agent.maxHealth;
                    totalEnergy += agent.energy / agent.maxEnergy;
                }
                
                let activeCount = group.filter(a => !a.dead).length;
                for (let gene in dnaAverages) {
                    dnaAverages[gene] /= activeCount;
                }
                
                // Calculate variances (diversity bonus)
                for (let agent of group) {
                    if (agent.dead) continue;
                    for (let gene in dnaAverages) {
                        let diff = agent.dna[gene] - dnaAverages[gene];
                        dnaVariances[gene] = (dnaVariances[gene] || 0) + diff * diff;
                    }
                }
                for (let gene in dnaVariances) {
                    dnaVariances[gene] = Math.sqrt(dnaVariances[gene] / activeCount);
                }
                
                // EMERGENT BONUSES (not hard-coded, calculated from composition)
                let synergies = {
                    size: activeCount,
                    multipliers: {},
                    capabilities: []
                };
                
                // 1. RESOURCE SYNERGY: High average botany/manufacturing + diversity = better harvesting
                if (dnaAverages.botany && dnaAverages.manufacturing) {
                    let resourcePower = (dnaAverages.botany + dnaAverages.manufacturing) / 2;
                    let diversityBonus = 1 + (dnaVariances.botany || 0) * 0.5;
                    synergies.multipliers.resourceHarvest = 1 + (resourcePower * diversityBonus * 0.4);
                    if (synergies.multipliers.resourceHarvest > 1.15) synergies.capabilities.push('efficient_harvesting');
                }
                
                // 2. COMBAT SYNERGY: High aggression + defense + variance = better fighting
                if (dnaAverages.aggression && dnaAverages.defense) {
                    let combatPower = (dnaAverages.aggression + dnaAverages.defense) / 2;
                    let tacticDiversity = (dnaVariances.aggression || 0) + (dnaVariances.defense || 0);
                    synergies.multipliers.combatEffectiveness = 1 + (combatPower * (1 + tacticDiversity) * 0.3);
                    if (synergies.multipliers.combatEffectiveness > 1.2) synergies.capabilities.push('pack_tactics');
                }
                
                // 3. MOBILITY SYNERGY: High speed + coordinated movement = faster group
                if (dnaAverages.speed) {
                    let mobilityBonus = dnaAverages.speed;
                    let coordination = 1 - Math.min(0.5, (dnaVariances.speed || 0)); // Low variance = better coordination
                    synergies.multipliers.movementSpeed = 1 + (mobilityBonus * coordination * 0.25);
                    if (synergies.multipliers.movementSpeed > 1.12) synergies.capabilities.push('swift_formation');
                }
                
                // 4. INTELLIGENCE SYNERGY: High intelligence + education variance = problem solving
                if (dnaAverages.intelligence && dnaVariances.intelligence) {
                    let thinkPower = dnaAverages.intelligence;
                    let creativity = dnaVariances.intelligence;
                    synergies.multipliers.resourceConversion = 1 + (thinkPower * (1 + creativity) * 0.35);
                    if (synergies.multipliers.resourceConversion > 1.15) synergies.capabilities.push('innovative_crafting');
                }
                
                // 5. SOCIAL SYNERGY: High social/altruism = better cooperation
                if (dnaAverages.social && dnaAverages.altruism) {
                    let socialPower = (dnaAverages.social + dnaAverages.altruism) / 2;
                    synergies.multipliers.energySharing = 1 + (socialPower * 0.3);
                    synergies.multipliers.bondStrength = 1 + (socialPower * 0.2);
                    if (socialPower > 0.7) synergies.capabilities.push('communal_support');
                }
                
                // 6. ROLE SYNERGY: Specific role combinations unlock bonuses
                let roleCount = Object.keys(roles).length;
                if (roleCount >= 3) {
                    // Diverse roles = adaptability
                    synergies.multipliers.adaptability = 1 + (roleCount * 0.08);
                    synergies.capabilities.push('versatile_group');
                }
                
                // Builder + Miner = construction synergy
                if (roles.Builder && roles.Miner) {
                    synergies.multipliers.resourceConversion = (synergies.multipliers.resourceConversion || 1) * 1.3;
                    synergies.capabilities.push('construction_team');
                }
                
                // Soldier + Diplomat = strategic advantage
                if (roles.Soldier && roles.Diplomat) {
                    synergies.multipliers.combatEffectiveness = (synergies.multipliers.combatEffectiveness || 1) * 1.2;
                    synergies.capabilities.push('strategic_warfare');
                }
                
                // Merchant + Artisan = trade advantage
                if (roles.Merchant && roles.Artisan) {
                    synergies.multipliers.tradeValue = 1.4;
                    synergies.capabilities.push('master_traders');
                }
                
                // Scientist + Teacher = knowledge amplification
                if (roles.Scientist && roles.Teacher) {
                    synergies.multipliers.techGain = 1.5;
                    synergies.capabilities.push('research_institute');
                }
                
                // 7. HEALTH/ENERGY SYNERGY: Well-fed, healthy groups are more effective
                let groupVitality = (totalHealth + totalEnergy) / (2 * activeCount);
                if (groupVitality > 0.8) {
                    // Scale all multipliers by vitality
                    for (let key in synergies.multipliers) {
                        synergies.multipliers[key] *= (1 + (groupVitality - 0.8) * 0.5);
                    }
                }
                
                // 8. SIZE SCALING: Larger groups get diminishing returns but still benefit
                let sizeBonus = Math.min(1.3, 1 + Math.log(activeCount) * 0.15);
                for (let key in synergies.multipliers) {
                    synergies.multipliers[key] = (synergies.multipliers[key] || 1) * sizeBonus;
                }
                
                return synergies;
            }

            learnSkill(skill, level) {
                if (!this.skills) this.skills = {};
                if (this.skills[skill] < level) {
                    this.skills[skill] = level;
                    this.applySkills();
                    sim.particles.push(new Particle(this.pos.x, this.pos.y, '#ffffff'));
                }
            }

            applySkills() {
                this.maxSpeed = this.baseSpeed + ((this.skills && this.skills.SPEED || 0) * 0.3); 
                this.maxEnergy = 300 + ((this.skills && this.skills.ENERGY || 0) * 100);
                this.maxHealth = 100 + ((this.skills && this.skills.HEALTH || 0) * 50);
                this.senseRad = this.baseSense + ((this.skills && this.skills.SENSE || 0) * 50);
            }
            
            learn(key, amount) {
                this.prefs[key] += amount * CONFIG.learningRate;
                this.prefs[key] = Math.max(0.1, Math.min(3.0, this.prefs[key]));
            }

            adjustLoyalty(id, amount) {
                if (!this.loyalty[id]) this.loyalty[id] = 0;
                this.loyalty[id] += amount;
                if (this.loyalty[id] > 100) this.loyalty[id] = 100;
                if (this.loyalty[id] < -100) this.loyalty[id] = -100;
            }

            getNetLoyalty(other) {
                if (!other) return 0; 
                if (this.kin.includes(other.id)) return 100;
                let personal = this.loyalty[other.id] || 0;
                if (this.tribeId !== -1 && other.tribeId !== -1 && sim.tribes) {
                    let tribal = sim.tribes.getOpinion(this.tribeId, other.tribeId);
                    return personal + tribal;
                }
                return personal;
            }

            resolveCollisions(resources) {
                // Nests are solid
                for(let n of sim.tribes.nests) {
                    if (Vector.dist(this.pos, n.pos) < n.radius + this.radius) {
                        let push = Vector.sub(this.pos, n.pos).normalize().mult(0.5);
                        this.pos.add(push);
                    }
                }
                for (let r of resources) {
                    if (r.type === 'MAT' || r.type === 'ORE') {
                        if (!r.carrier && r.active) {
                            let d = Vector.dist(this.pos, r.pos);
                            let minD = this.radius + r.config.radius;
                            if (d < minD) {
                                if (this.stuckCounter > 5) {
                                    r.active = false;
                                    sim.particles.push(new Particle(r.pos.x, r.pos.y, '#facc15'));
                                    this.energy += 10;
                                    if (this.energy > this.maxEnergy) this.energy = this.maxEnergy;
                                } else {
                                    let push = Vector.sub(this.pos, r.pos).normalize().mult(minD - d);
                                    this.pos.add(push);
                                }
                            }
                        }
                    } else if (r.type === 'BLOCK') {
                        // Blocks are solid obstacles that block movement
                        if (!r.active || r.life <= 0) continue; // Skip inactive or decayed blocks
                        
                        // SCIENTIST WEAKNESS: Scientists weaken all enemy blocks by 50%
                        let blockLifeMultiplier = 1.0;
                        if (this.tribeId !== -1 && r.creatorTribe !== -1 && r.creatorTribe !== this.tribeId) {
                            // This is an enemy block - check for scientists nearby
                            // PERFORMANCE: Use spatial grid to find scientists near the block
                            let scientistsNearby = 0;
                            if (typeof sim !== 'undefined' && sim.spatialGrid && sim.gridCols > 0) {
                                let nearby = sim.getNearbyEntities(r.pos.x, r.pos.y, 150);
                                scientistsNearby = nearby.agents.filter(a => 
                                    a.role === 'Scientist' && 
                                    a.tribeId === this.tribeId && 
                                    !a.dead
                                ).length;
                            } else if (typeof sim !== 'undefined' && sim.agents) {
                                // Fallback: filter only if spatial grid not available
                                scientistsNearby = sim.agents.filter(a => 
                                    a.role === 'Scientist' && 
                                    a.tribeId === this.tribeId && 
                                    !a.dead &&
                                    Vector.dist(a.pos, r.pos) < 150
                                ).length;
                            }
                            if (scientistsNearby > 0) {
                                blockLifeMultiplier = 0.5; // Blocks are 50% weaker (take 2x damage)
                            }
                        }
                        
                        // BLOCKS: All agents can move through blocks (removed collision logic for performance)
                        
                        // BLOCK ATTACK: Agents can attack enemy blocks
                        if (this.tribeId !== -1 && r.creatorTribe !== -1 && r.creatorTribe !== this.tribeId) {
                            // This is an enemy block
                            let d = Vector.dist(this.pos, r.pos);
                            if (d < this.radius + r.config.radius + 5) {
                                // Agent is touching the block - attack it
                                let damage = 0.25; // Base damage (reduced by 75% = 1/4 of original)
                                
                                // Builders, Soldiers, Raiders have much stronger effect
                                if (this.role === 'Builder' || this.role === 'Soldier' || this.role === 'Raider') {
                                    damage = 1.25; // Reduced by 75% (was 5, now 1.25 = 1/4 of original)
                                }
                                
                                // Apply scientist weakness multiplier
                                damage = Math.ceil(damage / blockLifeMultiplier);
                                // Ensure minimum damage of 1 per frame (round up)
                                if (damage < 1) damage = 1;
                                
                                // Damage the block
                                r.life -= damage;
                                
                                // Visual feedback
                                if (Math.random() < 0.1) { // 10% chance for particles
                                    sim.particles.push(new Particle(r.pos.x, r.pos.y, '#78716c', 'spark')); // Gray particles
                                }
                                
                                // Block is destroyed if life reaches 0
                                if (r.life <= 0) {
                                    r.active = false;
                                    sim.particles.push(new Particle(r.pos.x, r.pos.y, '#57534e', 'spark')); // Dark gray explosion
                                }
                            }
                        }
                    }
                }
            }

            update(resources, agents, doExpensiveOps = true) {
                if (this.dead) return;
                
                // Initialize combat/mating state tracking if not already set
                if (this.inCombat === undefined) this.inCombat = false;
                if (this.isMating === undefined) this.isMating = false;
                if (this.lastCombatFrame === undefined) this.lastCombatFrame = 0;
                if (this.lastMatingFrame === undefined) this.lastMatingFrame = 0;
                
                // Play battle sounds every 150 frames during combat (MUCH LOWER VOLUME, LESS GRATING SOUND)
                // STRICT GLOBAL THROTTLE: Only ONE battle sound can play per frame globally to prevent buzzing
                if (this.inCombat && typeof sim !== 'undefined' && sim.frame) {
                    let framesSinceCombat = sim.frame - this.lastCombatFrame;
                    if (framesSinceCombat <= 300) { // Combat state lasts 300 frames (2 sound plays)
                        // Play sound every 150 frames (150, 300) - but only if no other battle sound this frame or recently
                        if (framesSinceCombat % 150 === 0 && framesSinceCombat > 0) {
                            let framesSinceLastBattleSound = sim.frame - soundThrottle.lastBattleSoundFrame;
                            // STRICT: Must pass cooldown AND no other battle sound played this frame
                            if (framesSinceLastBattleSound >= soundThrottle.battleSoundCooldown && !soundThrottle.battleSoundPlayedThisFrame) {
                                // Use low static buzz for battle
                                let battleFreq = HARMONICS.A3; // Low A (220 Hz) - base frequency for static
                                // TEMPORARILY DISABLED FOR TESTING
                                // sfx.play('static', battleFreq, 0.015); // Low static buzz - louder so it's audible
                                soundThrottle.lastBattleSoundFrame = sim.frame; // Update global throttle
                                soundThrottle.battleSoundPlayedThisFrame = true; // Mark as played this frame
                            }
                        }
                    } else {
                        this.inCombat = false; // Clear combat state after 300 frames
                    }
                }
                
                // Mating state tracking (sound removed)
                if (this.isMating && typeof sim !== 'undefined' && sim.frame) {
                    let framesSinceMating = sim.frame - this.lastMatingFrame;
                    if (framesSinceMating > 300) {
                        this.isMating = false; // Clear mating state after 300 frames
                    }
                }
                
                // Babies grow faster based on babyGrowthRate
                // TEACHER BOOST: Check if teachers are present in nest to double baby growth rate
                let babyGrowthRate = CONFIG.babyGrowthRate;
                if (!this.isAdult() && this.tribeId !== -1) {
                    let myNest = sim.tribes.nests.find(n => n.tribeId === this.tribeId);
                    if (myNest) {
                        let distToNest = Vector.dist(this.pos, myNest.pos);
                        // Check if baby is inside nest
                        if (distToNest < myNest.radius) {
                            // Check for teachers inside the nest
                            // PERFORMANCE: Use spatial grid to find teachers near the nest
                            let teachersInNest = [];
                            if (typeof sim !== 'undefined' && sim.spatialGrid && sim.gridCols > 0) {
                                let nearby = sim.getNearbyEntities(myNest.pos.x, myNest.pos.y, myNest.radius);
                                teachersInNest = nearby.agents.filter(a => 
                                    a.role === 'Teacher' && 
                                    a.tribeId === this.tribeId && 
                                    !a.dead
                                );
                            } else if (typeof sim !== 'undefined' && sim.agents) {
                                // Fallback: filter only if spatial grid not available
                                teachersInNest = sim.agents.filter(a => 
                                    a.role === 'Teacher' && 
                                    a.tribeId === this.tribeId && 
                                    !a.dead &&
                                    Vector.dist(a.pos, myNest.pos) < myNest.radius
                                );
                            }
                            if (teachersInNest.length > 0) {
                                babyGrowthRate *= 2.0; // Double growth rate when teachers are present
                            }
                        }
                    }
                }
                
                if (!this.isAdult()) {
                    this.age += babyGrowthRate;
                } else {
                this.age++;
                }
                
                if (this.mateCooldown > 0) this.mateCooldown--;
                
                // Health-based death rate: healthier agents live longer
                // Calculate health ratio (0.0 to 1.0)
                let healthRatio = this.health / this.maxHealth;
                
                // Death rate multiplier based on health:
                // - Very healthy (>80%): death rate is 20% of normal (lifespan decreases 80% slower)
                // - Healthy (>60%): death rate is 40% of normal
                // - Moderate (>40%): death rate is 70% of normal
                // - Unhealthy (‚â§40%): death rate is 100% of normal (full death rate)
                let deathRateMult = 1.0;
                if (healthRatio > 0.8) {
                    deathRateMult = 0.2; // Very healthy: 80% slower death
                } else if (healthRatio > 0.6) {
                    deathRateMult = 0.4; // Healthy: 60% slower death
                } else if (healthRatio > 0.4) {
                    deathRateMult = 0.7; // Moderate: 30% slower death
                }
                // else deathRateMult = 1.0 (unhealthy: normal death rate)
                
                // BONDED AGENTS LIVE 10X LONGER: Reduce death rate to 1/10 for bonded agents
                // This means bonded agents age 10x slower, effectively living 10x longer
                // Check if agent is bonded (has partners)
                let isBonded = this.partners && this.partners.length > 0;
                if (isBonded) {
                    deathRateMult *= (1.0 / 10.0); // Bonded agents: 1/10 death rate = 10x lifespan
                }
                
                // FOOD CHAIN MEMBERS LIVE 2X LONGER: Reduce death rate by 50% for grazers, prey, and predators
                // This means food chain members age 50% slower, effectively living 2x longer
                if (this.isGrazer || this.isPrey || this.isPredator) {
                    deathRateMult *= 0.5; // Food chain members: 50% death rate = 2x lifespan
                }
                
                // TRIBE-BASED LIFESPAN BONUSES
                if (this.tribeId !== -1 && typeof sim !== 'undefined' && sim.agents && sim.tribes) {
                    let tribe = sim.tribes.tribes[this.tribeId];
                    if (tribe) {
                        // PERFORMANCE: Update tribe composition cache every 60 frames
                        if (!tribe._compositionCache || sim.frame - tribe._compositionCache.lastUpdateFrame > 60) {
                            // Update composition cache
                            let tribeMembers = sim.agents.filter(a => a.tribeId === this.tribeId && !a.dead);
                            tribe._compositionCache = {
                                hasArtisans: tribeMembers.some(a => a.role === 'Artisan' && !a.dead),
                                hasScientists: tribeMembers.some(a => a.role === 'Scientist' && !a.dead),
                                hasTechnologists: tribeMembers.some(a => a.role === 'Technologist' && !a.dead),
                                hasTeachers: tribeMembers.some(a => a.role === 'Teacher' && !a.dead),
                                lastUpdateFrame: sim.frame
                            };
                        }
                        
                        // SCIENTISTS/TECHNOLOGISTS/TEACHERS BONUS: If tribe has any of these, all scientists/technologists/teachers live 3X longer
                        if (this.role === 'Scientist' || this.role === 'Technologist' || this.role === 'Teacher') {
                            let hasIntellectuals = tribe._compositionCache.hasScientists || 
                                                   tribe._compositionCache.hasTechnologists || 
                                                   tribe._compositionCache.hasTeachers;
                            if (hasIntellectuals) {
                                deathRateMult *= (1.0 / 3.0); // 1/3 death rate = 3x lifespan
                            }
                        }
                        
                        // ARTISAN BONUS: If tribe has artisans, everyone gets 20% longevity and charisma boost
                        if (tribe._compositionCache.hasArtisans) {
                            deathRateMult *= 0.8; // 20% reduction in death rate = 20% longer lifespan
                            // Charisma boost applied below (after death rate calculation)
                        }
                    }
                }
                
                // Apply health-based death rate: only decrement lifespan probabilistically
                // Healthier agents have a lower chance of aging each frame
                if (Math.random() < deathRateMult) {
                this.lifespan--;
                }
                
                // ARTISAN CHARISMA BONUS: Apply 20% charisma boost if tribe has artisans
                // Track base charisma (before multiplier) and apply 1.2x multiplier when artisans present
                if (this.tribeId !== -1 && typeof sim !== 'undefined' && sim.tribes) {
                    let tribe = sim.tribes.tribes[this.tribeId];
                    if (tribe && tribe._compositionCache) {
                        // Initialize base charisma tracking
                        if (this._baseCharisma === undefined) {
                            this._baseCharisma = this.charisma || 0;
                        }
                        
                        if (tribe._compositionCache.hasArtisans) {
                            // Apply 20% boost: effective charisma = base * 1.2
                            this.charisma = this._baseCharisma * 1.2;
                        } else {
                            // No artisans - use base charisma
                            this.charisma = this._baseCharisma;
                        }
                    }
                }
                
                if (this.age >= CONFIG.adultAge && this.age - CONFIG.babyGrowthRate < CONFIG.adultAge) {
                    this.breakAllBonds();
                    sim.particles.push(new Particle(this.pos.x, this.pos.y, '#ffffff'));
                }

                // Bond snapping - rigid bonds are harder to break
                if (this.partners.length > 0) {
                     let luckyIndex = Math.floor(Math.random() * this.partners.length);
                     let p = this.partners[luckyIndex];
                     let rigidType = (this.rigidBonds && this.rigidBonds[p.id]) || null;
                     let breakRate = CONFIG.bondBreakRate;
                     if (rigidType) {
                         // Rigid bonds break much slower
                         breakRate *= (1.0 - CONFIG.rigidBondBreakResistance);
                     }
                     if (Math.random() < breakRate) {
                     this.removePartner(p);
                     p.removePartner(this);
                     }
                }
                
                // Tribal conversion through bonded groups
                if (this.partners.length > 0 && this.age % 100 === 0 && this.tribeId !== -1 && this.role !== 'Monster') {
                    // Count tribes in bonded group
                    let tribeCounts = {};
                    let totalBonded = 0;
                    
                    // PERFORMANCE: Limit partner iteration for large groups
                    let maxPartnersToCheck = 50;
                    let partnersToCheck = this.partners.length > maxPartnersToCheck 
                        ? this.partners.slice(0, maxPartnersToCheck) 
                        : this.partners;
                    
                    partnersToCheck.forEach(p => {
                        if (!p || p.dead || p.tribeId === -1 || p.role === 'Monster') return;
                        tribeCounts[p.tribeId] = (tribeCounts[p.tribeId] || 0) + 1;
                        totalBonded++;
                    });
                    
                    // Find majority tribe
                    let majorityTribe = null;
                    let maxCount = 0;
                    for (let tid in tribeCounts) {
                        if (tribeCounts[tid] > maxCount) {
                            maxCount = tribeCounts[tid];
                            majorityTribe = parseInt(tid);
                        }
                    }
                    
                    // Convert if majority is different tribe and represents >50% of bonded group
                    if (majorityTribe !== null && majorityTribe !== this.tribeId && maxCount > totalBonded / 2) {
                        // Small chance to convert based on group pressure
                        if (Math.random() < 0.1) {
                            this.tribeId = majorityTribe;
                            if (sim.tribes.tribes[majorityTribe]) {
                                this.color = sim.tribes.tribes[majorityTribe].color;
                                sim.particles.push(new Particle(this.pos.x, this.pos.y, this.color, 'spark'));
                            }
                        }
                    }
                }

                if (this.lifespan <= 0 && this.role !== 'Monster') {
                    this.dead = true;
                    this.breakAllBonds();
                    return;
                }

                if (Vector.dist(this.pos, this.lastPos) < 1.0) this.stuckCounter++;
                else this.stuckCounter = 0;
                this.lastPos = this.pos.copy();

                if (this.carrying) {
                    if (!this.carrying.active) this.carrying = null; 
                    else {
                        this.carrying.pos.x = this.pos.x;
                        this.carrying.pos.y = this.pos.y - this.radius - 5; 
                    }
                }

                // Resource Sharing & Child Feeding
                if (this.partners.length > 0 && this.age % 10 === 0) {
                    // PERFORMANCE: Limit partner iteration for large groups
                    let maxPartnersForEnergy = 30;
                    let partnersForEnergy = this.partners.length > maxPartnersForEnergy 
                        ? this.partners.slice(0, maxPartnersForEnergy) 
                        : this.partners;
                    
                    partnersForEnergy.forEach(p => {
                        if (!p || p.dead) return;
                        if (this.isAdult() && !p.isAdult() && this.energy > 50) {
                            let flow = 5;
                            this.energy -= flow;
                            p.energy += flow;
                        } else if (this.energy > p.energy) {
                            let flow = (this.energy - p.energy) * 0.05; 
                            this.energy -= flow;
                            p.energy += flow;
                        }
                    });
                }
                
                // WELFARE SYSTEM
                let myNest = sim.tribes.nests.find(n => n.tribeId === this.tribeId);
                if (this.energy < 50 && myNest && Vector.dist(this.pos, myNest.pos) < 150 && myNest.wealth > 5) {
                     // Welfare check (MUCH CHEAPER!)
                     this.energy += 20;
                     myNest.wealth -= 0.1; // Reduced from 1 to 0.1 (90% cost reduction!)
                     this.state = "On Welfare";
                }

                if (!this.isAdult()) {
                    // Check if agent is inside nest - if so, energy decays 1.5x slower
                    let energyDecay = this.isInsideNest() ? 0.05 / 1.5 : 0.05; // 1.5x slower inside nest
                    this.energy -= energyDecay; 
                }
                
                // General energy decay for all agents - 1.5x slower inside nest
                // (This handles passive energy decay that might occur elsewhere)
                if (this.energy > 0 && Math.random() < 0.01) { // Small chance for passive decay
                    let energyDecay = this.isInsideNest() ? 0.1 / 1.5 : 0.1; // 1.5x slower inside nest
                    this.energy -= energyDecay;
                }
                
                // Exile Logic
                if (this.tribeId !== -1 && sim.tribes.tribes[this.tribeId] && sim.tribes.tribes[this.tribeId].leaderId) {
                     let leaderId = sim.tribes.tribes[this.tribeId].leaderId;
                     if (this.loyalty[leaderId] < -50) {
                         this.tribeId = -1; // Exile
                         this.color = "#555"; // Grey
                     }
                }
                
                // UNAFFILIATED AGENTS JOIN WEALTHY TRIBES - Weighted chance to join top 3 wealthiest tribes
                // Only applies to unaffiliated agents (exiled, not monsters)
                if (this.tribeId === -1 && this.role !== 'Monster' && typeof sim !== 'undefined' && sim.tribes && sim.tribes.nests) {
                    // Check periodically (every 200 frames to avoid performance issues)
                    if (sim.frame % 200 === 0 && Math.random() < 0.15) { // 15% chance per check
                        // Get all tribes with their nest wealth
                        let tribeWealths = [];
                        for (let tid in sim.tribes.tribes) {
                            let tribeId = parseInt(tid);
                            let nest = sim.tribes.nests.find(n => n.tribeId === tribeId && n.hp > 0);
                            if (nest) {
                                tribeWealths.push({
                                    tribeId: tribeId,
                                    wealth: nest.wealth,
                                    nest: nest
                                });
                            }
                        }
                        
                        // Sort by wealth (descending) and get top 3
                        tribeWealths.sort((a, b) => b.wealth - a.wealth);
                        let top3Tribes = tribeWealths.slice(0, 3);
                        
                        if (top3Tribes.length > 0) {
                            // Calculate weights based on wealth (wealthier = higher chance)
                            let totalWealth = top3Tribes.reduce((sum, t) => sum + t.wealth, 0);
                            
                            if (totalWealth > 0) {
                                // Weighted random selection
                                let random = Math.random() * totalWealth;
                                let cumulative = 0;
                                let selectedTribe = null;
                                
                                for (let tribe of top3Tribes) {
                                    cumulative += tribe.wealth;
                                    if (random <= cumulative) {
                                        selectedTribe = tribe;
                                        break;
                                    }
                                }
                                
                                // Fallback to first if somehow none selected
                                if (!selectedTribe) selectedTribe = top3Tribes[0];
                                
                                // Join the selected wealthy tribe
                                this.tribeId = selectedTribe.tribeId;
                                this.assignColor(); // Update color based on role
                                
                                // VFX for joining a tribe
                                sim.particles.push(new Particle(this.pos.x, this.pos.y, '#3b82f6', 'star'));
                            }
                        }
                     }
                }

                if (this.role !== 'Monster') {
                    let growthFactor = 0.7 + (this.energy / this.maxEnergy) * 0.8;
                    if (!this.isAdult()) growthFactor *= 0.6; 
                    if(this.role === 'Monster') {
                         growthFactor += (this.partners.length * 0.5); 
                    }
                    if (this.isHero) growthFactor *= 1.2;
                    growthFactor = Math.min(2.5, growthFactor); 
                    this.radius = this.baseRadius * growthFactor;
                }

                // IMMORTALITY CHECK
                let isVIP = (this.role === 'Guardian' || (this.tribeId !== -1 && sim.tribes.tribes[this.tribeId] && sim.tribes.tribes[this.tribeId].leaderId === this.id));
                
                if (isVIP && myNest && myNest.wealth > 0) {
                    if (this.energy < 50) { this.energy += 50; myNest.wealth = Math.max(0, myNest.wealth - 1); }
                    if (this.health < 50) { this.health += 50; myNest.wealth = Math.max(0, myNest.wealth - 1); }
                    this.lifespan = this.maxLifespan; // Reset age timer
                }

                if (this.disease > 0) {
                    this.disease--;
                    this.energy -= 0.2; 
                    this.maxSpeed = this.baseSpeed * 0.5; 
                    if (this.disease % 20 === 0) sim.particles.push(new Particle(this.pos.x, this.pos.y, '#22c55e'));
                } else {
                    this.maxSpeed = this.baseSpeed + ((this.skills && this.skills.SPEED || 0) * 0.3); 
                }

                if (this.immunity > 0) {
                    this.immunity--; 
                    if (this.disease > 0) this.disease = 0; 
                }

                if (this.role === 'Scientist') {
                    this.researchPoints += CONFIG.researchSpeed;
                    // Scientists also generate tech points for their tribe
                    if (typeof sim !== 'undefined' && sim.tribes && this.tribeId !== -1 && Math.random() < 0.1) {
                        sim.tribes.progressTech(this.tribeId, 'science', 1);
                    }
                    if (this.researchPoints > 100) {
                        this.researchPoints = 0;
                        const skillKeys = Object.keys(this.skills);
                        const learned = skillKeys[Math.floor(Math.random() * skillKeys.length)];
                        if (!this.skills) this.skills = {};
                        this.learnSkill(learned, (this.skills[learned] || 0) + 1);
                        sim.particles.push(new Particle(this.pos.x, this.pos.y, '#60a5fa')); 
                    }
                }

                if (this.skills && this.skills.HEALTH > 0 && this.health < this.maxHealth) {
                    let groupBenefits = this.getGroupBenefits();
                    this.health += 0.05 * this.skills.HEALTH * groupBenefits.healingBonus;
                }

                // BOTANIST BEHAVIOR - Find food areas and grow more food
                if (this.role === 'Botanist') {
                    this.energy += 0.1; // Botanists are energy efficient
                    
                    // Fertilize nearby food resources (extend their life)
                    if (Math.random() < CONFIG.botanistFertilizeRate) {
                    let nearbyFood = resources.filter(r => 
                            r.type === 'FOOD' && 
                        Vector.dist(this.pos, r.pos) < CONFIG.botanistFertilizeRadius
                    );
                    nearbyFood.forEach(r => {
                        if (r.life < r.maxLife) {
                            r.life = Math.min(r.maxLife, r.life + 50); // Restore life
                        }
                    });
                    }
                    
                    // When near food areas, plant more food
                    let nearbyFoodCount = resources.filter(r => 
                        r.type === 'FOOD' && 
                        r.active &&
                        Vector.dist(this.pos, r.pos) < 80
                    ).length;
                    
                    // If in a food-rich area and have energy, grow more food
                    if (nearbyFoodCount >= 2 && this.energy > 50 && Math.random() < 0.03) {
                        // Plant new food near existing food
                        let plantX = this.pos.x + (Math.random() * 60 - 30);
                        let plantY = this.pos.y + (Math.random() * 60 - 30);
                        sim.spawnResource(null, plantX, plantY, 'FOOD', false, this.tribeId);
                        this.energy -= 20;
                        sim.particles.push(new Particle(this.pos.x, this.pos.y, '#4ade80', 'leaf'));
                        this.state = "Growing Food";
                    }
                }
                
                if (this.role === 'Healer') {
                    let groupBenefits = this.getGroupBenefits();
                    if (this.health < this.maxHealth) this.health += 0.2 * groupBenefits.healingBonus;
                }

                let load = 0;
                if (this.carrying) {
                    load = 0.05; 
                    if (this.role === 'Builder' && this.carrying.type === 'MAT') load = 0;
                    if (this.role === 'Scout' && this.carrying.type === 'FOOD') load = 0;
                    if (this.role === 'Merchant') load = 0; 
                    if (this.role === 'Miner' && this.carrying.type === 'ORE') load = 0.1; 
                }

                let groupBenefits = this.getGroupBenefits();
                let structureBandFactor = this.structureBandActive ? CONFIG.structureStabilityBandBonus : 1;
                let structureBonus = 1 + Math.min(2, this.structureStability / 200) * structureBandFactor;
                let cost = (CONFIG.energyBurnRate + (this.dna.speed * 0.04) + (this.radius * 0.02) + load) * groupBenefits.energyMultiplier;
                cost *= 1 - Math.min(0.4, this.structureStability * 0.0006 * structureBandFactor); // reduce cost as structure stabilizes
                
                // WAR COST MULTIPLIER - 80% increase per war (additive costs for multiple wars)
                if (this.tribeId !== -1 && typeof sim !== 'undefined' && sim.tribes) {
                    let tribe = sim.tribes.tribes[this.tribeId];
                    if (tribe && tribe.atWarWith) {
                        // Count how many wars the tribe is actively engaged in
                        let warCount = 0;
                        for (let otherId in tribe.atWarWith) {
                            if (tribe.atWarWith[otherId] === true) {
                                warCount++;
                            }
                        }
                        // War costs are additive: 80% per war (1 war = 1.8x, 2 wars = 2.6x, 3 wars = 3.4x, etc.)
                        if (warCount > 0) {
                            cost *= (1.0 + (warCount * 0.8));
                        }
                    }
                }
                let rigidCount = this.getRigidBondCount();
                if (rigidCount > 0) {
                    cost *= 0.5;
                    if (!this.hasRigidLifespanBonus) {
                        this.maxLifespan = this.baseMaxLifespan * 1.5;
                        this.hasRigidLifespanBonus = true;
                    }
                } else if (this.hasRigidLifespanBonus) {
                    this.maxLifespan = this.baseMaxLifespan;
                    this.hasRigidLifespanBonus = false;
                }
                if (this.structureStability > 0) {
                    this.maxLifespan = Math.max(this.maxLifespan, this.baseMaxLifespan * structureBonus);
                    if (this.health < this.maxHealth) {
                        this.health += 0.02 * (structureBonus - 1) * structureBandFactor;
                    }
                }
                if (this.isGroupEntity) {
                    cost *= Math.max(0.1, CONFIG.groupAgentEnergyCostMult);
                    this.maxLifespan = Math.max(this.maxLifespan, this.baseMaxLifespan * CONFIG.groupAgentLifespanMult);
                }
                if (this.frenzyTimer > 0) { cost *= 2; this.frenzyTimer--; }
                // Garbage Collectors are very energy efficient
                if (this.role === 'Garbage Collector') cost *= 0.3; // 70% reduction
                // LEADERS: Do not consume energy or resources of tribe
                let isLeader = false;
                if (this.tribeId !== -1 && typeof sim !== 'undefined' && sim.tribes) {
                    isLeader = (sim.tribes.tribes[this.tribeId] && sim.tribes.tribes[this.tribeId].leaderId === this.id);
                }
                
                if (!isLeader) {
                    // Botanists and Farmers eat less food - more energy efficient
                    if (this.role === 'Botanist' || this.role === 'Farmer') cost *= 0.5; // 50% reduction - they need less food
                    // BUILDERS: Moderately energy efficient and can get energy from tribe wealth if needed
                    if (this.role === 'Builder') {
                        cost *= 0.7; // 30% reduction - builders are moderately efficient (reduced from 60% to prevent wealth inflation)
                        // Builders can get energy from tribe wealth only when very low (like soldiers and diplomats)
                        if (this.tribeId !== -1 && typeof sim !== 'undefined' && sim.tribes) {
                            let myNest = sim.tribes.nests.find(n => n.tribeId === this.tribeId);
                            // Only sustain when energy is critically low (< 30) and tribe can afford it
                            if (myNest && myNest.wealth > 10 && this.energy < 30) {
                                this.energy += 1; // Small energy boost
                                myNest.wealth -= 0.2; // Cost to tribe
                            }
                        }
                    }
                this.energy -= cost;
                } else {
                    // Leaders regenerate energy slowly (they don't consume tribe resources)
                    if (this.energy < this.maxEnergy) {
                        this.energy += 0.1; // Slow natural regeneration
                    }
                }
                if (this.energy > this.maxEnergy) this.energy = this.maxEnergy;

                if (this.energy > 150 && this.health < this.maxHealth && this.role !== 'Monster') {
                    this.energy -= 0.5; this.health += 0.5;
                }

                if (this.energy <= 0 || this.health <= 0) {
                    // Check if this is a nest leader before marking as dead
                    let wasLeader = false;
                    if (this.tribeId !== -1 && typeof sim !== 'undefined' && sim.tribes) {
                        wasLeader = sim.tribes.tribes[this.tribeId].leaderId === this.id;
                        
                        // If nest leader is killed, nest loses 30% of wealth immediately
                        if (wasLeader) {
                            let myNest = sim.tribes.nests.find(n => n.tribeId === this.tribeId);
                            if (myNest) {
                                let wealthLoss = myNest.wealth * 0.3;
                                myNest.wealth = Math.max(0, myNest.wealth - wealthLoss);
                                sim.setStatusMessage(`‚öîÔ∏è Leader of Tribe ${this.tribeId} killed! Nest lost ${Math.floor(wealthLoss)} wealth (30%)`, 300);
                                sim.particles.push(new Particle(myNest.pos.x, myNest.pos.y, '#dc2626', 'spark'));
                            }
                        }
                    }
                    
                    if (this.carrying) {
                        this.carrying.carrier = null; 
                        this.carrying = null;
                    }
                    this.dead = true;
                    this.breakAllBonds();
                    this.spawnDeathResource();
                    this.spawnDeathFoodBurst();
                    this.spawnGroupAgentBabies(sim);
                    sim.particles.push(new Particle(this.pos.x, this.pos.y, '#fff', 'skull'));
                    return;
                }

                this.interact(resources, agents, doExpensiveOps);
                this.attemptGroupAscension();
                
                // SUPERAGENTS: No expensive group calculations needed - abilities are baked in
                if (this.isSuperAgent) {
                    // SuperAgents are just regular agents with enhanced stats - no special processing needed
                    // All synergies and capabilities are already applied to their stats
                } else if (this.isGroupEntity) {
                    // PERFORMANCE OPTIMIZATION: Very aggressive throttling of expensive group entity operations
                    // Only do these expensive operations every 4-6 frames for group entities
                    let groupEntityCount = (typeof sim !== 'undefined' && sim.agents) ? 
                        sim.agents.filter(a => a.isGroupEntity).length : 0;
                    
                    let throttleInterval = 3; // Default: every 3 frames
                    if (groupEntityCount > 25) {
                        throttleInterval = 6; // Every 6 frames when many group entities
                    } else if (groupEntityCount > 15) {
                        throttleInterval = 4; // Every 4 frames when moderate group entities
                    }
                    
                    let groupEntityUpdateOffset = (typeof sim !== 'undefined' && sim.frame) ? sim.frame % throttleInterval : 0;
                    let agentUpdateOffset = (this.id ? this.id.charCodeAt(0) : 0) % throttleInterval;
                    
                    if (groupEntityUpdateOffset === agentUpdateOffset) {
                        this.cleanupConverterBonds(sim);
                        this.attemptSpawnConverterBonder(sim);
                        this.huntNearbyGroupResources(resources);
                        this.consumeNearbyEnemiesForEnergy(agents);
                    }
                }
                
                this.vel.add(this.acc);
                let speedLimit = this.maxSpeed * (groupBenefits.propulsionBoost || 1);
                if (this.carrying && load > 0) speedLimit *= 0.7; 
                if (this.frenzyTimer > 0) speedLimit *= 1.5;
                if (this.role === 'Monster') speedLimit *= 0.8; 
                
                this.vel.limit(speedLimit);
                this.pos.add(this.vel);
                // Wrap position on torus
                if (typeof sim !== 'undefined') {
                    this.pos.wrap(sim.width, sim.height);
                }
                
                this.resolveCollisions(resources);
                
                this.acc.mult(0);
                this.boundaries();
            }

            wander() {
                let wanderPoint = this.vel.copy();
                wanderPoint.normalize();
                wanderPoint.mult(50); 
                wanderPoint.add(this.pos);
                let wanderRadius = 30;
                
                // Apply movement gene biases (compass directions)
                let geneBias = new Vector(0, 0);
                geneBias.x += (this.dna.move_e - this.dna.move_w) * 0.3;
                geneBias.y += (this.dna.move_s - this.dna.move_n) * 0.3;
                geneBias.x += (this.dna.move_ne - this.dna.move_sw) * 0.21;
                geneBias.y += (this.dna.move_se - this.dna.move_nw) * 0.21;
                geneBias.x += (this.dna.move_se - this.dna.move_nw) * 0.21;
                geneBias.y -= (this.dna.move_ne - this.dna.move_sw) * 0.21;
                
                // WEIGHTED OSCILLATING MOVEMENT PATTERNS (prevents stasis)
                // Update oscillation phase based on cycle speed
                let cycleSpeed = Math.max(1, Math.floor(10 + this.dna.oscillate_cycle_speed * 90)); // 10-100 frames per step
                if (typeof sim !== 'undefined' && sim.frame % cycleSpeed === 0) {
                    this.oscillatePhase = (this.oscillatePhase + 1) % 8; // Cycle through 8 positions
                }
                
                // Get current direction from pattern (0-7 = N,NE,E,SE,S,SW,W,NW) with weight
                let patternDirection = this.dna.oscillate_pattern[this.oscillatePhase];
                let patternWeight = this.dna.oscillate_weights[this.oscillatePhase];
                let oscillateBias = new Vector(0, 0);
                
                // Convert direction to vector (0=N, 1=NE, 2=E, 3=SE, 4=S, 5=SW, 6=W, 7=NW)
                let angle = (patternDirection * Math.PI / 4) - Math.PI / 2; // -90¬∞ offset (N is up)
                oscillateBias.x = Math.cos(angle);
                oscillateBias.y = Math.sin(angle);
                // Apply weight, amplitude, and config strength (all reduced to prevent sticking)
                oscillateBias.mult(patternWeight * this.dna.oscillate_amplitude * CONFIG.oscillatingMovementStrength * 0.5);
                
                // Add drift component to prevent perfect cancellation (always moves slightly forward)
                let driftBias = this.vel.copy().normalize().mult(this.dna.movement_tendency * 0.3);
                
                geneBias.add(oscillateBias);
                geneBias.add(driftBias);
                
                let theta = this.wanderTheta + this.vel.heading();
                let x = wanderRadius * Math.cos(theta);
                let y = wanderRadius * Math.sin(theta);
                wanderPoint.add(new Vector(x, y));
                let steer = wanderPoint.sub(this.pos);
                steer.limit(this.maxForce);
                
                // Apply movement gene bias (scaled by movement_tendency to favor actual movement)
                steer.add(geneBias);
                steer.mult(this.dna.movement_tendency); // Agents with high tendency move more, low oscillate more
                steer.add(this.getMovementPatternBias(steer));
                
                let changeRate = 0.1 + (this.dna.twitch * 0.8);
                this.wanderTheta += (Math.random() - 0.5) * changeRate;
                
                // Curiosity Gene: Wanders further
                if (this.dna.curiosity > 0.7) steer.mult(1.2);

                return steer;
            }

            interact(resources, agents, doExpensiveOps = true) {
                if (this.isConverterUnit) {
                    this.converterInteract(resources);
                    return;
                }
                if (this.isConverterBonder) {
                    this.runConverterBonding(sim, agents);
                    return;
                }
                
                // BUILDERS: Don't return early here - builder logic runs later after forces are defined
                // The builder logic will handle everything and return early after applying forces
                
                let localRes = [];
                let localAgents = [];

                this.targetId = null;

                // PERFORMANCE OPTIMIZATION: Skip expensive operations for some agents to maintain smooth updates
                // Always do basic movement, but skip expensive group/combat calculations for some agents
                let effectiveSenseRad = this.senseRad;
                let myGroup = [];
                let myGroupStrength = 0;
                let inGroup = false;
                let combatRange = CONFIG.groupCombatRange || 220;
                let groupBenefits = {
                    rangeBonus: 1.0,
                    gatherRangeBonus: 1.0,
                    conversionBonus: 1.0,
                    healingBonus: 1.0,
                    energyMultiplier: 1.0,
                    propulsionBoost: 1.0
                };
                
                if (doExpensiveOps !== false) {
                // Apply group benefits and gather bond bonus to sensing range
                    groupBenefits = this.getGroupBenefits();
                    effectiveSenseRad = this.senseRad * groupBenefits.rangeBonus * this.gatherRangeBonus * groupBenefits.gatherRangeBonus;
                    
                    myGroup = this.getCachedBondedGroup();
                    myGroupStrength = this.getGroupStrength(myGroup);
                    inGroup = myGroup.length > 1;
                } else {
                    // Lightweight mode: use basic sense radius, no group calculations
                    effectiveSenseRad = this.senseRad * this.gatherRangeBonus;
                }
                
                // PERFORMANCE OPTIMIZATION: Use spatial grid for O(n) distance checks instead of O(n¬≤)
                // Reuse arrays to reduce allocations
                localRes.length = 0;
                localAgents.length = 0;
                if (typeof sim !== 'undefined' && sim.spatialGrid && sim.gridCols > 0) {
                    let nearby = sim.getNearbyEntities(this.pos.x, this.pos.y, effectiveSenseRad);
                    // Reuse arrays instead of creating new ones
                    for (let r of nearby.resources) localRes.push(r);
                    for (let a of nearby.agents) if (a !== this) localAgents.push(a);
                } else {
                    // Fallback to brute force if spatial grid not available
                for (let r of resources) if (Vector.dist(this.pos, r.pos) < effectiveSenseRad) localRes.push(r);
                for (let a of agents) if (a !== this && Vector.dist(this.pos, a.pos) < effectiveSenseRad) localAgents.push(a);
                }

                let forces = {
                    base: new Vector(0,0),
                    food: new Vector(0,0),
                    hunt: new Vector(0,0),
                    flee: new Vector(0,0),
                    social: new Vector(0,0),
                    wander: new Vector(0,0),
                    mine: new Vector(0,0),
                    raid: new Vector(0,0),
                    trade: new Vector(0,0),
                    bond: new Vector(0,0),
                    war: new Vector(0,0) 
                };

                // Nest Logic - Get nest reference early (needed for builder logic)
                let myNest = sim.tribes.nests.find(n => n.tribeId === this.tribeId);
                let distToNest = myNest ? Vector.dist(this.pos, myNest.pos) : Infinity;
                
                // Declare active variable before builder logic uses it
                let active = false;
                
                // BUILDER LOGIC - Must run FIRST before any other force-setting code
                // Builders stay near nest and build, never wander or interact with agents
                if (this.role === 'Builder' && myNest) {
                    // CRITICAL: Clear ALL forces first
                    forces.base = new Vector(0, 0);
                    forces.food = new Vector(0, 0);
                    forces.mine = new Vector(0, 0);
                    forces.hunt = new Vector(0, 0);
                    forces.flee = new Vector(0, 0);
                    forces.social = new Vector(0, 0);
                    forces.wander = new Vector(0, 0);
                    forces.raid = new Vector(0, 0);
                    forces.trade = new Vector(0, 0);
                    forces.bond = new Vector(0, 0);
                    
                    let nestRadius = myNest.radius || 20;
                    let maxWorkRadius = nestRadius + 80; // Builders work within 80 pixels of nest edge
                    
                    // STRONG STATION KEEPING - Builders must stay very close to nest
                    if (distToNest > maxWorkRadius) {
                        // Too far from nest - VERY strong force to return
                        let overshoot = distToNest - maxWorkRadius;
                        let returnForce = this.seek(myNest.pos).mult(10.0 + overshoot * 0.1); // Very strong, increases with distance
                        forces.base = returnForce;
                        this.vel.mult(0.7); // Strong velocity dampening
                        this.acc.mult(0.5); // Strong acceleration dampening
                        this.state = "Returning to Nest";
                        active = true;
                    } else if (distToNest > nestRadius + 40) {
                        // Getting close to max radius - gentle pull back
                        let pullStrength = (distToNest - (nestRadius + 40)) / 40; // 0 to 1
                        let pullForce = this.seek(myNest.pos).mult(3.0 * pullStrength);
                        forces.base = pullForce;
                        this.state = "Building";
                        active = true;
                    } else {
                        // Within work radius - can build
                        this.state = "Building";
                        active = true;
                        
                        // BUILDERS CONVERT TRIBE WEALTH TO BUILD BLOCKS
                        let buildCost = 10;
                        if (myNest.wealth >= buildCost) {
                            // Find nearby blocks for clustering
                            let nearbyBlocks = [];
                            if (typeof sim !== 'undefined' && sim.spatialGrid && sim.gridCols > 0) {
                                let nearby = sim.getNearbyEntities(this.pos.x, this.pos.y, 60);
                                nearbyBlocks = nearby.resources.filter(r => r.type === 'BLOCK' && r.active);
                            } else if (typeof sim !== 'undefined' && sim.resources) {
                                nearbyBlocks = sim.resources.filter(r => 
                                    r.type === 'BLOCK' && 
                                    r.active && 
                                    Vector.dist(this.pos, r.pos) < 60
                                );
                            }
                            
                            // Build chance: Much lower to prevent rapid defense level inflation
                            // 2% base chance, 5% if near existing blocks (reduced from 50%/90%)
                            let buildChance = nearbyBlocks.length > 0 ? 0.05 : 0.02;
                            
                            if (Math.random() < buildChance) {
                                // Deduct wealth and build
                                myNest.wealth -= buildCost;
                                
                                // Place block outside nest
                                let blockX, blockY;
                                if (nearbyBlocks.length > 0) {
                                    // Cluster near existing blocks
                                    let nearbyBlock = nearbyBlocks[Math.floor(Math.random() * nearbyBlocks.length)];
                                    let angle = Math.random() * Math.PI * 2;
                                    let offset = 20 + Math.random() * 20; // 20-40 pixels from existing block
                                    blockX = nearbyBlock.pos.x + Math.cos(angle) * offset;
                                    blockY = nearbyBlock.pos.y + Math.sin(angle) * offset;
                                    
                                    // Ensure outside nest
                                    let distFromNest = Vector.dist(new Vector(blockX, blockY), myNest.pos);
                                    if (distFromNest < nestRadius + 20) {
                                        let angleToNest = Math.atan2(blockY - myNest.pos.y, blockX - myNest.pos.x);
                                        blockX = myNest.pos.x + Math.cos(angleToNest) * (nestRadius + 25);
                                        blockY = myNest.pos.y + Math.sin(angleToNest) * (nestRadius + 25);
                                    }
                                } else {
                                    // Place around nest perimeter
                                    let angle = Math.random() * Math.PI * 2;
                                    let blockDist = nestRadius + 25 + Math.random() * 40;
                                    blockX = myNest.pos.x + Math.cos(angle) * blockDist;
                                    blockY = myNest.pos.y + Math.sin(angle) * blockDist;
                                }
                                
                                let newBlock = sim.spawnResource(null, blockX, blockY, 'BLOCK', false, this.tribeId);
                                // Don't increment defenseLevel here - it's already calculated from HP
                                // defenseLevel is recalculated each frame as: Math.floor(this.hp / 500)
                                myNest.hp += 200; // HP increase will naturally increase defenseLevel
                                // Blocks generate ongoing wealth for the nest
                                myNest.wealth += 0.5; // Small immediate wealth boost
                                this.learn('build', 0.5);
                                sim.particles.push(new Particle(this.pos.x, this.pos.y, '#ffffff', 'spark'));
                            }
                        } else {
                            // Not enough wealth - just wait near nest
                            this.state = "Waiting for Wealth";
                        }
                    }
                    
                    // CRITICAL: Apply forces BEFORE returning - forces must be applied for movement to work
                    const agentForceList = [
                        forces.base, forces.food, forces.mine,
                        forces.raid, forces.trade, forces.hunt,
                        forces.flee, forces.social, forces.wander,
                        forces.bond
                    ];
                    let movementForce = new Vector(0, 0);
                    let contributionCount = 0;
                    agentForceList.forEach(f => {
                        if (!f) return;
                        if (f.mag() < 0.001) return;
                        movementForce.add(f);
                        contributionCount++;
                    });
                    if (contributionCount > 0) {
                        movementForce.div(contributionCount);
                        this.applyForce(movementForce);
                    }
                    
                    // BUILDERS EXIT EARLY - No other interactions
                    return;
                }
                
                // SKIP ALL FORCE-SETTING CODE FOR BUILDERS (they've already returned above)
                // Group combat and leader defense code below only runs for non-builders
                
                let chaseTarget = null;
                let chaseDist = Infinity;
                let fleeTarget = null;
                let fleeDist = Infinity;
                // Only do expensive combat calculations if doing expensive ops
                if (doExpensiveOps !== false) {
                    for (let enemy of localAgents) {
                        if (!enemy || enemy.dead || enemy.tribeId === this.tribeId || enemy.tribeId === -1) continue;
                        let enemyGroup = enemy.getCachedBondedGroup();
                        let enemyStrength = enemy.getGroupStrength(enemyGroup);
                        if (enemyStrength <= 0) continue;
                        let d = Vector.dist(this.pos, enemy.pos);
                        if (d > combatRange) continue;
                        let enemyInGroup = enemyGroup.length > 1;
                        let ratio = myGroupStrength / (enemyStrength + 0.01);
                        if (inGroup && ratio > 1.2 && d < chaseDist) {
                            chaseTarget = enemy;
                            chaseDist = d;
                        }
                        if ((inGroup && ratio < 0.8) || (!inGroup && enemyInGroup && enemyStrength > myGroupStrength * 1.2)) {
                            if (d < fleeDist) {
                                fleeTarget = enemy;
                                fleeDist = d;
                            }
                        }
                    }
                }
                // active is already declared above before builder logic
                if (chaseTarget) {
                    forces.hunt.add(this.seek(chaseTarget.pos).mult(2.4));
                    this.state = "Group Assault";
                    active = true;
                } else if (fleeTarget) {
                    forces.flee.add(this.flee(fleeTarget.pos).mult(2.1));
                    this.state = "Group Evade";
                    active = true;
                }
                let tribeInfo = sim.tribes && sim.tribes.tribes[this.tribeId];
                if (tribeInfo && tribeInfo.leaderUnderAttack && tribeInfo.leaderUnderAttackTargetId && this.tribeId !== -1 && this.id !== tribeInfo.leaderId) {
                    let attacker = sim.agents.find(a => a.id === tribeInfo.leaderUnderAttackTargetId);
                    if (attacker && !attacker.dead) {
                        let distToAttacker = Vector.dist(this.pos, attacker.pos);
                        if (distToAttacker < 400) {
                            forces.hunt.add(this.seek(attacker.pos).mult(2.2));
                            this.state = "Defending Leader";
                            active = true;
                        }
                    } else {
                        tribeInfo.leaderUnderAttack = false;
                        tribeInfo.leaderUnderAttackTargetId = null;
                    }
                }
                
                this.state = "Wander";
                let hunger = (this.maxEnergy - this.energy) / this.maxEnergy; 
                let isStarving = hunger > 0.7;

                // TEACHER BOOST: Check if teachers are present in nest to double baby growth rate
                let babyGrowthRate = CONFIG.babyGrowthRate;
                if (!this.isAdult() && this.tribeId !== -1 && myNest) {
                    // Check if baby is inside nest
                    if (distToNest < myNest.radius) {
                        // Check for teachers inside the nest
                        // PERFORMANCE: Use spatial grid to find teachers near the nest
                        let teachersInNest = [];
                        if (typeof sim !== 'undefined' && sim.spatialGrid && sim.gridCols > 0) {
                            let nearby = sim.getNearbyEntities(myNest.pos.x, myNest.pos.y, myNest.radius);
                            teachersInNest = nearby.agents.filter(a => 
                                a.role === 'Teacher' && 
                                a.tribeId === this.tribeId && 
                                !a.dead
                            );
                        } else if (typeof sim !== 'undefined' && sim.agents) {
                            // Fallback: filter only if spatial grid not available
                            teachersInNest = sim.agents.filter(a => 
                                a.role === 'Teacher' && 
                                a.tribeId === this.tribeId && 
                                !a.dead &&
                                Vector.dist(a.pos, myNest.pos) < myNest.radius
                            );
                        }
                        if (teachersInNest.length > 0) {
                            babyGrowthRate *= 2.0; // Double growth rate when teachers are present
                        }
                    }
                }
                
                // NEST TETHER (LEADERS/GUARDIANS)
                if (this.tribeId !== -1 && myNest) {
                    let isLeader = sim.tribes.tribes[this.tribeId].leaderId === this.id;
                    if (isLeader || this.role === 'Guardian') {
                        // Leaders/Guardians stay within reasonable radius from nest
                        // Leaders restricted to 3X nest radius, Guardians use configurable radius
                        let nestRadius = myNest.radius || 20;
                        let maxWanderRadius = isLeader ? (nestRadius * 3) : ((CONFIG.leaderMaxWanderRadius || 120) + nestRadius);
                        let tether = maxWanderRadius;
                        
                        if (distToNest > tether) {
                            // Stronger pull the further they are from nest
                            let overshoot = distToNest - tether;
                            let k = 0.12; // Stronger tether force (was 0.05)
                            let force = Vector.sub(myNest.pos, this.pos).normalize().mult(overshoot * k);
                            forces.base.add(force);
                            // Stronger dampening when far from nest
                            this.vel.mult(0.90); // More dampening (was 0.95)
                            // Also reduce acceleration to prevent overshoot
                            this.acc.mult(0.8);
                            if (!active) { 
                                this.state = isLeader ? "Returning to Nest" : "Guarding"; 
                                active = true; 
                            }
                        } else if (distToNest > tether * 0.8) {
                            // Gentle pull when getting close to max radius
                            let pullStrength = (distToNest - tether * 0.8) / (tether * 0.2);
                            let k = 0.03 * pullStrength;
                            let force = Vector.sub(myNest.pos, this.pos).normalize().mult(k * 10);
                            forces.base.add(force);
                        }
                        
                        // ============================================
                        // NEST LEADER PRIORITY BEHAVIORS (in order)
                        // ============================================
                        if (isLeader) {
                            // LEADERS: High defense, no energy/resource consumption
                            this.defense = Math.max(this.defense || 0, 0.8); // High defense (80% damage reduction)
                            this.shieldBonus = Math.max(this.shieldBonus || 0, 0.8); // Apply as shield bonus for damage reduction
                            
                            // PERFORMANCE: Consolidate nearby queries - only query once per frame
                            let nearbyAgents = null;
                            let nearbyResources = null;
                            let nearbyNests = null;
                            let hasQueriedNearby = false;
                            
                            // Helper to get nearby entities (cached for this frame)
                            const getNearby = (radius) => {
                                if (!hasQueriedNearby || !nearbyAgents) {
                                    let nearby = sim.getNearbyEntities(this.pos.x, this.pos.y, Math.max(120, radius));
                                    nearbyAgents = nearby.agents;
                                    nearbyResources = nearby.resources;
                                    nearbyNests = sim.tribes.nests.filter(n => 
                                        n.tribeId !== this.tribeId && 
                                        Vector.dist(this.pos, n.pos) < n.radius + 10
                                    );
                                    hasQueriedNearby = true;
                                }
                                return { agents: nearbyAgents, resources: nearbyResources, nests: nearbyNests };
                            };
                            
                            // Priority 1: Bond with tribe members outside nest for symbiosis - release them in nest
                            if (distToNest > myNest.radius + 10) {
                                let nearby = getNearby(100);
                                for (let agent of nearby.agents) {
                                    if (agent && !agent.dead && agent.tribeId === this.tribeId && 
                                        agent.id !== this.id && !this.partners.includes(agent) &&
                                        Vector.dist(agent.pos, myNest.pos) > myNest.radius + 10) {
                                        // Bond with tribe member outside nest
                                        if (!this.partners.includes(agent) && !agent.partners.includes(this)) {
                                            this.addPartner(agent);
                                            agent.addPartner(this);
                                            // Increase charisma and love
                                            agent.charisma = Math.min(1.0, (agent.charisma || 0.5) + 0.1);
                                            agent.love = Math.min(100, (agent.love || 50) + 10);
                                            this.charisma = Math.min(1.0, (this.charisma || 0.5) + 0.05);
                                            sim.particles.push(new Particle(this.pos.x, this.pos.y, '#fde047', 'spark'));
                                            break; // One at a time
                                        }
                                    }
                                }
                            }
                            
                            // Priority 2: Bond with non-tribe members and convert them immediately - release them in nest
                            if (distToNest > myNest.radius + 10) {
                                let nearby = getNearby(100);
                                for (let agent of nearby.agents) {
                                    if (agent && !agent.dead && agent.tribeId !== this.tribeId && 
                                        agent.tribeId !== -1 && agent.id !== this.id && 
                                        !this.partners.includes(agent) && agent.role !== 'Monster') {
                                        // Bond with non-tribe member
                                        if (!this.partners.includes(agent) && !agent.partners.includes(this)) {
                                            this.addPartner(agent);
                                            agent.addPartner(this);
                                            // Convert immediately to tribe
                                            agent.tribeId = this.tribeId;
                                            if (sim.tribes.tribes[this.tribeId]) {
                                                agent.color = (sim.tribes.tribes[this.tribeId] && sim.tribes.tribes[this.tribeId].color) || agent.color;
                                            }
                                            // Increase charisma and love
                                            agent.charisma = Math.min(1.0, (agent.charisma || 0.5) + 0.15);
                                            agent.love = Math.min(100, (agent.love || 50) + 15);
                                            this.charisma = Math.min(1.0, (this.charisma || 0.5) + 0.1);
                                            sim.particles.push(new Particle(agent.pos.x, agent.pos.y, agent.color, 'spark'));
                                            break; // One at a time
                                        }
                                    }
                                }
                            }
                            
                            // Priority 3: Eat resources (other than those created by tribe)
                            if (!this.carrying) {
                                let nearby = getNearby(50);
                                for (let r of nearby.resources) {
                                    if (r && r.active && r.type !== 'BLOCK' && 
                                        (r.creatorTribe === -1 || r.creatorTribe !== this.tribeId)) {
                                        let d = Vector.dist(this.pos, r.pos);
                                        if (d < this.radius + r.config.radius + 5) {
                                            // Consume resource
                                            let energyGain = weightedResourceEnergy(r.type) || 30;
                                            this.energy = Math.min(this.maxEnergy, this.energy + energyGain);
                                            r.active = false;
                                            sim.particles.push(new Particle(r.pos.x, r.pos.y, '#fde047', 'spark'));
                                            break; // One at a time
                                        }
                                    }
                                }
                            }
                            
                            // Priority 4: Form diplomatic/commercial relations with nests within radius when entering another nest
                            let nearby = getNearby(0);
                            if (nearby.nests.length > 0) {
                                let otherNest = nearby.nests[0];
                                let otherTribeId = otherNest.tribeId;
                                let myTribe = sim.tribes.tribes[this.tribeId];
                                let otherTribe = sim.tribes.tribes[otherTribeId];
                                
                                if (myTribe && otherTribe && !myTribe.atWarWith[otherTribeId]) {
                                    // Strong effect: 50% chance to form/strengthen diplomatic bond
                                    if (Math.random() < 0.5) {
                                        let currentDip = myTribe.diplomaticBonds[otherTribeId] || 0;
                                        let newDip = Math.min(100, currentDip + 5);
                                        myTribe.diplomaticBonds[otherTribeId] = newDip;
                                        if (otherTribe.diplomaticBonds[this.tribeId] === undefined) {
                                            otherTribe.diplomaticBonds[this.tribeId] = 0;
                                        }
                                        otherTribe.diplomaticBonds[this.tribeId] = Math.min(100, (otherTribe.diplomaticBonds[this.tribeId] || 0) + 5);
                                        
                                        // DIPLOMATIC BOND CREATED - Nice harmonious sound (when crossing threshold)
                                        if (currentDip < 10 && newDip >= 10 && typeof sfx !== 'undefined' && sfx.enabled) {
                                            sfx.play('bond', getHarmonicFreq([HARMONICS.A4, HARMONICS.C5, HARMONICS.E5, HARMONICS.G5], 10), 0.12); // Harmonious diplomatic tone
                                        }
                                        
                                        sim.particles.push(new Particle(this.pos.x, this.pos.y, '#3b82f6', 'spark'));
                                    }
                                    
                                    // Strong effect: 50% chance to form/strengthen commercial bond
                                    if (Math.random() < 0.5) {
                                        let currentCom = myTribe.commercialBonds[otherTribeId] || 0;
                                        let newCom = Math.min(100, currentCom + 5);
                                        myTribe.commercialBonds[otherTribeId] = newCom;
                                        if (otherTribe.commercialBonds[this.tribeId] === undefined) {
                                            otherTribe.commercialBonds[this.tribeId] = 0;
                                        }
                                        otherTribe.commercialBonds[this.tribeId] = Math.min(100, (otherTribe.commercialBonds[this.tribeId] || 0) + 5);
                                        
                                        // COMMERCIAL BOND CREATED - Nice harmonious sound (when crossing threshold)
                                        if (currentCom < 10 && newCom >= 10 && typeof sfx !== 'undefined' && sfx.enabled) {
                                            sfx.play('bond', getHarmonicFreq([HARMONICS.A4, HARMONICS.C5, HARMONICS.E5, HARMONICS.G5], 10), 0.12); // Harmonious commercial/trade tone
                                        }
                                        
                                        sim.particles.push(new Particle(this.pos.x, this.pos.y, '#22c55e', 'spark'));
                                    }
                                }
                            }
                            
                            // Priority 5 & 6: Attack enemies / defend nest (consolidated)
                            nearby = getNearby(120);
                            let myTribe = sim.tribes.tribes[this.tribeId];
                            let enemyLeader = null;
                            for (let agent of nearby.agents) {
                                if (agent && !agent.dead && agent.tribeId !== this.tribeId && 
                                    agent.tribeId !== -1 && agent.role !== 'Monster') {
                                    let otherTribe = sim.tribes.tribes[agent.tribeId];
                                    if (!otherTribe) continue;
                                    
                                    // Priority 6: Check if this is an enemy leader
                                    if (otherTribe.leaderId === agent.id && myTribe && myTribe.atWarWith[agent.tribeId]) {
                                        enemyLeader = agent;
                                        continue; // Process leaders after regular enemies
                                    }
                                    
                                    // Priority 5: Attack regular enemies
                                    if (myTribe && myTribe.atWarWith[agent.tribeId]) {
                                        let d = Vector.dist(this.pos, agent.pos);
                                        if (d < this.radius + agent.radius + 10) {
                                            let damage = 2.0; // Leader does good damage
                                            agent.health -= damage;
                                            agent.energy -= damage * 0.5;
                                            sim.particles.push(new Particle(agent.pos.x, agent.pos.y, '#ef4444', 'spark'));
                                            if (!active) { this.state = "Attacking Enemy"; active = true; }
                                            break;
                    } else {
                                            // Seek enemy
                                            let seekForce = Vector.sub(agent.pos, this.pos).normalize().mult(0.5);
                                            forces.hunt.add(seekForce);
                                            if (!active) { this.state = "Hunting Enemy"; active = true; }
                                        }
                                    }
                                }
                            }
                            
                            // Priority 6: Attack enemy leader (if found)
                            if (enemyLeader && myTribe && myTribe.atWarWith[enemyLeader.tribeId]) {
                                let d = Vector.dist(this.pos, enemyLeader.pos);
                                if (d < this.radius + enemyLeader.radius + 10) {
                                    let damage = 3.0; // Extra damage to enemy leaders
                                    enemyLeader.health -= damage;
                                    enemyLeader.energy -= damage * 0.5;
                                    sim.particles.push(new Particle(enemyLeader.pos.x, enemyLeader.pos.y, '#dc2626', 'spark'));
                                    if (!active) { this.state = "Attacking Enemy Leader"; active = true; }
                                } else {
                                    // Seek enemy leader
                                    let seekForce = Vector.sub(enemyLeader.pos, this.pos).normalize().mult(0.6);
                                    forces.hunt.add(seekForce);
                                    if (!active) { this.state = "Hunting Enemy Leader"; active = true; }
                                }
                            }
                            
                            // LEADER BOND RELEASE: When leader returns to nest with bonded agent, release bond
                            if (distToNest < myNest.radius + 20 && this.partners.length > 0) {
                                // Release all bonds when returning to nest
                                for (let i = this.partners.length - 1; i >= 0; i--) {
                                    let partner = this.partners[i];
                                    this.removePartner(partner);
                                    if (partner && !partner.dead) {
                                        partner.removePartner(this);
                                    }
                                }
                                sim.particles.push(new Particle(this.pos.x, this.pos.y, '#fde047', 'spark')); // Yellow spark for bond release
                            }
                        }
                    } else if (this.role === 'Guardian' || this.role === 'Teacher' || this.role === 'Scientist' || this.role === 'Artisan') {
                        // STATION KEEPING: Guardians, Teachers, Scientists, Artisans stay near nest
                        // BUILDERS are handled separately above and return early
                        let nestRadius = myNest.radius || 20;
                        let maxWanderRadius = 150 + nestRadius; // Station keeping radius
                        let tether = maxWanderRadius;
                        
                        if (distToNest > tether) {
                            // Other station keepers use normal tether
                            if (distToNest > tether) {
                                // Stronger pull the further they are from nest
                                let overshoot = distToNest - tether;
                                let k = 0.12; // Strong tether force
                                let force = Vector.sub(myNest.pos, this.pos).normalize().mult(overshoot * k);
                                forces.base.add(force);
                                // Stronger dampening when far from nest
                                this.vel.mult(0.90);
                                // Also reduce acceleration to prevent overshoot
                                this.acc.mult(0.8);
                                if (!active) { 
                                    this.state = "Station Keeping"; 
                                    active = true; 
                                }
                            } else if (distToNest > tether * 0.8) {
                                // Gentle pull when getting close to max radius
                                let pullStrength = (distToNest - tether * 0.8) / (tether * 0.2);
                                let k = 0.03 * pullStrength;
                                let force = Vector.sub(myNest.pos, this.pos).normalize().mult(k * 10);
                                forces.base.add(force);
                            }
                        }
                    } else if (!inGroup && this.role !== 'Builder') {
                        // ROAMING BEHAVIOR (for non-leaders/non-guardians/non-station-keepers/non-builders)
                        // BUILDERS NEVER ROAM - They must stay near nest and build
                        // High roaming gene = wander far, low = stay near nest
                        let roamingStrength = this.dna.roaming * CONFIG.roamingGeneStrength;
                        
                        if (roamingStrength < 0.3) {
                            // Stay near nest
                            let comfortDistance = 200;
                            if (distToNest > comfortDistance) {
                                let k = 0.02;
                                let force = Vector.sub(myNest.pos, this.pos).normalize().mult((distToNest - comfortDistance) * k);
                                forces.base.add(force);
                                this.state = "Returning Home";
                            }
                        } else if (roamingStrength > 0.7) {
                            // Roam freely, return periodically
                            if (this.nextNestReturn === 0) {
                                // Set next return time
                                let minReturn = CONFIG.nestReturnFrequencyMin;
                                let maxReturn = CONFIG.nestReturnFrequencyMax;
                                let returnFreq = minReturn + this.dna.nest_return_frequency * (maxReturn - minReturn);
                                this.nextNestReturn = sim.frame + returnFreq;
                            }
                            
                            if (sim.frame >= this.nextNestReturn) {
                                // Time to return to nest
                                if (distToNest > 100) {
                                    let k = 0.03;
                                    let force = Vector.sub(myNest.pos, this.pos).normalize().mult(k * 20);
                                    forces.base.add(force);
                                    this.state = "Returning to Nest";
                                } else {
                                    // Reached nest, reset timer
                                    this.nextNestReturn = 0;
                                    this.state = "Resting at Nest";
                                }
                            } else {
                                this.state = "Roaming";
                            }
                        }
                    } else {
                        this.state = "Group Roaming";
                        this.nextNestReturn = 0;
                    }

                    // BUILDERS DON'T GATHER MAT - They convert tribe wealth to build blocks
                    // Removed MAT gathering logic - builders work with tribe wealth instead
                }
                
                // NEST DEFENSE
                // BUILDERS DON'T DEFEND - They focus only on building
                if (this.role !== 'Builder' && myNest && sim.tribes.tribes[this.tribeId] && sim.tribes.tribes[this.tribeId].underAttack) {
                    forces.base = this.seek(myNest.pos).mult(4.0);
                    this.state = "DEFENDING NEST";
                    active = true;
                }

                // ALLIANCE DEFENSE
                // BUILDERS DON'T DEFEND ALLIES - They focus only on building
                if (this.role !== 'Builder' && !active && myNest) {
                     let allies = Object.keys(sim.tribes.tribes).filter(tid => tid != this.tribeId && sim.tribes.getOpinion(this.tribeId, tid) > 50);
                     for(let allyId of allies) {
                         if (sim.tribes.tribes[allyId].underAttack) {
                             let allyNest = sim.tribes.nests.find(n => n.tribeId == allyId);
                             if (allyNest) {
                                 forces.base = this.seek(allyNest.pos).mult(3.0);
                                 this.state = "Helping Ally";
                                 active = true;
                                 break;
                             }
                         }
                     }
                }

                // ARTISAN: Manufacturing
                if (this.role === 'Artisan' && myNest && distToNest < 100 && this.energy > 80) {
                    if (Math.random() < 0.02) { // Production chance
                        this.energy -= 30;
                        sim.spawnResource(null, this.pos.x + (Math.random()*20-10), this.pos.y + (Math.random()*20-10), 'MAT', false, this.tribeId);
                        sim.particles.push(new Particle(this.pos.x, this.pos.y, '#a5f3fc', 'spark'));
                        this.state = "Manufacturing";
                    }
                }

                // HEALER BEHAVIOR
                if (this.role === 'Healer') {
                    let patient = null;
                    let minHealth = 100;
                    for(let a of localAgents) {
                        if (a.tribeId === this.tribeId && a.health < a.maxHealth * 0.8 && a.health < minHealth) {
                            minHealth = a.health;
                            patient = a;
                        }
                    }
                    if (patient) {
                        forces.social = this.seek(patient.pos).mult(2.0);
                        this.state = "Healing";
                        active = true;
                        if (Vector.dist(this.pos, patient.pos) < 20) {
                            if (this.energy > 20) {
                                this.energy -= 1;
                                patient.health += 2;
                                // Self-limiting: Only create particle if particle count is reasonable
                                if (Math.random() < 0.1 && sim.particles && sim.particles.length < 150) {
                                    sim.particles.push(new Particle(patient.pos.x, patient.pos.y, '#fbcfe8', 'heart'));
                                }
                            }
                        }
                    }
                }

                // TEACHER BEHAVIOR
                if (this.role === 'Teacher') {
                    let pupil = localAgents.find(a => a.tribeId === this.tribeId && !a.isAdult());
                    if (pupil) {
                         forces.social = this.seek(pupil.pos).mult(1.5);
                         this.state = "Teaching";
                         active = true;
                         if (Vector.dist(this.pos, pupil.pos) < 30) {
                             pupil.age += 0.5; // Grow faster
                             if (Math.random() < 0.05) pupil.learnSkill('SENSE', 1);
                         }
                    }
                }

                // SCOUT BEHAVIOR - Explore and find resources
                if (this.role === 'Scout' && !this.carrying && !active) {
                    // Scouts actively explore to find resources
                    // They're attracted to areas with resources they haven't seen recently
                    let nearbyResources = localRes.filter(r => 
                        r.active && 
                        !r.carrier &&
                        Vector.dist(this.pos, r.pos) < 200
                    );
                    
                    if (nearbyResources.length > 0) {
                        // Find the most valuable unexplored resource
                        let bestResource = null;
                        let bestValue = -1;
                        for (let r of nearbyResources) {
                            let value = weightedResourceEnergy(r.type) || 10;
                            // Prefer resources further from nest (exploration)
                            let distFromNest = myNest ? Vector.dist(r.pos, myNest.pos) : 0;
                            value += distFromNest / 50; // Bonus for distant resources
                            if (value > bestValue) {
                                bestValue = value;
                                bestResource = r;
                            }
                        }
                        
                        if (bestResource) {
                            forces.food = this.seek(bestResource.pos).mult(1.5);
                            this.state = "Scouting";
                    active = true;
                        }
                    } else {
                        // No nearby resources - explore outward
                        forces.wander = this.wander().mult(2.0);
                        this.state = "Exploring";
                        active = true;
                    }
                }

                // BOTANIST BEHAVIOR - Seek food areas to cultivate
                if (this.role === 'Botanist' && !this.carrying) {
                    // Find nearby food resources to cultivate
                    let foodTargets = localRes.filter(r => 
                        r.type === 'FOOD' && 
                        r.active && 
                        !r.carrier &&
                        Vector.dist(this.pos, r.pos) < 150
                    );
                    
                    if (foodTargets.length > 0) {
                        // Seek the closest food area
                        let closestFood = foodTargets.sort((a, b) => 
                            Vector.dist(this.pos, a.pos) - Vector.dist(this.pos, b.pos)
                        )[0];
                        
                        let foodDist = Vector.dist(this.pos, closestFood.pos);
                        if (foodDist > 40) {
                            // Move toward food areas
                            forces.food = this.seek(closestFood.pos).mult(1.2);
                            this.state = "Seeking Food Area";
                            active = true;
                        }
                    }
                }

                // Builder logic has been moved to run FIRST (before line 6814) to prevent wandering

                // Multi-cellular Physics - Elastic vs Rigid Bonds with type-specific benefits
                this.partners = this.partners.filter(p => !p.dead);
                
                // BREAK BONDS WITH ENEMIES - Check if any partners became enemies
                for (let i = this.partners.length - 1; i >= 0; i--) {
                    let p = this.partners[i];
                    if (this.tribeId !== -1 && p.tribeId !== -1 && typeof sim !== 'undefined' && sim.tribes) {
                        let tribe1 = sim.tribes.tribes[this.tribeId];
                        let tribe2 = sim.tribes.tribes[p.tribeId];
                        if (tribe1 && tribe2) {
                            // Break bond if tribes are at war
                            if ((tribe1.atWarWith && tribe1.atWarWith[p.tribeId] === true) ||
                                (tribe2.atWarWith && tribe2.atWarWith[this.tribeId] === true)) {
                                this.removePartner(p);
                                p.removePartner(this);
                                continue;
                            }
                            // Break bond if opinion dropped below hate threshold
                            let opinion = sim.tribes.getOpinion(this.tribeId, p.tribeId);
                            if (opinion < (CONFIG.hateThreshold || -40)) {
                                this.removePartner(p);
                                p.removePartner(this);
                                continue;
                            }
                        }
                    }
                }
                
                // ELASTIC BOND LEADERSHIP - Find strongest member in elastic-bonded groups
                let elasticGroup = this.getCachedBondedGroup();
                let hasElasticBonds = false;
                for (let partner of this.partners) {
                    if (!this.rigidBonds[partner.id]) {
                        hasElasticBonds = true;
                        break;
                    }
                }
                
                let elasticLeader = null;
                if (hasElasticBonds && elasticGroup.length > 1) {
                    // Find strongest member (highest health + energy + stability)
                    let maxStrength = -1;
                    for (let member of elasticGroup) {
                        if (member.dead) continue;
                        let strength = (member.health / member.maxHealth) * 0.4 +
                                      (member.energy / member.maxEnergy) * 0.3 +
                                      (member.structureStability / CONFIG.structureStabilityCap) * 0.3;
                        if (strength > maxStrength) {
                            maxStrength = strength;
                            elasticLeader = member;
                        }
                    }
                }
                
                // MUTUAL REPULSION for rigid bonds to prevent overlap (maintain stable shape)
                this.partners.forEach(p => {
                    let rigidType = (this.rigidBonds && this.rigidBonds[p.id]) || null;
                    if (rigidType) {
                    let d = Vector.dist(this.pos, p.pos);
                        let minSeparation = this.radius + p.radius + 10; // Minimum comfortable distance
                        
                        if (d < minSeparation && d > 0) {
                            // Repel if too close (prevents overlap)
                            let repulsionStrength = (minSeparation - d) * 0.3;
                            let repulsion = Vector.sub(this.pos, p.pos).normalize().mult(repulsionStrength);
                            forces.bond.add(repulsion);
                        }
                    }
                });
                
                let rigidCount = this.getRigidBondCount();
                this.partners.forEach(p => {
                    let d = Vector.dist(this.pos, p.pos);
                    let rigidType = this.rigidBonds[p.id];
                    
                    // Calculate partner's influence weight based on health and energy (strength)
                    let partnerStrength = 1.0;
                    if (CONFIG.bondInfluenceByStrength) {
                        let healthFactor = p.health / p.maxHealth; // 0-1
                        let energyFactor = Math.min(1.0, p.energy / p.maxEnergy); // 0-1
                        partnerStrength = (healthFactor * 0.6 + energyFactor * 0.4); // Weighted average
                        partnerStrength = Math.max(0.2, partnerStrength); // Minimum 20% influence
                    }
                    
                    // Rigid bonds are harder to break
                    let totalBonds = Math.max(1, this.partners.length);
                    let rigidRatio = (rigidCount / totalBonds);
                    let bandMultiplier = this.structureBandActive ? CONFIG.structureStabilityBandBonus : 1;
                    let stabilityBonus = 1 + this.structureStability * 0.002 * bandMultiplier;
                    // Limit elastic bond length for group agents
                    let maxElasticLength = 150;
                    if ((this.isGroupEntity || (p && p.isGroupEntity)) && !rigidType) {
                        maxElasticLength = CONFIG.groupAgentElasticBondMaxLength || 180;
                    }
                    let breakDist = (rigidType ? 200 : maxElasticLength) + (rigidRatio * 40) * stabilityBonus;
                    let baseResistance = rigidType ? CONFIG.rigidBondBreakResistance : 1.0;
                    let breakResistance = baseResistance * (1 + rigidRatio * 0.75) * stabilityBonus;
                    
                    if (d > breakDist || this.getNetLoyalty(p) < -10 * breakResistance) {
                        this.removePartner(p);
                        p.removePartner(this);
                    } else {
                        if (rigidType) {
                            // Rigid bond: maintain fixed length with strong spring
                            let rigidLength = CONFIG.rigidBondLength;
                            let displacement = d - rigidLength;
                            let k = CONFIG.rigidBondStiffness * partnerStrength; // Weight by strength
                            let force = Vector.sub(p.pos, this.pos).normalize().mult(displacement * k);
                            forces.bond.add(force);
                            // Stronger velocity coupling for rigid bonds, weighted by partner strength
                            this.vel.add(p.vel.copy().mult(0.08 * partnerStrength));
                            
                            // TYPE-SPECIFIC EMERGENT BEHAVIORS
                            if (rigidType === 'shield') {
                                // Shield pairs: increased defense and health regen when close
                                if (d < rigidLength * 1.2) {
                                    if (this.health < this.maxHealth) this.health += 0.15;
                                    // Reduce incoming damage
                                    this.shieldBonus = 0.3; // 30% damage reduction
                                    // Energy efficiency when defending together
                                    if (this.state === "Guarding") {
                                        this.energy += 0.1;
                                    }
                                    // Boost loyalty between shield partners
                                    this.adjustLoyalty(p.id, 0.05);
                                }
                            } else if (rigidType === 'hunt') {
                                // Hunt pairs: synchronized hunting, damage boost when attacking same target
                                if (this.targetId && p.targetId === this.targetId && d < rigidLength * 1.5) {
                                    // Coordinated attack bonus (2x damage when synchronized)
                                    this.huntBonus = 2.0;
                                    this.prefs.hunt = Math.min(3.0, this.prefs.hunt + 0.01);
                                    // Share target detection range
                                    if (p.state === "Hunting") {
                                        this.state = "Hunting";
                                    }
                                } else {
                                    this.huntBonus = 1.0;
                                }
                            } else if (rigidType === 'gather') {
                                // Gather pairs: increased resource detection and carry capacity
                                if (d < rigidLength * 1.2) {
                                    // Share resources more efficiently
                                    if (this.carrying && !p.carrying && p.energy < p.maxEnergy * 0.5) {
                                        if (this.carrying.type === 'FOOD' || this.carrying.type === 'UNIQUE') {
                                            // Quick energy transfer from carrier
                                            p.energy += 0.5;
                                            this.energy -= 0.5;
                                        }
                                    }
                                    // Both gain resource detection bonus
                                    this.gatherRangeBonus = 1.5; // 50% wider detection
                                    // Reduced energy cost when foraging together
                                    if (this.state === "Foraging" && p.state === "Foraging") {
                                        this.energy += 0.05;
                                    }
                                    // Occasionally duplicate resources
                                    if (this.carrying && Math.random() < 0.001) {
                                        let bonus = { ...this.carrying };
                                        bonus.pos = this.pos.copy();
                                        bonus.carrier = null;
                                        sim.resources.push(bonus);
                                    }
                                }
                            } else if (rigidType === 'swift') {
                                // Swift pairs: increased movement speed and coordination
                                if (d < rigidLength * 1.2) {
                                    this.maxSpeed = Math.min(this.baseSpeed * 1.4, this.maxSpeed + 0.01);
                                    // Perfect velocity matching for synchronized movement
                                    this.vel.add(p.vel.copy().mult(0.05));
                                    // Lower energy cost when moving together
                                    if (this.vel.mag() > 0.5 && p.vel.mag() > 0.5) {
                                        this.energy += 0.03;
                                    }
                                    // Shared navigation (if partner sees something, both benefit)
                                    if (p.targetId && !this.targetId) {
                                        this.targetId = p.targetId;
                                    }
                                }
                            }
                        } else {
                            // Elastic bond: flexible spring, weighted by partner strength
                        let idealDist = this.radius + p.radius + 5;
                        let displacement = d - idealDist;
                            let k = 0.05 * partnerStrength; // Weight by strength
                        let force = Vector.sub(p.pos, this.pos).normalize().mult(displacement * k);
                        forces.bond.add(force);
                            this.vel.add(p.vel.copy().mult(0.02 * partnerStrength)); // Weight velocity coupling
                        }
                    }
                });
                
                // ELASTIC BOND LEADERSHIP CONSTRAINT - Prevent members from moving opposite to leader
                if (elasticLeader && elasticLeader !== this && hasElasticBonds) {
                    // Check if this agent has any elastic bonds
                    let hasElasticBond = false;
                    for (let partner of this.partners) {
                        if (!this.rigidBonds[partner.id]) {
                            hasElasticBond = true;
                            break;
                        }
                    }
                    
                    if (hasElasticBond) {
                        // Get leader's movement direction
                        let leaderVel = elasticLeader.vel.copy();
                        if (leaderVel.mag() > 0.1) {
                            leaderVel.normalize();
                            
                            // Get this agent's intended movement direction (from accumulated forces)
                            let myIntendedDir = new Vector(0, 0);
                            for (let key in forces) {
                                if (forces[key] && forces[key].mag) {
                                    myIntendedDir.add(forces[key]);
                                }
                            }
                            
                            if (myIntendedDir.mag() > 0.1) {
                                myIntendedDir.normalize();
                                
                                // Calculate dot product (1 = same direction, -1 = opposite)
                                let dotProduct = leaderVel.x * myIntendedDir.x + leaderVel.y * myIntendedDir.y;
                                
                                // If moving in opposite direction (dot product < -0.3), constrain movement
                                if (dotProduct < -0.3) {
                                    // Project movement onto perpendicular to leader's direction
                                    // This allows movement perpendicular but not opposite
                                    let perpX = -leaderVel.y;
                                    let perpY = leaderVel.x;
                                    
                                    // Project intended direction onto perpendicular
                                    let perpDot = myIntendedDir.x * perpX + myIntendedDir.y * perpY;
                                    let constrainedDir = new Vector(perpX * perpDot, perpY * perpDot);
                                    
                                    // Also allow some movement towards leader (following)
                                    let toLeader = Vector.subTorus(elasticLeader.pos, this.pos, sim.width, sim.height);
                                    if (toLeader.mag() > 0.1) {
                                        toLeader.normalize();
                                        constrainedDir.add(toLeader.mult(0.3));
                                    }
                                    
                                    // Apply constraint to forces - reduce opposite movement
                                    let constraintStrength = Math.abs(dotProduct) * 0.4; // Stronger constraint for more opposite movement
                                    for (let key in forces) {
                                        if (forces[key] && forces[key].mag) {
                                            let oppositeComponent = forces[key].copy();
                                            oppositeComponent.normalize();
                                            let oppDot = oppositeComponent.x * leaderVel.x + oppositeComponent.y * leaderVel.y;
                                            if (oppDot < -0.3) {
                                                // Reduce opposite component
                                                forces[key].mult(1 - constraintStrength);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                
                this.updateStructureStability();
                
                // BONDED GROUP RESOURCE SHARING - Groups pool energy and wealth
                if (this.partners.length > 0 && this.frame % 30 === 0) { // Check every 30 frames
                    let group = this.getBondedGroup();
                    if (group.length > 1) {
                        // Calculate total group resources
                        let totalEnergy = 0;
                        let totalWealth = 0;
                        let groupSize = 0;
                        
                        for (let member of group) {
                            if (!member.dead) {
                                totalEnergy += member.energy;
                                totalWealth += member.wealth;
                                groupSize++;
                            }
                        }
                        
                        if (groupSize > 1) {
                            // Calculate fair share per member
                            let avgEnergy = totalEnergy / groupSize;
                            let avgWealth = totalWealth / groupSize;
                            
                            // Redistribute resources (move towards average, but not instantly)
                            let shareRate = 0.15; // 15% redistribution per cycle
                            
                            for (let member of group) {
                                if (!member.dead) {
                                    // Energy sharing (helps starving members)
                                    if (member.energy < avgEnergy * 0.7 && avgEnergy > 50) { // Only share if group has surplus
                                        let transfer = (avgEnergy - member.energy) * shareRate;
                                        member.energy += transfer;
                                        
                                        // Visual feedback
                                        if (Math.random() < 0.1) {
                                            sim.particles.push(new Particle(member.pos.x, member.pos.y, '#4ade80', 'plus'));
                                        }
                                    }
                                    
                                    // Wealth sharing (less aggressive, for emergencies only)
                                    if (member.wealth < avgWealth * 0.5 && avgWealth > 100) {
                                        let transfer = (avgWealth - member.wealth) * (shareRate * 0.5); // Half rate
                                        member.wealth += transfer;
                                        
                                        // Visual feedback
                                        if (Math.random() < 0.1) {
                                            sim.particles.push(new Particle(member.pos.x, member.pos.y, '#fbbf24', 'coin'));
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                let amPredator = false;
                let amPrey = false;

                if (this.role === 'Monster') {
                    let nearest = null;
                    let dNear = Infinity;
                    for(let a of localAgents) {
                        if (a.role === 'Monster') continue;
                        
                        // Don't attack bonded group members
                        let isInBondedGroup = this.partners.includes(a);
                        if (!isInBondedGroup) {
                            for (let p of this.partners) {
                                if (!p.dead && p.partners.includes(a)) {
                                    isInBondedGroup = true;
                                    break;
                                }
                            }
                        }
                        if (isInBondedGroup) continue;
                        
                        let d = Vector.dist(this.pos, a.pos);
                        if(d < dNear) { dNear = d; nearest = a; }
                    }
                    if(nearest) {
                        forces.hunt = this.seek(nearest.pos).mult(2.0);
                        this.state = "Rampage";
                        if(dNear < this.radius + nearest.radius + 5) {
                            // Agents inside nests are 1.5x harder to kill
                            let damage = nearest.isInsideNest() ? 10 / 1.5 : 10;
                            nearest.health -= damage;
                            this.energy += 10; 
                            if(this.energy > this.maxEnergy) this.energy = this.maxEnergy; 
                            
                            // BLOODY PARTICLE SCATTER EFFECTS - Reduced for performance during intense battles
                            // Only create particles if particle count is reasonable
                            if (sim.particles.length < 200) {
                                for (let i = 0; i < 2; i++) { // Reduced from 5 to 2
                                    let angle = Math.random() * Math.PI * 2;
                                    let dist = Math.random() * 15;
                                    let particleX = nearest.pos.x + Math.cos(angle) * dist;
                                    let particleY = nearest.pos.y + Math.sin(angle) * dist;
                                    // Blood particles - red variations with slight scatter
                                    let bloodColors = ['#dc2626', '#b91c1c', '#991b1b', '#ef4444'];
                                    let bloodColor = bloodColors[Math.floor(Math.random() * bloodColors.length)];
                                    sim.particles.push(new Particle(particleX, particleY, bloodColor, 'spark'));
                                }
                            sim.particles.push(new Particle(nearest.pos.x, nearest.pos.y, '#ef4444', 'spark'));
                            }
                        }
                    } else {
                        forces.wander = this.wander();
                    }
                    this.applyForce(forces.hunt);
                    this.applyForce(forces.wander);
                    return; 
                }

                // MERCHANT - Enhanced trading with all non-enemy tribes
                if (this.role === 'Merchant') {
                    if (this.carrying) {
                        let tradePartner = null;
                        let closestTrade = Infinity;
                        
                        // Seek merchants from non-enemy tribes (not just carrying merchants)
                        for(let a of localAgents) {
                            if (a.role === 'Merchant' && a.tribeId !== this.tribeId && a.tribeId !== -1) {
                                // Check if tribes are not at war
                                let relation = sim.tribes.getOpinion(this.tribeId, a.tribeId);
                                if (relation > CONFIG.hateThreshold) { // Not enemies
                                let d = Vector.dist(this.pos, a.pos);
                                    // Prioritize partners who are carrying
                                    let priority = a.carrying ? 1.0 : 0.5;
                                    let effectiveD = d / priority;
                                    if (effectiveD < closestTrade) { 
                                        closestTrade = d; 
                                        tradePartner = a; 
                                    }
                                }
                            }
                        }
                        
                        if (tradePartner) {
                            forces.trade = this.seek(tradePartner.pos).mult(2.5);
                            this.state = "Trading";
                            active = true;
                            if (closestTrade < this.radius + tradePartner.radius + 10) {
                                // Commerce transactions can be any exchange
                                let tradeHappened = false;
                                
                                if (this.carrying && tradePartner.carrying) {
                                    // Both have items - swap them
                                let myItem = this.carrying;
                                let theirItem = tradePartner.carrying;
                                this.carrying = theirItem;
                                tradePartner.carrying = myItem;
                                theirItem.carrier = this;
                                myItem.carrier = tradePartner;
                                    tradeHappened = true;
                                } else if (this.carrying && !tradePartner.carrying) {
                                    // Only I have item - give it to them (they'll return the favor later)
                                    tradePartner.carrying = this.carrying;
                                    this.carrying.carrier = tradePartner;
                                    this.carrying = null;
                                    tradeHappened = true;
                                }
                                
                                if (tradeHappened) {
                                    // Trade strengthens relations significantly (faster than decay) - 2X STRONGER
                                    sim.tribes.updateOpinion(this.tribeId, tradePartner.tribeId, 20.0); // Doubled from 10.0
                                    sim.tribes.updateOpinion(tradePartner.tribeId, this.tribeId, 20.0); // Doubled from 10.0
                                    
                                    // Strengthen commercial bonds between nests - 2X STRONGER
                                    let myTribe = sim.tribes.tribes[this.tribeId];
                                    let theirTribe = sim.tribes.tribes[tradePartner.tribeId];
                                    if (myTribe && theirTribe) {
                                        let oldBond1 = myTribe.commercialBonds[tradePartner.tribeId] || 0;
                                        let oldBond2 = theirTribe.commercialBonds[this.tribeId] || 0;
                                        
                                        myTribe.commercialBonds[tradePartner.tribeId] = Math.min(100, oldBond1 + 16); // Doubled from 8
                                        theirTribe.commercialBonds[this.tribeId] = Math.min(100, oldBond2 + 16); // Doubled from 8
                                        
                                        // ECONOMIC BOND FORMATION SOUND - Play when commercial bond reaches threshold
                                        let newBond1 = myTribe.commercialBonds[tradePartner.tribeId];
                                        // Economic bond tracking (sound removed)
                                    }
                                    
                                    // Both merchants gain wealth from trade
                                    this.wealth += 5;
                                    tradePartner.wealth += 5;
                                    this.energy += 10;
                                    tradePartner.energy += 10;
                                    
                                    // Enhanced trade VFX
                                    sim.particles.push(new Particle(this.pos.x, this.pos.y, '#fbbf24', 'dollar'));
                                    sim.particles.push(new Particle(tradePartner.pos.x, tradePartner.pos.y, '#fbbf24', 'dollar'));
                                    sim.particles.push(new Particle((this.pos.x + tradePartner.pos.x)/2, (this.pos.y + tradePartner.pos.y)/2, '#22d3ee', 'star')); 
                            }
                            }
                        } else {
                            // Wander toward other nests to find trading opportunities
                            if (Math.random() < 0.3) {
                                let targetNest = null;
                                let closestNest = Infinity;
                                for (let nest of sim.tribes.nests) {
                                    if (nest.tribeId !== this.tribeId) {
                                        let relation = sim.tribes.getOpinion(this.tribeId, nest.tribeId);
                                        if (relation > CONFIG.hateThreshold) { // Not enemies
                                            let d = Vector.dist(this.pos, nest.pos);
                                            if (d < closestNest) {
                                                closestNest = d;
                                                targetNest = nest;
                                            }
                                        }
                                    }
                                }
                                if (targetNest) {
                                    forces.wander = this.seek(targetNest.pos).mult(0.8);
                        } else {
                            forces.wander = this.wander().mult(1.5);
                                }
                            } else {
                                forces.wander = this.wander().mult(1.5);
                            }
                        }
                    } else {
                        // BUILDERS DON'T GATHER FOOD - only MAT (handled in builder-specific code above)
                        if (myNest && distToNest < 100 && this.role !== 'Builder') {
                            let exportItem = null;
                            for(let r of localRes) {
                                if (!r.carrier && r.active && (r.type === 'FOOD' || r.type === 'MAT')) {
                                    exportItem = r;
                                    break; 
                                }
                            }
                            if (exportItem) {
                                forces.food = this.seek(exportItem.pos); 
                                if (Vector.dist(this.pos, exportItem.pos) < this.radius + exportItem.config.radius) {
                                    exportItem.carrier = this;
                                    this.carrying = exportItem;
                                }
                            }
                        } else if (myNest) {
                            forces.base = this.seek(myNest.pos);
                        }
                    }
                }

                // ARTISAN & MANUFACTURE
                let canManufacture = this.role === 'Artisan' || this.skills.MANUFACTURE > 0;
                if (canManufacture) {
                    let cost = this.role === 'Artisan' ? 100 : 150 - (this.skills.MANUFACTURE * 10);
                    if (this.carrying && this.carrying.type === 'MAT' && this.energy > cost + 50) {
                        this.carrying.active = false; 
                        sim.spawnResource(null, this.pos.x, this.pos.y, 'TREASURE', false, this.tribeId);
                        this.carrying = null;
                        this.energy -= cost;
                        // Update base charisma (multiplier will be applied in update method)
                        if (this._baseCharisma === undefined) this._baseCharisma = this.charisma || 0;
                        this._baseCharisma += 1;
                        this.charisma = this._baseCharisma;
                        this.wealth += 10;
                    }
                    if (this.skills.MANUFACTURE > 0 && Math.random() < 0.001 * this.skills.MANUFACTURE) {
                         sim.spawnResource(null, this.pos.x, this.pos.y, 'MAT', false, this.tribeId);
                    }
                }

                // MINER
                if (this.role === 'Miner') {
                    let target = null;
                    let dTarget = Infinity;
                    let searchPool = localRes.length > 0 ? localRes : resources;
                    for(let r of searchPool) {
                        if((r.type === 'MAT' || r.type === 'ORE') && !r.carrier && r.active) {
                            let d = Vector.dist(this.pos, r.pos);
                            if (d < dTarget) { dTarget = d; target = r; }
                        }
                    }
                    if(target) {
                        forces.mine = this.seek(target.pos).mult(1.5);
                        this.state = "Mining";
                        active = true;
                        if(dTarget < 20) {
                            target.active = false; 
                            let val = target.type === 'ORE' ? 30 : 5;
                            this.energy += 30;
                            this.wealth += val;
                            if(this.energy > this.maxEnergy) this.energy = this.maxEnergy;
                            sim.particles.push(new Particle(target.pos.x, target.pos.y, target.type === 'ORE' ? '#94a3b8' : '#facc15', 'spark'));
                        }
                    }
                }

                // WAR COMBAT - All agents hunt and fight enemy agents during war (EXCEPT BUILDERS - they focus on building)
                if (this.role !== 'Builder' && this.tribeId !== -1 && typeof sim !== 'undefined' && sim.tribes) {
                    let myTribe = sim.tribes.tribes[this.tribeId];
                    if (myTribe && myTribe.atWarWith) {
                        // Check if tribe is at war with anyone
                        let atWar = false;
                        let enemyTribeIds = [];
                        for (let otherId in myTribe.atWarWith) {
                            if (myTribe.atWarWith[otherId] === true) {
                                atWar = true;
                                enemyTribeIds.push(otherId);
                            }
                        }
                        
                        if (atWar && enemyTribeIds.length > 0) {
                            // Find nearby enemy agents to fight
                            // PERFORMANCE: Uses localAgents from spatial grid (only searches current grid cell, not globally)
                            let enemyTarget = null;
                            let minEnemyDist = Infinity;
                            
                            for (let a of localAgents) {
                                // Only target agents from enemy tribes (not food chain agents)
                                // Compare tribe IDs properly (handle both string and number)
                                if (a.tribeId !== -1 && !a.dead) {
                                    let isEnemy = false;
                                    for (let enemyId of enemyTribeIds) {
                                        // Compare as both string and number to handle type mismatches
                                        if (a.tribeId == enemyId || a.tribeId.toString() === enemyId.toString()) {
                                            isEnemy = true;
                                            break;
                                        }
                                    }
                                    if (isEnemy) {
                                        let d = Vector.distTorus(this.pos, a.pos, sim.width, sim.height);
                                        if (d < minEnemyDist && d < 200) { // Combat range: 200
                                            minEnemyDist = d;
                                            enemyTarget = a;
                                        }
                                    }
                                }
                            }
                            
                            if (enemyTarget) {
                                // Hunt enemy agent - add to forces object
                                forces.war.add(this.seek(enemyTarget.pos).mult(1.5));
                                this.state = "Fighting";
                                active = true;
                                
                                // Ranged attack if possible
                                if (minEnemyDist < 150 && this.shootCooldown <= 0) {
                                    sim.projectiles.push(new Projectile(this.pos.x, this.pos.y, enemyTarget, this));
                                    this.shootCooldown = 40; // Slightly longer cooldown for non-combat roles
                                }
                                
                                // Melee combat
                                if (minEnemyDist < this.radius + enemyTarget.radius + 5) {
                                    // All agents can fight during war, but less effectively than combat roles
                                    let baseDamage = (this.role === 'Soldier' || this.role === 'Guardian') ? 5 : 2;
                                    
                                    // Agents inside nests are 1.5x harder to kill
                                    let damage = enemyTarget.isInsideNest() ? baseDamage / 1.5 : baseDamage;
                                    
                                    // SPY WEAKNESS: Apply spy weakness to enemy's damage (they attack weaker when spies are nearby)
                                    // Note: This is applied when enemy attacks, not here - but we track it for consistency
                                    
                                    enemyTarget.health -= damage;
                                    enemyTarget.energy -= damage * 2;
                                    
                                    // War fighting deteriorates relations
                                    if (Math.random() < 0.1 && enemyTarget.tribeId !== -1) {
                                        sim.tribes.updateOpinion(enemyTarget.tribeId, this.tribeId, -1);
                                        sim.tribes.updateOpinion(this.tribeId, enemyTarget.tribeId, -0.5);
                                    }
                                    
                                    sim.particles.push(new Particle(enemyTarget.pos.x, enemyTarget.pos.y, '#dc2626', 'spark'));
                                }
                            }
                        }
                    }
                }

                // RAIDER & SOLDIER Aggression - TARGET NON-ALLIED TRIBES!
                if (this.role === 'Raider' || this.role === 'Soldier' || this.role === 'Guardian') {
                    let target = null;
                    let minDist = Infinity;
                    let bestTarget = null;
                    let bestScore = -Infinity;
                    
                    // STRATEGIC TARGETING: Prioritize non-allied, disliked, and at-war tribes
                    for (let enemyNest of sim.tribes.nests) {
                        if (enemyNest.tribeId === this.tribeId) continue;
                        
                        let myTribe = sim.tribes.tribes[this.tribeId];
                        if (!myTribe) continue; // Safety check for food chain agents or missing tribes
                        
                        let relation = sim.tribes.getOpinion(this.tribeId, enemyNest.tribeId) || 0;
                        let dipBond = myTribe.diplomaticBonds[enemyNest.tribeId] || 0;
                        let comBond = myTribe.commercialBonds[enemyNest.tribeId] || 0;
                        let atWar = myTribe.atWarWith[enemyNest.tribeId] || false;
                        
                        // Skip allied tribes (strong bonds)
                        if (dipBond > 40 || comBond > 40) continue;
                        
                        let distance = Vector.dist(this.pos, enemyNest.pos);
                        
                        // Calculate target priority score
                        let score = 0;
                        
                        // 1. Prioritize at-war tribes (highest priority)
                        if (atWar) score += 1000;
                        
                        // 2. Prioritize disliked tribes (negative relations)
                        if (relation < 0) score += Math.abs(relation) * 5; // More dislike = higher priority
                        
                        // 3. Prioritize neutral/unknown tribes (no bonds)
                        if (dipBond === 0 && comBond === 0 && relation <= 10) score += 50;
                        
                        // 4. Prioritize wealthy nests (plunder opportunity!)
                        score += enemyNest.wealth / 10;
                        
                        // 5. Prefer closer targets (distance penalty)
                        score -= distance / 10;
                        
                        // 6. Raiders especially target weak, wealthy nests
                        if (this.role === 'Raider') {
                            score += (enemyNest.wealth / enemyNest.hp) * 100; // wealth-to-hp ratio
                        }
                        
                        if (score > bestScore) {
                            bestScore = score;
                            bestTarget = enemyNest;
                            minDist = distance;
                        }
                    }
                    
                    target = bestTarget;

                    if (target) {
                        // Soldier attacks nests even harder
                        let forceMult = this.role === 'Soldier' ? 3.0 : 2.5;
                        forces.raid = this.seek(target.pos instanceof Vector ? target.pos : target.pos).mult(forceMult); 
                        this.state = "Sieging";
                        active = true;
                        
                        if (minDist < this.radius + (target.radius || 20)) {
                            if (target instanceof Nest) {
                                // Attack nest - defense level reduces damage
                                let baseDamage = (this.role === 'Soldier' ? 8 : 5);
                                // Defense reduces damage: each defense level reduces damage by 15% (max 75% reduction at DEF 5+)
                                let defenseReduction = Math.min(0.75, target.defenseLevel * 0.15);
                                let damage = baseDamage * (1.0 - defenseReduction);
                                target.hp -= damage;
                                sim.tribes.tribes[target.tribeId].underAttack = true; // TRIGGER DEFENSE
                                sim.particles.push(new Particle(target.pos.x, target.pos.y, '#ef4444', 'spark'));
                                
                                // ATTACKING DETERIORATES RELATIONS!
                                if (Math.random() < 0.3) { // 30% chance per attack
                                    sim.tribes.updateOpinion(target.tribeId, this.tribeId, -2); // Victim dislikes attacker
                                    sim.tribes.updateOpinion(this.tribeId, target.tribeId, -0.5); // Attacker also becomes more hostile
                                }
                            }
                        } else if (distToNest < 150 && this.shootCooldown <= 0) {
                            // Ranged Attack
                            sim.projectiles.push(new Projectile(this.pos.x, this.pos.y, target, this));
                            this.shootCooldown = 30;
                        }
                    } else {
                        // If no nest, hunt agents
                        for(let a of localAgents) {
                            if (a.tribeId !== this.tribeId && a.tribeId !== -1) {
                                let d = Vector.dist(this.pos, a.pos);
                                if (d < minDist) { minDist = d; target = a; }
                            }
                        }
                        if (target) {
                            forces.raid = this.seek(target.pos).mult(2.0);
                            this.state = "Raiding";
                            active = true;
                            if (minDist < 150 && this.shootCooldown <= 0) {
                                sim.projectiles.push(new Projectile(this.pos.x, this.pos.y, target, this));
                                this.shootCooldown = 30;
                            }
                            
                            if (minDist < this.radius + target.radius + 5) {
                                // Steal wealth
                                let steal = Math.min(target.wealth, (this.role === 'Raider' ? 50 : 10)); // Raiders steal huge amounts
                                target.wealth -= steal;
                                this.wealth += steal;
                                target.energy -= 10;
                                this.energy += 10;
                                sim.particles.push(new Particle(target.pos.x, target.pos.y, '#a855f7', 'spark'));
                                
                                // RAIDING DETERIORATES RELATIONS!
                                if (Math.random() < 0.2 && target.tribeId !== -1 && this.tribeId !== -1) {
                                    sim.tribes.updateOpinion(target.tribeId, this.tribeId, -3); // Victim strongly dislikes raider
                                    sim.tribes.updateOpinion(this.tribeId, target.tribeId, -1); // Raider becomes more hostile
                                }
                            }
                        } else {
                            forces.wander = this.wander().mult(1.5);
                        }
                    }
                }

                // GARBAGE COLLECTOR BEHAVIOR
                if (this.role === 'Garbage Collector') {
                    // Hunt for orphaned resources from dead tribes
                    let garbageResources = localRes.filter(r => {
                        // Resources without carrier that don't belong to my tribe
                        if (r.carrier || !r.active) return false;
                        // Check if resource is near any active nest
                        let nearMyNest = false;
                        for (let nest of sim.tribes.nests) {
                            if (nest.tribeId === this.tribeId && Vector.dist(r.pos, nest.pos) < 100) {
                                nearMyNest = true;
                                break;
                            }
                        }
                        // Collect anything not near my own nest
                        return !nearMyNest && (r.type === 'MAT' || r.type === 'ORE' || r.type === 'TREASURE' || r.type === 'STIM' || r.type === 'HERB');
                    });
                    
                    if (garbageResources.length > 0) {
                        // Find closest garbage
                        let closest = garbageResources.sort((a, b) => 
                            Vector.dist(this.pos, a.pos) - Vector.dist(this.pos, b.pos)
                        )[0];
                        
                        let d = Vector.dist(this.pos, closest.pos);
                        if (d < this.radius + closest.config.radius) {
                            // Collect garbage
                            closest.active = false;
                            this.energy += 10; // Small energy boost
                            
                            // RECYCLE: 20% chance to shit out valuable material
                            if (Math.random() < 0.2) {
                                let recycledTypes = ['MAT', 'ORE', 'TREASURE'];
                                let recycled = recycledTypes[Math.floor(Math.random() * recycledTypes.length)];
                                sim.spawnResource(null, this.pos.x + (Math.random()*20-10), this.pos.y + (Math.random()*20-10), recycled, false, this.tribeId);
                                sim.particles.push(new Particle(this.pos.x, this.pos.y, '#a3e635', 'spark'));
                                // Vary trade tone
                                let tradeNotes = [HARMONICS.E4, HARMONICS.A4, HARMONICS.C5, HARMONICS.D5];
                                sfx.play('trade', getHarmonicFreq(tradeNotes, 5), 0.08);
                            }
                            
                            this.state = "Recycling";
                            active = true;
                        } else {
                            // Seek garbage
                            forces.food.add(this.seek(closest.pos).mult(2.5));
                            this.state = "Collecting Garbage";
                            active = true;
                        }
                    }
                }
                
                // FARMER BEHAVIOR - OPTIMIZED: Use limited local queries only
                if (this.role === 'Farmer') {
                    // PERFORMANCE: Farmers only look locally (within 150 pixels) to avoid slowdown
                    let farmerLocalAgents = [];
                    if (typeof sim !== 'undefined' && sim.spatialGrid && sim.gridCols > 0) {
                        let nearby = sim.getNearbyEntities(this.pos.x, this.pos.y, 150); // Limited range
                        farmerLocalAgents = nearby.agents.filter(a => !a.dead);
                    } else {
                        farmerLocalAgents = localAgents.filter(a => Vector.dist(this.pos, a.pos) < 150);
                    }
                    
                    // Initialize spawn timer if not set
                    if (this.nextGrazerSpawn === 0) {
                        this.nextGrazerSpawn = sim.frame + 30; // Start timer at 30 steps
                    }
                    
                    // Farmers spawn 4 grazers every 30 steps (if they have enough energy)
                    if (sim.frame >= this.nextGrazerSpawn && this.energy > 50) {
                        // Spawn 4 grazers nearby
                        for (let i = 0; i < 4; i++) {
                        let spawnX = this.pos.x + (Math.random() * 60 - 30);
                        let spawnY = this.pos.y + (Math.random() * 60 - 30);
                        
                        // Create grazer DNA
                        let grazerDna = {
                            grazer_gene: 0.9,
                            speed: 0.5 + Math.random() * 0.3,
                            size: 0.4 + Math.random() * 0.2,
                            sociability: 0.7 + Math.random() * 0.3
                        };
                        
                        let grazer = new Agent(spawnX, spawnY, grazerDna, null, -1);
                        grazer.role = 'Grazer';
                        grazer.isGrazer = true;
                        sim.agents.push(grazer);
                        }
                        
                        this.energy -= 30; // Same energy cost for 4 grazers
                        sim.particles.push(new Particle(this.pos.x, this.pos.y, '#84cc16', 'leaf'));
                        this.state = "Spawning Grazers";
                        
                        // Schedule next spawn in 30 steps
                        this.nextGrazerSpawn = sim.frame + 30;
                    }
                    
                    // FARMERS ONLY ATTACK PREDATORS AND RAIDERS (using limited local query)
                    let nearbyThreats = farmerLocalAgents.filter(a => (a.isPredator || a.role === 'Raider') && !a.dead);
                    if (nearbyThreats.length > 0) {
                        let closest = nearbyThreats.sort((a, b) => 
                            Vector.dist(this.pos, a.pos) - Vector.dist(this.pos, b.pos)
                        )[0];
                        
                        forces.hunt.add(this.seek(closest.pos).mult(3.0));
                        this.state = "Protecting Prey";
                        active = true;
                        
                        let d = Vector.dist(this.pos, closest.pos);
                        if (d < this.radius + closest.radius + 5) {
                            let damage = CONFIG.damageRate * 200; // Strong attack
                            // SPY WEAKNESS: Spies weaken attack of non-tribe agents near them
                            damage *= this.getSpyWeaknessMultiplier();
                            // Agents inside nests are 1.5x harder to kill
                            damage = closest.isInsideNest() ? damage / 1.5 : damage;
                            closest.health -= damage;
                            markLeaderUnderAttack(closest, this);
                            // Only create blood particle if particle count is reasonable
                            if (sim.particles.length < 200) {
                                // Only create blood particle if particle count is reasonable
                                if (sim.particles.length < 200) {
                            sim.particles.push(new Particle(closest.pos.x, closest.pos.y, '#dc2626', 'blood'));
                                }
                            }
                            // Sound handled by throttled system in update() - no direct call here
                        }
                    }
                }
                
                // SOLDIER BEHAVIOR - Defend nest, kill enemies, attack enemy nests
                if (this.role === 'Soldier' && myNest) {
                    // TRIBE SUSTENANCE - Soldiers sustained by tribe wealth (MUCH CHEAPER NOW!)
                    if (this.energy < 60 && myNest.wealth > 5) {
                        this.energy += 3; // Sustained by tribe
                        myNest.wealth -= 0.2; // Reduced from 1.5 to 0.2 (87% cost reduction!)
                    }
                    // Die faster if tribe is poor
                    if (myNest.wealth < 20) { // Lowered threshold from 50 to 20
                        this.health -= 0.8; // Faster starvation than diplomats
                    }
                    
                    // DEFEND NEST - Stay near nest when not engaging enemies
                    let distToNest = Vector.dist(this.pos, myNest.pos);
                    if (distToNest > 200 && !active) {
                        forces.social.add(this.seek(myNest.pos).mult(1.0));
                        this.state = "Patrolling";
                    }
                    
                    // DEFEND SPECIALISTS - Protect diplomats, merchants, artisans, teachers, scientists from same tribe AND LINKED TRIBES
                    let protectTargets = localAgents.filter(a => {
                        if (a.dead) return false;
                        
                        // Always protect same tribe specialists
                        if (a.tribeId === this.tribeId && 
                            (a.role === 'Diplomat' || a.role === 'Merchant' || a.role === 'Artisan' || 
                             a.role === 'Teacher' || a.role === 'Scientist')) {
                            return true;
                        }
                        
                        // Also protect specialists from LINKED (allied) tribes
                        if (a.tribeId !== this.tribeId && 
                            (a.role === 'Diplomat' || a.role === 'Merchant' || a.role === 'Artisan' || 
                             a.role === 'Teacher' || a.role === 'Scientist')) {
                            let myTribe = sim.tribes.tribes[this.tribeId];
                            if (!myTribe) return false;
                            
                            // Check diplomatic OR commercial bonds
                            let diploBond = myTribe.diplomaticBonds[a.tribeId] || 0;
                            let commBond = myTribe.commercialBonds[a.tribeId] || 0;
                            
                            // Defend if strong link (bonds > 40)
                            return diploBond > 40 || commBond > 40;
                        }
                        
                        return false;
                    });
                    
                    if (protectTargets.length > 0) {
                        // Find threatened diplomats/merchants
                        for (let target of protectTargets) {
                            let nearbyThreats = localAgents.filter(e => {
                                if (e.dead || e.tribeId === this.tribeId) return false;
                                let loyalty = this.getNetLoyalty(e);
                                return loyalty < -20 && Vector.dist(target.pos, e.pos) < 100;
                            });
                            
                            if (nearbyThreats.length > 0) {
                                // Move to protect
                                forces.social.add(this.seek(target.pos).mult(2.0));
                                this.state = "Protecting Diplomat/Merchant";
                                active = true;
                                break;
                            }
                        }
                    }
                    
                    // ATTACK ENEMIES - Find and engage enemies (LIMITED RANGE for performance)
                    if (!active) {
                        // Limit combat search range to 180 (reduced from sense radius) for performance during war
                        const combatRange = CONFIG.groupCombatRange || 180;
                        let combatLocalAgents = [];
                        if (typeof sim !== 'undefined' && sim.spatialGrid && sim.gridCols > 0) {
                            let nearby = sim.getNearbyEntities(this.pos.x, this.pos.y, combatRange);
                            combatLocalAgents = nearby.agents.filter(a => a !== this && !a.dead);
                        } else {
                            // Fallback: filter from localAgents by distance
                            combatLocalAgents = localAgents.filter(a => Vector.dist(this.pos, a.pos) < combatRange);
                        }
                        
                        // Dynamically reduce range if many wars are active
                        let effectiveCombatRange = combatRange;
                        if (typeof sim !== 'undefined' && sim.tribes && sim.tribes.activeWars > 2) {
                            effectiveCombatRange = combatRange * 0.7; // Reduce by 30% when many wars
                            // Re-filter with reduced range
                            combatLocalAgents = combatLocalAgents.filter(a => Vector.dist(this.pos, a.pos) < effectiveCombatRange);
                        }
                        
                        let enemies = combatLocalAgents.filter(other => {
                            if (other.dead || other === this) return false;
                            if (this.partners.includes(other)) return false;
                            
                            // Quick war check first (cheaper than loyalty calculation)
                            if (this.tribeId !== -1 && other.tribeId !== -1 && typeof sim !== 'undefined' && sim.tribes.isAtWar(this.tribeId, other.tribeId)) {
                                return true;
                            }
                            
                            // Only check loyalty if not at war (expensive calculation)
                            let loyalty = this.getNetLoyalty(other);
                            return loyalty < -30;
                        });
                        
                        if (enemies.length > 0) {
                            let closest = enemies.sort((a, b) => 
                                Vector.dist(this.pos, a.pos) - Vector.dist(this.pos, b.pos)
                            )[0];
                            
                            let d = Vector.dist(this.pos, closest.pos);
                            
                            // RANGED COMBAT - Shoot if in range and cooldown ready
                            if (d > 50 && d < CONFIG.rangedCombatRange && this.canShootRanged) {
                                if (!this.rangedCombatCooldown) this.rangedCombatCooldown = 0;
                                
                                if (this.rangedCombatCooldown <= 0 && Math.random() < CONFIG.rangedCombatChance) {
                                    // FIRE PROJECTILE!
                                    sim.projectiles.push(new Projectile(
                                        this.pos.x, 
                                        this.pos.y, 
                                        closest.pos.x, 
                                        closest.pos.y, 
                                        this, 
                                        CONFIG.rangedCombatDamage, 
                                        'arrow'
                                    ));
                                    this.rangedCombatCooldown = CONFIG.rangedCombatCooldown;
                                    this.state = "Shooting Enemy";
                                    active = true;
                                    
                                    // MORE VISIBLE VFX for ranged attacks
                                    sim.particles.push(new Particle(this.pos.x, this.pos.y, '#fbbf24', 'spark'));
                                    // Sound handled by throttled system in update() - no direct call here
                                }
                            }
                            
                            // Move towards enemy
                            forces.hunt.add(this.seek(closest.pos).mult(2.5));
                            if (!active) this.state = "Engaging Enemy";
                            active = true;
                            
                            // Melee combat (close range)
                            if (d < this.radius + closest.radius + 5) {
                                let damage = CONFIG.damageRate * 100; // Strong damage
                                // SPY WEAKNESS: Spies weaken attack of non-tribe agents near them
                                damage *= this.getSpyWeaknessMultiplier();
                                // Agents inside nests are 1.5x harder to kill
                                damage = closest.isInsideNest() ? damage / 1.5 : damage;
                                closest.health -= damage;
                                markLeaderUnderAttack(closest, this);
                                // Only create blood particle if particle count is reasonable
                            if (sim.particles.length < 200) {
                                // Only create blood particle if particle count is reasonable
                                if (sim.particles.length < 200) {
                                sim.particles.push(new Particle(closest.pos.x, closest.pos.y, '#dc2626', 'blood'));
                                }
                            }
                                // Sound handled by throttled system in update() - no direct call here
                                
                                // DETERIORATE RELATIONS when attacking
                                if (this.tribeId !== -1 && closest.tribeId !== -1 && this.tribeId !== closest.tribeId) {
                                    sim.tribes.updateOpinion(this.tribeId, closest.tribeId, -1.5); // Aggressor dislikes victim more
                                    sim.tribes.updateOpinion(closest.tribeId, this.tribeId, -3); // Victim REALLY dislikes aggressor
                                }
                            }
                        }
                    }
                    
                    // Decrement ranged combat cooldown
                    if (this.rangedCombatCooldown > 0) this.rangedCombatCooldown--;
                }
                
                // MINER BEHAVIOR - Solo resource hunters seeking dense clusters
                if (this.role === 'Miner') {
                    // Miners are solo actors - seek ALL types of resources for their tribe
                    if (!this.carrying && !active) {
                        let valuableResources = localRes.filter(r => 
                            r.active && !r.carrier && 
                            (r.type === 'MAT' || r.type === 'ORE' || r.type === 'TREASURE' || r.type === 'UNIQUE' || r.type === 'FOOD')
                        );
                        
                        if (valuableResources.length > 0) {
                            // DENSITY-BASED SEEKING: Find areas with highest resource density
                            let bestTarget = null;
                            let bestScore = -1;
                            
                            for (let resource of valuableResources.slice(0, 10)) { // Sample top 10 closest
                                let density = 0;
                                // Count nearby resources within 100px radius
                                for (let other of valuableResources) {
                                    if (Vector.dist(resource.pos, other.pos) < 100) {
                                        density++;
                                    }
                                }
                                
                                let distance = Vector.dist(this.pos, resource.pos);
                                // Score = density / distance (prefer dense + close)
                                let score = density / Math.max(10, distance);
                                
                                if (score > bestScore) {
                                    bestScore = score;
                                    bestTarget = resource;
                                }
                            }
                            
                            if (bestTarget) {
                                let d = Vector.dist(this.pos, bestTarget.pos);
                                if (d < this.radius + bestTarget.config.radius) {
                                    // Pick up resource
                                    this.carrying = bestTarget;
                                    bestTarget.carrier = this;
                                    this.state = "Mining Resources";
                                    active = true;
                                } else {
                                    // Seek densest cluster
                                    forces.food.add(this.seek(bestTarget.pos).mult(2.5));
                                    this.state = "Seeking Resource Cluster";
                                    active = true;
                                }
                            }
                        }
                    }
                    
                    // Return to nest with resources
                    if (this.carrying && myNest) {
                        let distToNest = Vector.dist(this.pos, myNest.pos);
                        if (distToNest > myNest.radius) {
                            forces.social.add(this.seek(myNest.pos).mult(2.0));
                            this.state = "Delivering Resources";
                            active = true;
                        } else {
                            // Drop off at nest
                            let resourceValue = this.carrying.config.val || 10;
                            this.carrying.active = false;
                            this.carrying.carrier = null;
                            this.carrying = null;
                            myNest.wealth += resourceValue * 5; // Miners contribute 5√ó resource value (MASSIVE INCREASE!)
                            sim.particles.push(new Particle(myNest.pos.x, myNest.pos.y, '#ea580c', 'spark'));
                            sim.particles.push(new Particle(myNest.pos.x + 10, myNest.pos.y, '#fbbf24', 'coin')); // Extra VFX
                        }
                    }
                }
                
                // GARBAGE COLLECTOR BEHAVIOR - Clean up dead tribe resources, seek dense clusters
                if (this.role === 'Garbage Collector') {
                    if (!this.carrying && !active) {
                        // Look for orphaned resources from OTHER TRIBES (not own tribe)
                        let garbageResources = localRes.filter(r => {
                            if (!r.active || r.carrier) return false;
                            if (r.type === 'FOOD') return false; // Don't collect food
                            
                            // Check if resource is from a different (dead or existing) tribe
                            if (r.nestId !== undefined && r.nestId !== this.tribeId) {
                                return true; // Garbage from other tribes
                            }
                            
                            // Also collect resources that have no tribe association
                            return r.nestId === undefined;
                        });
                        
                        if (garbageResources.length > 0) {
                            // DENSITY-BASED SEEKING: Find areas with highest garbage density
                            let bestTarget = null;
                            let bestScore = -1;
                            
                            let sampled = garbageResources.slice(0, 10); // Sample closest 10
                            for (let resource of sampled) {
                                let density = 0;
                                // Count nearby garbage within 120px radius
                                for (let other of garbageResources) {
                                    if (Vector.dist(resource.pos, other.pos) < 120) {
                                        density++;
                                    }
                                }
                                
                                let distance = Vector.dist(this.pos, resource.pos);
                                // Score = density / distance (prefer dense + close)
                                let score = density / Math.max(10, distance);
                                
                                if (score > bestScore) {
                                    bestScore = score;
                                    bestTarget = resource;
                                }
                            }
                            
                            let closest = bestTarget || garbageResources[0];
                            
                            let d = Vector.dist(this.pos, closest.pos);
                            if (d < this.radius + closest.config.radius) {
                                // Collect garbage
                                this.carrying = closest;
                                closest.carrier = this;
                                this.state = "Collecting Garbage";
                                active = true;
                                
                                // RECYCLE: 20% chance to convert to useful resource
                                if (Math.random() < CONFIG.garbageRecycleChance) {
                                    closest.active = false;
                                    this.carrying = null;
                                    
                                    // Spawn recycled resource (silver, ore, mat)
                                    let recycledTypes = ['MAT', 'ORE', 'TREASURE'];
                                    let recycledType = recycledTypes[Math.floor(Math.random() * recycledTypes.length)];
                                    sim.spawnResource(null, this.pos.x, this.pos.y, recycledType, false, this.tribeId);
                                    
                                    sim.particles.push(new Particle(this.pos.x, this.pos.y, '#22c55e', 'spark'));
                                    // Vary collect tone
                                    let collectNotes2 = [HARMONICS.C4, HARMONICS.E4, HARMONICS.A4, HARMONICS.C5, HARMONICS.D5];
                                    sfx.play('collect', getHarmonicFreq(collectNotes2, 6), 0.1);
                                }
                            } else {
                                // Seek garbage
                                forces.food.add(this.seek(closest.pos).mult(1.8));
                                this.state = "Seeking Garbage";
                                active = true;
                            }
                        }
                    }
                    
                    // Energy efficiency: GCs burn less energy
                    if (this.energy > 0) {
                        this.energy += (CONFIG.energyBurnRate * (1 - CONFIG.garbageCollectorEnergyEfficiency)); // Compensate for burn
                    }
                }
                
                // PREDATOR BEHAVIOR - Avoid farmers, hunt prey/grazers
                if (this.isPredator) {
                    // PREDATORS AVOID FARMERS (they are dangerous)
                    let nearbyFarmers = localAgents.filter(a => a.role === 'Farmer' && !a.dead);
                    if (nearbyFarmers.length > 0) {
                        let closestFarmer = nearbyFarmers.sort((a, b) => 
                            Vector.dist(this.pos, a.pos) - Vector.dist(this.pos, b.pos)
                        )[0];
                        let farmerDist = Vector.dist(this.pos, closestFarmer.pos);
                        
                        if (farmerDist < 200) { // Fear radius
                            // Flee from farmer
                            forces.flee.add(Vector.sub(this.pos, closestFarmer.pos).normalize().mult(2.5));
                            this.state = "Avoiding Farmer";
                            active = true;
                        }
                    }
                    
                    // Hunt prey/grazers (but not if near farmer)
                    if (!active) {
                        let targets = localAgents.filter(a => (a.isPrey || a.isGrazer) && !a.dead);
                        // Filter out prey protected by farmers
                        targets = targets.filter(target => {
                            let protectedByFarmer = false;
                            for (let partner of target.partners) {
                                if (partner.role === 'Farmer' && !partner.dead) {
                                    protectedByFarmer = true;
                                    break;
                                }
                            }
                            // Also check if farmer is nearby
                            let farmerNearby = localAgents.some(a => 
                                a.role === 'Farmer' && 
                                Vector.dist(a.pos, target.pos) < 100
                            );
                            return !protectedByFarmer && !farmerNearby;
                        });
                        
                        if (targets.length > 0) {
                            let closest = targets.sort((a, b) => 
                                Vector.dist(this.pos, a.pos) - Vector.dist(this.pos, b.pos)
                            )[0];
                            
                            forces.hunt.add(this.seek(closest.pos).mult(2.0 * CONFIG.predatorPackBonus * (this.partners.length + 1)));
                            this.state = "Hunting";
                            active = true;
                            
                            let d = Vector.dist(this.pos, closest.pos);
                            if (d < this.radius + closest.radius + 5) {
                                let damage = CONFIG.damageRate * 150;
                                // SPY WEAKNESS: Spies weaken attack of non-tribe agents near them
                                damage *= this.getSpyWeaknessMultiplier();
                                // Agents inside nests are 1.5x harder to kill
                                damage = closest.isInsideNest() ? damage / 1.5 : damage;
                                closest.health -= damage;
                                markLeaderUnderAttack(closest, this);
                                this.energy += 50; // Gain energy from kill
                                // Only create blood particle if particle count is reasonable
                            if (sim.particles.length < 200) {
                                // Only create blood particle if particle count is reasonable
                                if (sim.particles.length < 200) {
                                sim.particles.push(new Particle(closest.pos.x, closest.pos.y, '#dc2626', 'blood'));
                                }
                            }
                                // Sound handled by throttled system in update() - no direct call here
                            }
                        }
                    }
                }
                
                // PREY BEHAVIOR - Seek DENSE food areas, evade predators, reproduce more with food
                if (this.isPrey) {
                    // Evade predators (PRIORITY #1)
                    let nearbyPredators = localAgents.filter(a => a.isPredator && !a.dead);
                    if (nearbyPredators.length > 0) {
                        let closestPredator = nearbyPredators.sort((a, b) => 
                            Vector.dist(this.pos, a.pos) - Vector.dist(this.pos, b.pos)
                        )[0];
                        let predatorDist = Vector.dist(this.pos, closestPredator.pos);
                        
                        if (predatorDist < 200) { // Increased detection radius from 150 to 200
                            // Flee from predator (SCATTER!)
                            forces.flee.add(Vector.sub(this.pos, closestPredator.pos).normalize().mult(CONFIG.preyEvadeBonus * 2.5));
                            this.state = "Fleeing Predator";
                            active = true;
                            this.lastFleeTime = this.frame || 0; // Remember when we fled
                        }
                    }
                    
                    // Seek food sources if not fleeing (DENSITY-BASED SEEKING)
                    if (!active) {
                        let nearbyFood = localRes.filter(r => r.type === 'FOOD' && r.active && !r.carrier);
                        if (nearbyFood.length > 0) {
                            // DENSITY-BASED: Find areas with highest food concentration
                            let bestTarget = null;
                            let bestScore = -1;
                            
                            // Sample up to 15 closest food items
                            let sampled = nearbyFood.slice(0, 15);
                            for (let food of sampled) {
                                let density = 0;
                                // Count nearby food within 80px radius
                                for (let other of nearbyFood) {
                                    if (Vector.dist(food.pos, other.pos) < 80) {
                                        density++;
                                    }
                                }
                                
                                let distance = Vector.dist(this.pos, food.pos);
                                // Score = density / distance (prefer dense + close)
                                let score = density / Math.max(10, distance);
                                
                                // BOOST: If we were recently fleeing, prefer returning to dense food areas
                                if (this.lastFleeTime && (this.frame - this.lastFleeTime) < 100) {
                                    score *= (1 + density * 0.2); // Bonus for regrouping
                                }
                                
                                if (score > bestScore) {
                                    bestScore = score;
                                    bestTarget = food;
                                }
                            }
                            
                            if (bestTarget) {
                                forces.food.add(this.seek(bestTarget.pos).mult(1.8));
                                this.state = "Seeking Food Cluster";
                                active = true;
                                
                                // REPRODUCTION BOOST: Track food consumption for reproduction rate
                                let d = Vector.dist(this.pos, bestTarget.pos);
                                if (d < this.radius + bestTarget.config.radius) {
                                    this.foodEaten = (this.foodEaten || 0) + 1; // Track food eaten
                                }
                            }
                        }
                    }
                }
                
                // DIPLOMAT BEHAVIOR - Visit foreign nests, create diplomatic bonds
                if (this.role === 'Diplomat' && myNest) {
                    // TRIBE SUSTENANCE - Diplomats draw from tribe wealth, not self-sufficient (MUCH CHEAPER!)
                    if (this.energy < 50 && myNest.wealth > 3) {
                        this.energy += 2; // Sustained by tribe
                        myNest.wealth -= 0.1; // Reduced from 0.5 to 0.1 (80% cost reduction!)
                    }
                    // Die faster if tribe is poor
                    if (myNest.wealth < 20) { // Lowered from 50 to 20
                        this.health -= 0.5; // Starvation
                    }
                    
                    // Check if this tribe is at war
                    let myTribe = sim.tribes.tribes[this.tribeId];
                    let isAtWar = false;
                    let warTargets = [];
                    if (myTribe && myTribe.atWarWith) {
                        for (let warId in myTribe.atWarWith) {
                            if (myTribe.atWarWith[warId] === true) {
                                isAtWar = true;
                                warTargets.push(parseInt(warId));
                            }
                        }
                    }
                    
                    // Find nearby foreign nests
                    // PERFORMANCE: Check tribeId first before distance calculation
                    let foreignNests = sim.tribes.nests.filter(n => 
                        n.tribeId !== this.tribeId && 
                        Vector.dist(this.pos, n.pos) < 800
                    );
                    // Note: Nests array is usually small (< 50), so full filter is acceptable here
                    
                    if (foreignNests.length > 0) {
                        let targetNest;
                        
                        // WAR-TIME AGGRESSIVE DIPLOMACY: Prioritize enemies of opponent and neutral parties
                        if (isAtWar && warTargets.length > 0) {
                            // Find nests that are enemies of our opponent(s) or neutral
                            let strategicTargets = [];
                            let neutralTargets = [];
                            
                            foreignNests.forEach(nest => {
                                let relation = sim.tribes.getOpinion(this.tribeId, nest.tribeId);
                                let atWarWithNest = sim.tribes.isAtWar(this.tribeId, nest.tribeId);
                                
                                // Skip if at war with this nest (don't visit enemies directly during war)
                                if (atWarWithNest) return;
                                
                                // Check if this nest is an enemy of our opponent (potential ally)
                                let isEnemyOfOpponent = false;
                                for (let warTargetId of warTargets) {
                                    if (sim.tribes.isAtWar(nest.tribeId, warTargetId)) {
                                        isEnemyOfOpponent = true;
                                        break;
                                    }
                                }
                                
                                // Check if neutral (not strong allies, not enemies)
                                let isNeutral = relation >= -20 && relation <= 20;
                                
                                if (isEnemyOfOpponent) {
                                    strategicTargets.push({nest: nest, relation: relation, priority: 100}); // Highest priority
                                } else if (isNeutral) {
                                    neutralTargets.push({nest: nest, relation: relation, priority: 50}); // Medium priority
                                }
                            });
                            
                            // Sort strategic targets by relation (higher first)
                            strategicTargets.sort((a, b) => b.relation - a.relation);
                            neutralTargets.sort((a, b) => Math.abs(b.relation) - Math.abs(a.relation)); // Closest to true neutral first
                            
                            // Prioritize: enemies of opponent > neutral parties > others
                            if (strategicTargets.length > 0) {
                                targetNest = strategicTargets[0].nest;
                            } else if (neutralTargets.length > 0) {
                                targetNest = neutralTargets[0].nest;
                            } else {
                                // Fallback: sort by relation (visit allies first)
                                foreignNests.sort((a, b) => {
                                    let relA = sim.tribes.getOpinion(this.tribeId, a.tribeId);
                                    let relB = sim.tribes.getOpinion(this.tribeId, b.tribeId);
                                    return relB - relA;
                                });
                                targetNest = foreignNests[0];
                            }
                        } else {
                            // Normal peacetime diplomacy: Sort by relation (visit allies first)
                        foreignNests.sort((a, b) => {
                            let relA = sim.tribes.getOpinion(this.tribeId, a.tribeId);
                            let relB = sim.tribes.getOpinion(this.tribeId, b.tribeId);
                            return relB - relA; // Higher relation first
                        });
                            targetNest = foreignNests[0];
                        }
                        
                        let relation = sim.tribes.getOpinion(this.tribeId, targetNest.tribeId);
                        let atWar = sim.tribes.isAtWar(this.tribeId, targetNest.tribeId);
                        
                        // Visit neutral, friendly nests, OR enemy nests for PEACE NEGOTIATIONS
                        // During war, also visit enemies of opponent and neutral parties aggressively (even if slightly negative relation)
                        if (relation >= -10 || atWar || (isAtWar && relation >= -30)) {
                            let d = Vector.dist(this.pos, targetNest.pos);
                            
                            if (d > targetNest.radius + 20) {
                                // Travel to foreign nest
                                forces.social.add(this.seek(targetNest.pos).mult(1.5));
                                this.state = "Diplomatic Mission";
                                active = true;
                            } else {
                                // At foreign nest - conduct diplomacy
                                this.state = "Negotiating";
                                active = true;
                                
                                // AGGRESSIVE DIPLOMACY DURING WAR: Higher frequency when at war
                                let negotiationFrequency = CONFIG.diplomatNegotiationFrequency;
                                if (isAtWar) {
                                    negotiationFrequency *= 3.0; // 3x more frequent during war (aggressive diplomacy)
                                }
                                
                                if (Math.random() < negotiationFrequency) { // Configurable negotiation frequency (boosted during war)
                                    // Calculate negotiation bonus from bonded diplomats/merchants
                                    let negotiationBonus = 1.0;
                                    let bondedDiplomats = this.partners.filter(p => 
                                        !p.dead && 
                                        (p.role === 'Diplomat' || p.role === 'Merchant') &&
                                        p.tribeId === this.tribeId
                                    ).length;
                                    negotiationBonus += bondedDiplomats * 0.2; // +20% per bonded diplomat/merchant
                                    
                                    // PEACE NEGOTIATIONS - End wars through diplomacy!
                                    if (atWar) {
                                        // Try to negotiate peace
                                        let myTribe = sim.tribes.tribes[this.tribeId];
                                        let theirTribe = sim.tribes.tribes[targetNest.tribeId];
                                        let myExhaustion = myTribe.warExhaustion[targetNest.tribeId] || 0;
                                        let theirExhaustion = theirTribe.warExhaustion[this.tribeId] || 0;
                                        
                                        // Peace more likely if both sides exhausted or diplomacy strong
                                        let peaceChance = 0.02 * negotiationBonus; // Base 2% chance
                                        peaceChance += Math.min(myExhaustion, theirExhaustion) / 1000; // Higher if exhausted
                                        
                                        if (Math.random() < peaceChance) {
                                            // PEACE TREATY!
                                            sim.tribes.endWar(this.tribeId, targetNest.tribeId, true); // Treaty = true
                                            // PERFORMANCE: Cleanup after war ends
                                            sim._cleanupAfterWar();
                                            
                                            // Establish diplomatic bonds
                                            if (sim.tribes.tribes[this.tribeId] && sim.tribes.tribes[targetNest.tribeId]) {
                                                if (!sim.tribes.tribes[this.tribeId].diplomaticBonds) sim.tribes.tribes[this.tribeId].diplomaticBonds = {};
                                                if (!sim.tribes.tribes[targetNest.tribeId].diplomaticBonds) sim.tribes.tribes[targetNest.tribeId].diplomaticBonds = {};
                                                let oldDipBond1 = sim.tribes.tribes[this.tribeId].diplomaticBonds[targetNest.tribeId] || 0;
                                                let oldDipBond2 = sim.tribes.tribes[targetNest.tribeId].diplomaticBonds[this.tribeId] || 0;
                                                
                                                sim.tribes.tribes[this.tribeId].diplomaticBonds[targetNest.tribeId] = 30;
                                                sim.tribes.tribes[targetNest.tribeId].diplomaticBonds[this.tribeId] = 30;
                                            }
                                            
                                            // DIPLOMATIC BOND CREATED - Nice harmonious sound
                                            if ((oldDipBond1 < 10 || oldDipBond2 < 10) && typeof sfx !== 'undefined' && sfx.enabled) {
                                                sfx.play('bond', getHarmonicFreq([HARMONICS.A4, HARMONICS.C5, HARMONICS.E5, HARMONICS.G5], 10), 0.15); // Harmonious diplomatic tone
                                            }
                                            
                                            // Improve relations significantly
                                            sim.tribes.updateOpinion(this.tribeId, targetNest.tribeId, 20);
                                            sim.tribes.updateOpinion(targetNest.tribeId, this.tribeId, 20);
                                            
                                            // VFX - Peace celebration
                                            sim.particles.push(new Particle(this.pos.x, this.pos.y, '#22c55e', 'star'));
                                            sim.particles.push(new Particle(targetNest.pos.x, targetNest.pos.y, '#22c55e', 'star'));
                                            sim.particles.push(new Particle(this.pos.x, this.pos.y, '#10b981', 'spark'));
                                            sfx.play('diplomacy', 620, 0.2);
                                            
                                            this.state = "Peace Treaty Signed!";
                                        } else {
                                            // Failed negotiations, but still improve relations slightly
                                            sim.tribes.updateOpinion(this.tribeId, targetNest.tribeId, 0.5 * negotiationBonus);
                                            sim.tribes.updateOpinion(targetNest.tribeId, this.tribeId, 0.5 * negotiationBonus);
                                            this.state = "Peace Talks";
                                        }
                                    } else {
                                        // Normal diplomacy (not at war with this target)
                                        // AGGRESSIVE BOND GROWTH DURING WAR: Diplomatic bonds form faster when at war
                                        // 2X STRONGER EFFECT
                                        let bondGrowth = CONFIG.diplomaticBondGrowth * negotiationBonus * 2.0; // Doubled base effect
                                        if (isAtWar) {
                                            bondGrowth *= 2.5; // 2.5x faster bond growth during war (aggressive diplomacy)
                                        }
                                        
                                        let currentBond = (sim.tribes.tribes[this.tribeId] && sim.tribes.tribes[this.tribeId].diplomaticBonds && sim.tribes.tribes[this.tribeId].diplomaticBonds[targetNest.tribeId]) || 0;
                                        let newBond = Math.min(100, currentBond + bondGrowth);
                                        if (sim.tribes.tribes[this.tribeId] && !sim.tribes.tribes[this.tribeId].diplomaticBonds) {
                                            sim.tribes.tribes[this.tribeId].diplomaticBonds = {};
                                        }
                                        if (sim.tribes.tribes[targetNest.tribeId] && !sim.tribes.tribes[targetNest.tribeId].diplomaticBonds) {
                                            sim.tribes.tribes[targetNest.tribeId].diplomaticBonds = {};
                                        }
                                        
                                        // SFX when bond forms (crosses threshold)
                                        if (currentBond < 20 && newBond >= 20) {
                                            sim.particles.push(new Particle(this.pos.x, this.pos.y, '#fbbf24', 'star'));
                                            sim.particles.push(new Particle(targetNest.pos.x, targetNest.pos.y, '#fbbf24', 'star'));
                                        }
                                        
                                        sim.tribes.tribes[this.tribeId].diplomaticBonds[targetNest.tribeId] = newBond;
                                        sim.tribes.tribes[targetNest.tribeId].diplomaticBonds[this.tribeId] = newBond;
                                        
                                        // Also improve relations slightly (with bonus) - 2X STRONGER
                                        let relationImprovement = 1.0 * negotiationBonus; // Doubled from 0.5
                                        sim.tribes.updateOpinion(this.tribeId, targetNest.tribeId, relationImprovement);
                                        sim.tribes.updateOpinion(targetNest.tribeId, this.tribeId, relationImprovement);
                                        
                                        // VFX (brighter with better negotiation)
                                        sim.particles.push(new Particle(this.pos.x, this.pos.y, '#fde047', 'star'));
                                        if (negotiationBonus > 1.5) {
                                            sim.particles.push(new Particle(this.pos.x, this.pos.y, '#fbbf24', 'spark'));
                                        }
                                        sfx.play('diplomacy', 520, 0.12);
                                    }
                                    
                                    // TECH PROGRESSION: diplomacy activity grants tech points (always)
                                    sim.tribes.progressTech(this.tribeId, 'diplomacy', 2 * negotiationBonus);
                                    sim.tribes.progressTech(targetNest.tribeId, 'diplomacy', 1); // They also gain some
                                    
                                    // TRACK DIPLOMATIC BENEFITS (for bond maintenance)
                                    let currentFrame = sim.frame || 0;
                                    let myTribe = sim.tribes.tribes[this.tribeId];
                                    let theirTribe = sim.tribes.tribes[targetNest.tribeId];
                                    
                                    // Diplomacy provides ongoing value (improved relations, tech, future trade)
                                    let diplomaticValue = 10 * negotiationBonus; // Base value
                                    myTribe.diplomaticBenefits[targetNest.tribeId] = (myTribe.diplomaticBenefits[targetNest.tribeId] || 0) + diplomaticValue;
                                    theirTribe.diplomaticBenefits[this.tribeId] = (theirTribe.diplomaticBenefits[this.tribeId] || 0) + diplomaticValue;
                                    
                                    // Update last diplomacy time
                                    myTribe.lastDiplomacyTime[targetNest.tribeId] = currentFrame;
                                    theirTribe.lastDiplomacyTime[this.tribeId] = currentFrame;
                                }
                            }
                        }
                    }
                }
                
                // MERCHANT BEHAVIOR - Trade with allied nests
                if (this.role === 'Merchant' && myNest) {
                    // TRIBE SUSTENANCE - Merchants sustained by tribe wealth (MUCH CHEAPER!)
                    if (this.energy < 50 && myNest.wealth > 3) {
                        this.energy += 2; // Sustained by tribe
                        myNest.wealth -= 0.1; // Reduced from 0.5 to 0.1 (80% cost reduction!)
                    }
                    // Die faster if tribe is poor
                    if (myNest.wealth < 20) { // Lowered from 50 to 20
                        this.health -= 0.5; // Starvation
                    }
                    
                    // HARVEST RESOURCES FOR TRADE (if not carrying anything)
                    if (!this.carrying && !active) {
                        // Look for valuable resources scattered around landscape
                        let valuableResources = localRes.filter(r => 
                            r.active && !r.carrier && 
                            (r.type === 'MAT' || r.type === 'ORE' || r.type === 'TREASURE' || r.type === 'UNIQUE')
                        );
                        
                        if (valuableResources.length > 0) {
                            let closest = valuableResources.sort((a, b) => 
                                Vector.dist(this.pos, a.pos) - Vector.dist(this.pos, b.pos)
                            )[0];
                            
                            let d = Vector.dist(this.pos, closest.pos);
                            if (d < this.radius + closest.config.radius) {
                                // Pick up resource for trade
                                this.carrying = closest;
                                closest.carrier = this;
                                this.state = "Harvesting for Trade";
                                active = true;
                            } else {
                                // Seek resource
                                forces.food.add(this.seek(closest.pos).mult(2.0));
                                this.state = "Seeking Trade Goods";
                                active = true;
                            }
                        }
                    }
                    
                    // Find nearby allied nests to trade with
                    let tradePartners = sim.tribes.nests.filter(n => {
                        if (n.tribeId === this.tribeId) return false;
                        let relation = sim.tribes.getOpinion(this.tribeId, n.tribeId);
                        return relation >= CONFIG.minAllianceForTrade; // Only trade with allies
                    });
                    
                    if (tradePartners.length > 0 && this.carrying) {
                        // Sort by commercial bond strength (prefer strong trade partners)
                        tradePartners.sort((a, b) => {
                            let bondA = sim.tribes.tribes[this.tribeId].commercialBonds[a.tribeId] || 0;
                            let bondB = sim.tribes.tribes[this.tribeId].commercialBonds[b.tribeId] || 0;
                            return bondB - bondA;
                        });
                        
                        let targetNest = tradePartners[0];
                        let d = Vector.dist(this.pos, targetNest.pos);
                        
                        if (d > targetNest.radius + 30) {
                            // Travel to trade partner
                            forces.social.add(this.seek(targetNest.pos).mult(2.0));
                            this.state = "Trading Mission";
                            active = true;
                        } else {
                            // At trade partner nest - conduct trade
                            this.state = "Trading";
                            active = true;
                            
                            if (Math.random() < CONFIG.merchantTradeFrequency && this.carrying) {
                                // Calculate merchant's negotiation power (from bonded merchants/diplomats)
                                let myNegotiationPower = 1.0;
                                let bondedMerchants = this.partners.filter(p => 
                                    !p.dead && 
                                    (p.role === 'Merchant' || p.role === 'Diplomat') &&
                                    p.tribeId === this.tribeId
                                ).length;
                                myNegotiationPower += bondedMerchants * 0.15; // +15% per bonded merchant/diplomat
                                
                                // Calculate relative tribe strength (wealth, population, tech)
                                let myTribe = sim.tribes.tribes[this.tribeId];
                                let theirTribe = sim.tribes.tribes[targetNest.tribeId];
                                // PERFORMANCE: Use cached agent counts
                                let myCount = 0;
                                let theirCount = 0;
                                if (sim && sim.agents) {
                                    let myCached = sim._cachedTribeAgentCounts[this.tribeId];
                                    if (myCached && (sim.frame - myCached.lastUpdate < 30)) {
                                        myCount = myCached.count;
                                    } else {
                                        myCount = sim.agents.filter(a => a.tribeId === this.tribeId && !a.dead).length;
                                        sim._cachedTribeAgentCounts[this.tribeId] = { count: myCount, lastUpdate: sim.frame };
                                    }
                                    
                                    let theirCached = sim._cachedTribeAgentCounts[targetNest.tribeId];
                                    if (theirCached && (sim.frame - theirCached.lastUpdate < 30)) {
                                        theirCount = theirCached.count;
                                    } else {
                                        theirCount = sim.agents.filter(a => a.tribeId === targetNest.tribeId && !a.dead).length;
                                        sim._cachedTribeAgentCounts[targetNest.tribeId] = { count: theirCount, lastUpdate: sim.frame };
                                    }
                                }
                                let myStrength = (myNest.wealth || 0) + myCount * 10;
                                let theirStrength = (targetNest.wealth || 0) + theirCount * 10;
                                
                                // Stronger party gets better deal (but trade is always beneficial to both)
                                let strengthRatio = myStrength / (theirStrength + 1); // Avoid division by zero
                                strengthRatio = Math.max(0.5, Math.min(2.0, strengthRatio)); // Clamp between 0.5 and 2.0
                                
                                // Calculate trade values (MASSIVELY INCREASED PROFITS!)
                                let baseValue = this.carrying.config.val;
                                let myProfit = baseValue * 15 * myNegotiationPower * strengthRatio; // Merchant profit (5√ó increase!)
                                let homeProfit = baseValue * 10 * strengthRatio; // Home nest profit (5√ó increase!)
                                let theirCost = baseValue * 5 / strengthRatio; // They pay (but increased)
                                let theirBenefit = baseValue * 10; // They benefit greatly! (6.7√ó increase!)
                                
                                // Complete trade
                                let theirNetProfit = theirBenefit - theirCost; // Net benefit to them
                                targetNest.wealth += theirNetProfit;
                                this.wealth += myProfit;
                                myNest.wealth += homeProfit;
                                
                                // TRACK TRADE PROFITS FOR BOTH PARTIES (for bond maintenance)
                                let myTotalProfit = myProfit + homeProfit;
                                let currentFrame = typeof sim !== 'undefined' ? sim.frame : 0;
                                
                                // Update profit tracking (rolling window of last 500 frames)
                                myTribe.tradeProfit[targetNest.tribeId] = (myTribe.tradeProfit[targetNest.tribeId] || 0) + myTotalProfit;
                                theirTribe.tradeProfit[this.tribeId] = (theirTribe.tradeProfit[this.tribeId] || 0) + theirNetProfit;
                                
                                // Add to profit history
                                if (!myTribe.tradeProfitHistory[targetNest.tribeId]) myTribe.tradeProfitHistory[targetNest.tribeId] = [];
                                if (!theirTribe.tradeProfitHistory[this.tribeId]) theirTribe.tradeProfitHistory[this.tribeId] = [];
                                
                                myTribe.tradeProfitHistory[targetNest.tribeId].push({ profit: myTotalProfit, frame: currentFrame });
                                theirTribe.tradeProfitHistory[this.tribeId].push({ profit: theirNetProfit, frame: currentFrame });
                                
                                // Keep only last 500 frames of history
                                if (myTribe.tradeProfitHistory[targetNest.tribeId].length > 100) {
                                    myTribe.tradeProfitHistory[targetNest.tribeId].shift();
                                }
                                if (theirTribe.tradeProfitHistory[this.tribeId].length > 100) {
                                    theirTribe.tradeProfitHistory[this.tribeId].shift();
                                }
                                
                                // Update last trade time
                                myTribe.lastTradeTime[targetNest.tribeId] = currentFrame;
                                theirTribe.lastTradeTime[this.tribeId] = currentFrame;
                                
                                this.carrying.active = false;
                                this.carrying = null;
                                
                                // Strengthen commercial bond (with negotiation bonus)
                                let bondGrowth = CONFIG.commercialBondGrowth * myNegotiationPower;
                                let currentBond = sim.tribes.tribes[this.tribeId].commercialBonds[targetNest.tribeId] || 0;
                                let newBond = Math.min(100, currentBond + bondGrowth);
                                
                                // VFX when bond forms (crosses threshold)
                                if (currentBond < 20 && newBond >= 20) {
                                    sim.particles.push(new Particle(this.pos.x, this.pos.y, '#22d3ee', 'star'));
                                    sim.particles.push(new Particle(targetNest.pos.x, targetNest.pos.y, '#22d3ee', 'star'));
                                }
                                
                                sim.tribes.tribes[this.tribeId].commercialBonds[targetNest.tribeId] = newBond;
                                sim.tribes.tribes[targetNest.tribeId].commercialBonds[this.tribeId] = newBond;
                                
                                // Also improve relations slightly (with bonus)
                                let relationImprovement = 0.4 * myNegotiationPower; // DOUBLED from 0.2
                                sim.tribes.updateOpinion(this.tribeId, targetNest.tribeId, relationImprovement);
                                sim.tribes.updateOpinion(targetNest.tribeId, this.tribeId, relationImprovement);
                                
                                // TECH PROGRESSION: commerce activity grants tech points
                                sim.tribes.progressTech(this.tribeId, 'commerce', 3 * myNegotiationPower);
                                sim.tribes.progressTech(targetNest.tribeId, 'commerce', 2); // They also gain some
                                
                                // SFX for transaction
                                // Vary transaction tone
                                let transactionNotes2 = [HARMONICS.E4, HARMONICS.A4, HARMONICS.C5, HARMONICS.D5, HARMONICS.E5];
                                sfx.play('transaction', getHarmonicFreq(transactionNotes2, 6), 0.08);
                                
                                // VFX (more coins for better deals)
                                sim.particles.push(new Particle(this.pos.x, this.pos.y, '#22d3ee', 'coin'));
                                if (myNegotiationPower > 1.5 || strengthRatio > 1.3) {
                                    sim.particles.push(new Particle(this.pos.x + 10, this.pos.y, '#fbbf24', 'coin'));
                                }
                                // Vary trade tone
                                let tradeNotes2 = [HARMONICS.A4, HARMONICS.C5, HARMONICS.D5, HARMONICS.E5];
                                sfx.play('trade', getHarmonicFreq(tradeNotes2, 6), 0.15);
                            }
                        }
                    } else if (!this.carrying) {
                        // Go home to get resources to trade
                        if (distToNest > 50) {
                            forces.social.add(this.seek(myNest.pos).mult(1.5));
                            this.state = "Returning for Goods";
                            active = true;
                        }
                    }
                }
                
                // GRAZER BEHAVIOR - OPTIMIZED: Use limited local queries only (within 120 pixels)
                if (this.isGrazer) {
                    // PERFORMANCE: Grazers only look locally (within 120 pixels) to avoid slowdown
                    let grazerLocalAgents = [];
                    let grazerLocalRes = [];
                    if (typeof sim !== 'undefined' && sim.spatialGrid && sim.gridCols > 0) {
                        let nearby = sim.getNearbyEntities(this.pos.x, this.pos.y, 120); // Limited range
                        grazerLocalAgents = nearby.agents.filter(a => !a.dead);
                        grazerLocalRes = nearby.resources;
                    } else {
                        grazerLocalAgents = localAgents.filter(a => Vector.dist(this.pos, a.pos) < 120);
                        grazerLocalRes = localRes.filter(r => Vector.dist(this.pos, r.pos) < 120);
                    }
                    
                    // Evade predators and normal agents (using limited local query)
                    let threats = grazerLocalAgents.filter(a => (a.isPredator || (!a.isPrey && !a.isGrazer)) && !a.dead);
                    if (threats.length > 0) {
                        let closestThreat = threats.sort((a, b) => 
                            Vector.dist(this.pos, a.pos) - Vector.dist(this.pos, b.pos)
                        )[0];
                        let threatDist = Vector.dist(this.pos, closestThreat.pos);
                        
                        if (threatDist < 120) {
                            forces.flee.add(Vector.sub(this.pos, closestThreat.pos).normalize().mult(1.8));
                            this.state = "Fleeing Threat";
                            active = true;
                        }
                    }
                    
                    // Seek resources to convert if not fleeing (using limited local query)
                    if (!active) {
                        let targetResources = grazerLocalRes.filter(r => r.type === 'FOOD' && r.active && !r.carrier);
                        if (targetResources.length > 0) {
                            let closest = targetResources.sort((a, b) => 
                                Vector.dist(this.pos, a.pos) - Vector.dist(this.pos, b.pos)
                            )[0];
                            forces.food.add(this.seek(closest.pos).mult(1.2));
                            this.state = "Grazing";
                            active = true;
                        }
                    }
                }

                // RANGED COMBAT - SOLDIERS ONLY (LIMITED RANGE for performance)
                if (this.canShootRanged && this.shotCooldown <= 0) {
                    // Limit ranged combat search to actual ranged range (150) for performance
                    const rangedSearchRange = CONFIG.rangedCombatRange || 150;
                    let rangedLocalAgents = [];
                    if (typeof sim !== 'undefined' && sim.spatialGrid && sim.gridCols > 0) {
                        let nearby = sim.getNearbyEntities(this.pos.x, this.pos.y, rangedSearchRange);
                        rangedLocalAgents = nearby.agents.filter(a => a !== this && !a.dead);
                    } else {
                        rangedLocalAgents = localAgents.filter(a => Vector.dist(this.pos, a.pos) < rangedSearchRange);
                    }
                    
                    // Find enemies in range
                    let enemies = rangedLocalAgents.filter(other => {
                        if (other.dead || other === this) return false;
                        
                        // Can't shoot bonded group members
                        if (this.partners.includes(other)) return false;
                        let bondedGroup = this.getBondedGroup();
                        if (bondedGroup.includes(other)) return false;
                        
                        // Check if enemy
                        let loyalty = this.getNetLoyalty(other);
                        let isEnemy = loyalty < -30 || (this.tribeId !== -1 && other.tribeId !== -1 && sim.tribes.isAtWar(this.tribeId, other.tribeId));
                        
                        if (!isEnemy) return false;
                        
                        let d = Vector.dist(this.pos, other.pos);
                        return d > this.radius + other.radius + 20 && d < CONFIG.rangedCombatRange; // Medium range only
                    });
                    
                    if (enemies.length > 0 && Math.random() < CONFIG.rangedCombatChance) {
                        // Shoot at closest enemy
                        let target = enemies.sort((a, b) => 
                            Vector.dist(this.pos, a.pos) - Vector.dist(this.pos, b.pos)
                        )[0];
                        
                        // Create projectile
                        let projectile = new Projectile(
                            this.pos.x, this.pos.y,
                            target.pos.x, target.pos.y,
                            this,
                            CONFIG.rangedCombatDamage,
                            'arrow'
                        );
                        sim.projectiles.push(projectile);
                        
                        this.shotCooldown = CONFIG.rangedCombatCooldown;
                        this.state = "Shooting";
                        // Sound handled by throttled system in update() - no direct call here
                    }
                }
                
                // Cooldown decrement
                if (this.shotCooldown > 0) this.shotCooldown--;

                // GATHERING
                let foodScent = new Vector(0,0);
                let foodCount = 0;
                
                if (!this.isAdult()) {
                    // Children follow parents or sit tight
                    if (this.partners.length > 0) {
                        forces.social.add(this.seek(this.partners[0].pos).mult(2.0));
                    }
                } else {
                    // Adult Gathering
                    for (let r of localRes) {
                        if (r.type === 'SEED') continue; 
                        let d = Vector.dist(this.pos, r.pos);
                        // Agents cannot take from their OWN Nest (radius check)
                        let isMyNest = myNest && Vector.dist(r.pos, myNest.pos) < myNest.radius + 10;

                        // ALL AGENTS EAT FOOD WHEN THEY TOUCH IT IF NOT FULL
                        // Check if agent is touching food and not at full energy
                        if (d < this.radius + r.config.radius && r.type === 'FOOD' && r.active && !r.carrier) {
                            let isNotFull = this.energy < this.maxEnergy;
                            // Allow eating even if carrying something, or if not carrying
                            if (isNotFull && (!isMyNest || isStarving || this.energy < this.maxEnergy * 0.8)) {
                                     r.active = false; 
                                     let harvestMult = 1.0 + (this.wealth / 1000); 
                                     this.energy += r.config.val * harvestMult * CONFIG.foodNutritionalValue;
                                if (this.energy > this.maxEnergy) this.energy = this.maxEnergy;
                                // Small wealth gain from eating
                                this.wealth += 1;
                                // Continue to other resource handling if not carrying
                                if (!this.carrying) {
                                    // Don't process this resource again below
                                    continue;
                                }
                            }
                        }
                        
                        // BLOCKS CANNOT BE PICKED UP - Skip block resources
                        if (r.type === 'BLOCK') continue;
                        
                        // HUNGER PRIORITY FIX: If starving, eat regardless of nest proximity
                        if (d < this.radius + r.config.radius && (!isMyNest || isStarving)) {
                            if (this.carrying) {
                                 // Food eating already handled above
                                 if (r.type === 'FOOD') continue; // Skip - already handled
                            } else {
                                // PICKUP
                                if (r.type === 'TREASURE' || r.type === 'RELIC') {
                                    let val = r.type === 'RELIC' ? 200 : 50;
                                    if (r.type === 'RELIC') {
                                        // Curiosity/Scientist Bonus
                                        if (this.role === 'Scientist' || this.dna.curiosity > 0.7) {
                                            this.learnSkill('SENSE', this.skills.SENSE + 1);
                                            sim.particles.push(new Particle(this.pos.x, this.pos.y, '#67e8f9', 'spark'));
                                        }
                                    }
                                    r.active = false; 
                                    // Update base charisma (multiplier will be applied in update method)
                                    if (this._baseCharisma === undefined) this._baseCharisma = this.charisma || 0;
                                    this._baseCharisma += 5;
                                    this.charisma = this._baseCharisma;
                                    this.wealth += val;
                                    sim.particles.push(new Particle(this.pos.x, this.pos.y, '#22d3ee', 'spark'));
                                }
                                else if (r.type === 'MAT' || r.type === 'ORE') {
                                    let builderPriority = this.role === 'Builder' && hunger < 0.5;
                                    if (hunger > 0.9) {
                                        r.active = false;
                                        this.energy += 5; 
                                        if(this.energy > this.maxEnergy) this.energy = this.maxEnergy;
                                        sim.particles.push(new Particle(this.pos.x, this.pos.y, '#facc15'));
                                    }
                                else if (!r.carrier && !this.carrying && groupBenefits.conversionBonus > 1.05 && hunger > 0.6 && this.role !== 'Miner' && this.role !== 'Builder') {
                                    r.active = false;
                                    let energyGain = r.config.val * 0.3 * groupBenefits.conversionBonus;
                                    this.energy = Math.min(this.maxEnergy, this.energy + energyGain);
                                    this.wealth += 2;
                                    sim.particles.push(new Particle(this.pos.x, this.pos.y, '#a855f7', 'spark'));
                                    this.state = "Feeding on Ore";
                                    }
                                    // BUILDERS ONLY CARRY MAT - they don't consume other resources
                                    else if (builderPriority && r.type === 'MAT') {
                                        r.carrier = this;
                                        this.carrying = r;
                                    }
                                    else if (!r.carrier && this.role !== 'Miner' && this.role !== 'Merchant' && this.role !== 'Builder') {
                                        r.carrier = this;
                                        this.carrying = r;
                                    }
                                } else if (r.type === 'FOOD' || r.type === 'STIM' || r.type === 'HERB') {
                                    // BUILDERS DON'T GATHER FOOD - they focus on building only
                                    if (this.role === 'Builder') {
                                        continue; // Skip food gathering for builders
                                    }
                                    
                                    // Skip if food was already eaten by the earlier check
                                    if (r.type === 'FOOD' && !r.active) continue;
                                    
                                    // SOLDIERS, DIPLOMATS, MERCHANTS ARE TRIBE-SUSTAINED - don't gather food
                                    if (this.isSustainedByTribe) {
                                        // Skip food gathering for tribe-sustained roles
                                        continue;
                                    }
                                    
                                    // Bring food to nest if full (only if not already eaten)
                                    if (myNest && this.energy > this.maxEnergy * 0.8 && !r.carrier && !isStarving && r.active) {
                                        r.carrier = this; this.carrying = r;
                                    } else if (r.active) {
                                        if(this.role !== 'Merchant') {
                                            r.active = false;
                                            let harvestMult = 1.0 + (this.wealth / 1000);
                                            if (r.type === 'FOOD') { 
                                                this.energy += r.config.val * harvestMult * CONFIG.foodNutritionalValue; 
                                                if (this.energy > this.maxEnergy) this.energy = this.maxEnergy;
                                                this.wealth += 1; // Food is money
                                            }
                                            if (r.type === 'STIM') { this.energy += 50; this.frenzyTimer = 300; }
                                            if (r.type === 'HERB') { this.disease = 0; this.health += 50; this.immunity = 500; sim.particles.push(new Particle(this.pos.x, this.pos.y, '#e879f9', 'spark')); }
                                            
                                            // UNIQUE RESOURCES: amplify specific gene
                                            if (r.type === 'UNIQUE') {
                                                this.energy += r.config.val * harvestMult;
                                                
                                            let canAmplifyGene = false;
                                                if (this.tribeId === r.nestId) {
                                                canAmplifyGene = true; // Same tribe
                                                } else if (this.tribeId !== -1 && r.nestId !== -1) {
                                                    let myTribe = sim.tribes.tribes[this.tribeId];
                                                    let comBond = myTribe.commercialBonds[r.nestId] || 0;
                                                let dipBond = myTribe.diplomaticBonds[r.nestId] || 0;
                                                if (comBond > 30 || dipBond > 30) {
                                                    canAmplifyGene = true; // Strong ally
                                                    }
                                                }
                                                
                                            if (canAmplifyGene && r.geneBoost && this.dna[r.geneBoost] !== undefined) {
                                                    // Amplify the specific gene
                                                    let boost = 0.05; // 5% boost
                                                    this.dna[r.geneBoost] = Math.min(1.0, this.dna[r.geneBoost] + boost);
                                                    sim.particles.push(new Particle(this.pos.x, this.pos.y, r.config.color, 'spark'));
                                                }
                                            }
                                        } else if (hunger > 0.5) {
                                             r.active = false; this.energy += r.config.val * CONFIG.foodNutritionalValue;
                                        }
                                    }
                                }
                            }
                        }

                        if (r.active && !r.carrier && (r.type === 'FOOD' || r.type === 'UNIQUE')) {
                             let weight = 100 / (d*d); 
                             // Botanists are strongly attracted to food areas to cultivate them
                             if (this.role === 'Botanist' && r.type === 'FOOD') {
                                 weight *= 2.0; // Botanists prioritize food areas
                             }
                             // UNIQUE resources are extra attractive for tribe members or commercial partners
                             if (r.type === 'UNIQUE') {
                                 if (this.tribeId === r.nestId) {
                                     weight *= 1.5; // Same tribe bonus
                                 } else if (this.tribeId !== -1 && r.nestId !== -1) {
                                     let myTribe = sim.tribes.tribes[this.tribeId];
                                     let comBond = myTribe.commercialBonds[r.nestId] || 0;
                                     if (comBond > 30) {
                                         weight *= 1.3; // Commercial bond bonus
                                     }
                                 }
                             }
                             let dir = Vector.sub(r.pos, this.pos).normalize().mult(weight);
                             foodScent.add(dir); foodCount++;
                        }
                        if (r.active && !r.carrier && r.type === 'MAT' && this.role === 'Builder') {
                            let weight = 200 / (d*d);
                             let dir = Vector.sub(r.pos, this.pos).normalize().mult(weight);
                             forces.food.add(dir); 
                             foodCount++;
                        }
                    }
                }

                if (foodCount > 0 && !this.carrying && this.role !== 'Miner' && this.role !== 'Raider' && this.role !== 'Merchant' && this.isAdult()) {
                    forces.food = foodScent.normalize().mult(this.maxSpeed * (hunger * 3 + 0.5));
                    if (forces.food.mag() > 0.1) { this.state = "Foraging"; active = true; }
                }

                // BASE RETURN & BUILDING
                if (this.carrying && this.state !== "Trading") {
                    // Builders skip generic return if they are in Build Mode
                    if (this.role === 'Builder' && this.carrying.type === 'MAT' && myNest) {
                        // Already handled in Builder Block above
                    } else {
                        this.state = "Returning"; active = true;
                        if (myNest) {
                            forces.base = this.seek(myNest.pos).mult(2.0);
                            if (distToNest < this.radius + myNest.radius + 20) {
                                // Deposit at nest - ALL RESOURCE TYPES CONVERT TO WEALTH
                                // Use the new value scale for proper conversion
                                let resourceType = this.carrying.type;
                                let resourceValue = weightedResourceEnergy(resourceType) || 30; // Get value from scale
                                
                                // Convert resource value to wealth (scaled appropriately)
                                let val = resourceValue; // Base value from scale
                                
                                // Special multipliers for certain resource types
                                if (resourceType === 'TREASURE') {
                                    val = resourceValue * 0.5; // Treasure: 200 * 0.5 = 100 wealth
                                } else if (resourceType === 'RELIC') {
                                    val = resourceValue * 0.5; // Relic: 120 * 0.5 = 60 wealth
                                } else if (resourceType === 'UNIQUE') {
                                    val = resourceValue * 0.4; // Unique: 150 * 0.4 = 60 wealth
                                } else if (resourceType === 'ORE') {
                                    val = resourceValue * 0.375; // Ore: 80 * 0.375 = 30 wealth
                                } else if (resourceType === 'HERB') {
                                    val = resourceValue * 0.25; // Herb: 60 * 0.25 = 15 wealth
                                } else if (resourceType === 'STIM') {
                                    val = resourceValue * 0.2; // Stim: 50 * 0.2 = 10 wealth
                                } else if (resourceType === 'MAT') {
                                    val = resourceValue * 0.25; // Mat: 40 * 0.25 = 10 wealth
                                } else if (resourceType === 'FOOD') {
                                    val = resourceValue * 0.2; // Food: 25 * 0.2 = 5 wealth
                                } else if (resourceType === 'SEED') {
                                    val = resourceValue * 0.2; // Seed: 30 * 0.2 = 6 wealth
                                }
                                    
                                    // Raiders deposit 10x value
                                    if (this.role === 'Raider') val *= 10;

                                    let taxRate = CONFIG.tribalTaxRate;
                                if (this.isGroupEntity && CONFIG.groupAgentTaxPremium) {
                                    taxRate = Math.min(0.95, taxRate + CONFIG.groupAgentTaxPremium);
                                }
                                    this.wealth += val * (1 - taxRate); // Keep portion after tax
                                    myNest.wealth += val * taxRate; // Tax to nest
                                
                                // Also call giveNestWealth for proper conversion tracking
                                giveNestWealth(this.tribeId, resourceType, this.carrying);
                                
                                    this.carrying.active = false;
                                    this.carrying = null;
                                    sim.particles.push(new Particle(myNest.pos.x, myNest.pos.y, '#fbbf24', 'spark'));
                            }
                        } else {
                             if (this.carrying.type === 'MAT') this.home = this.pos.copy();
                        }
                    }
                }

                // KIN HELPING BEHAVIOR
                for(let kin of localAgents) {
                    if (this.kin.includes(kin.id) && !kin.dead) {
                        let d = Vector.dist(this.pos, kin.pos);
                        
                        // Help injured kin (especially children)
                        if (kin.health < kin.maxHealth * 0.5 && d < this.senseRad * 0.6) {
                            forces.social.add(this.seek(kin.pos).mult(1.5));
                            this.state = "Helping Kin";
                            active = true;
                            
                            if (d < this.radius + kin.radius + 10) {
                                // Transfer health/energy
                                if (this.health > this.maxHealth * 0.6 && kin.health < kin.maxHealth * 0.8) {
                                    let transfer = Math.min(2, this.health * 0.05);
                                    this.health -= transfer;
                                    kin.health += transfer;
                                    if (Math.random() < 0.1) {
                                        sim.particles.push(new Particle(kin.pos.x, kin.pos.y, '#10b981', 'plus'));
                                        sim.particles.push(new Particle(kin.pos.x, kin.pos.y, '#6ee7b7', 'ring'));
                                        // Vary heal tone
                                        let healNotes = [HARMONICS.C5, HARMONICS.D5, HARMONICS.E5, HARMONICS.G5];
                                        sfx.play('heal', getHarmonicFreq(healNotes, 5), 0.12);
                                    }
                                }
                                if (this.energy > this.maxEnergy * 0.6 && kin.energy < kin.maxEnergy * 0.5) {
                                    let transfer = Math.min(3, this.energy * 0.05);
                                    this.energy -= transfer;
                                    kin.energy += transfer;
                                }
                            }
                        }
                        
                        // Extra help for children of kin
                        if (!kin.isAdult() && d < this.senseRad * 0.5) {
                            if (this.carrying && this.carrying.type === 'FOOD' && kin.energy < kin.maxEnergy * 0.7) {
                                if (d < this.radius + kin.radius + 10) {
                                    // Give food to child kin
                                    kin.energy += this.carrying.config.val * CONFIG.foodNutritionalValue;
                                    this.carrying.active = false;
                                    this.carrying = null;
                                    sim.particles.push(new Particle(kin.pos.x, kin.pos.y, '#4ade80', 'spark'));
                                    // Vary eat tone
                                    let eatNotes = [HARMONICS.A4, HARMONICS.C5, HARMONICS.D5, HARMONICS.E5];
                                    sfx.play('eat', getHarmonicFreq(eatNotes, 5), 0.08);
                                }
                            }
                        }
                    }
                }

                // SOCIAL
                let alignment = new Vector(0,0);
                let cohesion = new Vector(0,0);
                let socialCount = 0;

                for (let other of localAgents) {
                    let d = Vector.dist(this.pos, other.pos);
                    let loyalty = this.getNetLoyalty(other);
                    let isLover = loyalty > CONFIG.loveThreshold;
                    let isHater = loyalty < CONFIG.hateThreshold;
                    let isKin = this.kin.includes(other.id); // FIX: should check kin array not tribe
                    let isSameTribe = (this.tribeId !== -1) && (this.tribeId === other.tribeId);
                    
                    // PREDATOR AGGRESSION - ONLY AGAINST DIFFERENT TRIBES OR UNAFFILIATED
                    
                    // 1. BRIBERY
                    if (isLover && other.getNetLoyalty(this) < CONFIG.loveThreshold && this.energy > 60 && d < 50 && this.isAdult() && other.isAdult()) {
                        this.energy -= 5;
                        other.energy += 5;
                        other.adjustLoyalty(this.id, 3); 
                        this.state = "Bribing";
                        active = true;
                        // Self-limiting: Only create particle if particle count is reasonable
                        if (Math.random() < 0.1 && sim.particles && sim.particles.length < 150) {
                            sim.particles.push(new Particle(other.pos.x, other.pos.y, '#f472b6', 'heart'));
                        }
                    }

                    // 2. JEALOUSY - attack rivals and their children
                    if (isLover) {
                        for(let rivalId in other.loyalty) {
                            if (other.loyalty[rivalId] > CONFIG.loveThreshold && rivalId !== this.id) {
                                let rival = localAgents.find(a => a.id === rivalId);
                                if (rival && rival !== this) {
                                    // Check if rival is in my bonded group
                                    let rivalInGroup = this.partners.includes(rival);
                                    if (!rivalInGroup) {
                                        for (let p of this.partners) {
                                            if (!p.dead && p.partners.includes(rival)) {
                                                rivalInGroup = true;
                                                break;
                                            }
                                        }
                                    }
                                    
                                    // Only attack if not in bonded group
                                    if (!rivalInGroup) {
                                    this.adjustLoyalty(rival.id, -5);
                                    forces.hunt.add(this.seek(rival.pos).mult(2.5));
                                    this.state = "Jealous";
                                    active = true;
                                    this.targetId = rival.id;
                                        
                                        // Attack the rival directly
                                    if (Vector.dist(this.pos, rival.pos) < this.radius + rival.radius + 5) {
                                            let myGroupBenefits = this.getGroupBenefits();
                                            let rivalGroupBenefits = rival.getGroupBenefits();
                                            let damage = CONFIG.damageRate * 100 * myGroupBenefits.damageBonus / rivalGroupBenefits.defenseBonus;
                                            // Apply hunt bonus and shield bonus
                                            damage *= this.huntBonus;
                                            damage *= (1 - rival.shieldBonus);
                                            // SPY WEAKNESS: Spies weaken attack of non-tribe agents near them
                                            damage *= this.getSpyWeaknessMultiplier();
                                            // Agents inside nests are 1.5x harder to kill
                                            damage = rival.isInsideNest() ? damage / 1.5 : damage;
                                            rival.health -= damage;
                                            markLeaderUnderAttack(rival, this);
                                        sim.particles.push(new Particle(rival.pos.x, rival.pos.y, '#ef4444', 'spark'));
                                            sfx.play('jealousy', 350, 0.15);
                                        }
                                        
                                        // ALSO attack children of rival and my lover
                                        for (let child of localAgents) {
                                            if (child.kin.includes(rival.id) && child.kin.includes(other.id) && !child.isAdult()) {
                                                let dChild = Vector.dist(this.pos, child.pos);
                                                if (dChild < this.senseRad * 0.7) {
                                                    forces.hunt.add(this.seek(child.pos).mult(2.0));
                                                    this.state = "Jealous Rage";
                                                    if (dChild < this.radius + child.radius + 5) {
                                                        let damage = CONFIG.damageRate * 150; // Extra vicious
                                                        // SPY WEAKNESS: Spies weaken attack of non-tribe agents near them
                                                        damage *= this.getSpyWeaknessMultiplier();
                                                        // Agents inside nests are 1.5x harder to kill
                                                        damage = child.isInsideNest() ? damage / 1.5 : damage;
                                                        child.health -= damage;
                                                    markLeaderUnderAttack(child, this);
                                                        sim.particles.push(new Particle(child.pos.x, child.pos.y, '#dc2626', 'spark'));
                                                        // Sound handled by throttled system in update() - no direct call here
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }

                    // Check if other is in my bonded group (direct partner or partner's partner)
                    let isInBondedGroup = false;
                    if (this.partners.includes(other)) {
                        isInBondedGroup = true;
                    } else {
                        // Check if other is bonded to any of my partners
                        for (let p of this.partners) {
                            if (!p.dead && p.partners.includes(other)) {
                                isInBondedGroup = true;
                                break;
                            }
                        }
                    }

                    amPredator = Math.abs(this.dna.predator_target - other.dna.prey_signal) < CONFIG.predationRange;
                    amPrey = Math.abs(other.dna.predator_target - this.dna.prey_signal) < CONFIG.predationRange;

                    // Predator logic - only if NOT same tribe and NOT in bonded group
                    if (amPredator && !isSameTribe && !isInBondedGroup) {
                        forces.hunt.add(this.seek(other.pos).mult(2.0));
                        this.state = "Hunting"; active = true;
                        if (d < this.radius + other.radius + 5) {
                            let myGroupBenefits = this.getGroupBenefits();
                            let otherGroupBenefits = other.getGroupBenefits();
                            let damage = (CONFIG.damageRate * 200) * myGroupBenefits.damageBonus / otherGroupBenefits.defenseBonus;
                            // Apply hunt bonus and shield bonus
                            damage *= this.huntBonus;
                            damage *= (1 - other.shieldBonus);
                            // SPY WEAKNESS: Spies weaken attack of non-tribe agents near them
                            damage *= this.getSpyWeaknessMultiplier();
                            // Agents inside nests are 1.5x harder to kill
                            damage = other.isInsideNest() ? damage / 1.5 : damage;
                            other.health -= damage; this.energy += 20;
                            markLeaderUnderAttack(other, this);
                            if(this.energy > this.maxEnergy) this.energy = this.maxEnergy;
                            
                            // BLOODY PARTICLE SCATTER EFFECTS - Reduced for performance during intense battles
                            // Only create particles if particle count is reasonable
                            if (sim.particles.length < 200) {
                                let particleCount = Math.min(2, 1 + Math.floor(damage / 10)); // Reduced: max 2 particles, scaled by damage
                                for (let i = 0; i < particleCount; i++) {
                                    let angle = Math.random() * Math.PI * 2;
                                    let dist = Math.random() * 15;
                                    let particleX = other.pos.x + Math.cos(angle) * dist;
                                    let particleY = other.pos.y + Math.sin(angle) * dist;
                                    // Blood particles - red variations with slight scatter
                                    let bloodColors = ['#dc2626', '#b91c1c', '#991b1b', '#ef4444'];
                                    let bloodColor = bloodColors[Math.floor(Math.random() * bloodColors.length)];
                                    sim.particles.push(new Particle(particleX, particleY, bloodColor, 'spark'));
                                }
                            sim.particles.push(new Particle(other.pos.x, other.pos.y, '#ef4444', 'spark'));
                            }
                            
                            // BATTLE SOUND - Track combat state and play every 10 frames during combat
                            this.inCombat = true;
                            this.lastCombatFrame = (typeof sim !== 'undefined' && sim.frame) ? sim.frame : 0;
                            
                            if(other.health <= 0) this.kills++;
                        }
                    } else if (amPrey && !isSameTribe && !isInBondedGroup) {
                        forces.flee.add(this.flee(other.pos).mult(2.0));
                        this.state = "Fleeing"; active = true;
                    }

                    // Bonding - Priority based: kin > lovers > same tribe > neutral tribes > no hate
                    let isBonded = this.partners.includes(other);
                    let isMonster = this.role === 'Monster';
                    let otherMonster = other.role === 'Monster';
                    
                    // Nest-tethered bonding penalty
                    let amStationary = this.role === 'Guardian' || (this.tribeId !== -1 && sim.tribes.tribes[this.tribeId].leaderId === this.id);
                    let otherStationary = other.role === 'Guardian' || (other.tribeId !== -1 && sim.tribes.tribes[other.tribeId].leaderId === other.id);
                    let nestBondPenalty = 1.0;
                    // Apply penalty if one is stationary and the other is not
                    if ((amStationary && !otherStationary) || (!amStationary && otherStationary)) {
                        nestBondPenalty = CONFIG.nestBondedPenalty;
                    }

                    // Monster Bonding Logic (Only with other Monsters)
                    if (isMonster) {
                        if (otherMonster && !isBonded && d < this.radius + other.radius + 20 && this.partners.length < 3) {
                             this.addPartner(other);
                             other.addPartner(this);
                             sim.particles.push(new Particle(this.pos.x, this.pos.y, '#8b5cf6', 'spark'));
                             // Bonding sound - keep this one as it's not high-intensity mating
                        }
                    } 
                    // Normal Bonding - Priority system
                    // BUILDERS CANNOT BOND - They must focus only on building
                    else if (!isBonded && this.role !== 'Builder' && other.role !== 'Builder' && d < this.radius + other.radius + 10 && this.partners.length < this.maxBonds && other.partners.length < other.maxBonds && !otherMonster) {
                        // Check if bonding is allowed based on priority rules
                        let canBond = false;
                        let bondPriority = 0;
                        
                        // 1. Kin - highest priority
                        if (isKin) {
                            canBond = true;
                            bondPriority = 5.0;
                        }
                        // 2. Lovers - high priority
                        else if (loyalty > CONFIG.loveThreshold) {
                            canBond = true;
                            bondPriority = 4.0;
                        }
                        // 3. Same tribe - medium-high priority
                        else if (this.tribeId !== -1 && this.tribeId === other.tribeId) {
                            canBond = true;
                            bondPriority = 3.0;
                        }
                        // 4. Neutral/friendly tribes (not at war) - medium priority
                        else if (this.tribeId !== -1 && other.tribeId !== -1 && this.tribeId !== other.tribeId) {
                            let tribalRelation = sim.tribes.getOpinion(this.tribeId, other.tribeId);
                            if (tribalRelation >= CONFIG.hateThreshold) { // Not at war
                                canBond = true;
                                bondPriority = 2.0;
                            }
                        }
                        // 5. No personal hate - low priority
                        else if (loyalty >= CONFIG.hateThreshold) {
                            canBond = true;
                            bondPriority = 1.0;
                        }
                        
                        if (canBond) {
                            let sameRole = this.role === other.role;
                            let bondChance = sameRole ? 0.005 : 0.05; 
                            bondChance *= bondPriority; // Apply priority multiplier
                            
                            let dnaDiff = Math.abs(this.dna.aggression - other.dna.aggression) + Math.abs(this.dna.speed - other.dna.speed);
                            if (dnaDiff > 0.5) bondChance *= 2.0; 
                            
                            // Rigid bond gene bonus: additive effect makes bonds form easier
                            let avgRigidPref = (this.dna.rigid_bond_preference + other.dna.rigid_bond_preference) / 2;
                            let rigidBonus = 1.0 + (avgRigidPref * CONFIG.rigidBondFormationBonus);
                            bondChance *= rigidBonus;
                            
                            // Apply nest-tethered penalty
                            bondChance *= nestBondPenalty;
                            
                            if (Math.random() < bondChance * CONFIG.bondingRate) {
                                this.addPartner(other);
                                other.addPartner(this);
                                // Visual effect: different color for rigid bonds
                                let willBeRigid = this.rigidBonds[other.id];
                                let color = willBeRigid ? '#ff6b6b' : '#ffffff';
                                sim.particles.push(new Particle(this.pos.x, this.pos.y, color, 'spark'));
                                // Bonding sound - keep this one as it's not high-intensity mating (just bond formation)
                            }
                        }
                    }

                    if (d < 20) {
                        if (this.disease > 0 && other.disease === 0 && other.immunity === 0) {
                            if (Math.random() < CONFIG.diseaseSpreadProb) other.disease = 500; 
                        }
                    }

                    if (isHater) {
                        for (let friend of localAgents) {
                            if (this.getNetLoyalty(friend) > 50 && friend !== other) friend.adjustLoyalty(other.id, -0.5);
                        }
                    }

                    // War (Only different tribes, not in bonded group)
                    // BUILDERS DON'T ATTACK - They focus only on building
                    let isEnemy = isHater;
                    let sizeAdvantage = this.dna.size > other.dna.size;
                    let huntScore = (this.dna.aggression * this.prefs.hunt);
                    if (this.dna.defending > 0.5 && myNest && Vector.dist(this.pos, myNest.pos) < 100) huntScore += 2.0; 
                    if (this.role === 'Soldier') huntScore += 0.5;
                    if (isHater) huntScore += 3.0; 

                    // Check diplomatic relations - tribes with diplomatic bonds cannot attack unless also at war
                    let hasDiplomaticRelation = false;
                    let isAtWar = false;
                    if (this.tribeId !== -1 && other.tribeId !== -1 && this.tribeId !== other.tribeId && typeof sim !== 'undefined' && sim.tribes) {
                        let myTribe = sim.tribes.tribes[this.tribeId];
                        let theirTribe = sim.tribes.tribes[other.tribeId];
                        if (myTribe && theirTribe) {
                            // Check if tribes have diplomatic bonds
                            let dipBond = myTribe.diplomaticBonds[other.tribeId] || 0;
                            hasDiplomaticRelation = dipBond > 5; // Has diplomatic relation if bond > 5
                            
                            // Check if tribes are at war
                            isAtWar = (myTribe.atWarWith && myTribe.atWarWith[other.tribeId] === true) ||
                                      (theirTribe.atWarWith && theirTribe.atWarWith[this.tribeId] === true);
                        }
                    }

                    // CRITICAL: Same tribe agents NEVER attack each other - tribes cannot harm their own members
                    // CRITICAL: Tribes with diplomatic relations cannot attack unless also at war
                    // BUILDERS DON'T ATTACK - They focus only on building
                    // MERCHANTS DON'T ATTACK - They focus on trade
                    // SCIENTISTS/TECHNOLOGISTS DON'T ATTACK - They focus on research
                    // FARMERS ONLY ATTACK PREDATORS AND RAIDERS - They protect their livestock
                    let canAttack = this.role !== 'Builder' && 
                                   this.role !== 'Merchant' && 
                                   this.role !== 'Scientist' && 
                                   this.role !== 'Technologist' &&
                                   !amPredator && !amPrey && isEnemy && huntScore > 1.0 && 
                                   sizeAdvantage && other.role !== 'Monster' && !isSameTribe && !isInBondedGroup;
                    
                    // FARMERS ONLY ATTACK PREDATORS AND RAIDERS
                    if (this.role === 'Farmer') {
                        canAttack = (other.isPredator || other.role === 'Raider') && isEnemy && !isSameTribe && !isInBondedGroup;
                    }
                    
                    // Prevent attack if has diplomatic relation and not at war
                    if (canAttack && hasDiplomaticRelation && !isAtWar) {
                        canAttack = false;
                    }
                    
                    if (canAttack) {
                         forces.hunt.add(this.seek(other.pos).mult(huntScore));
                         active = true; this.state = "War";
                         this.targetId = other.id;
                         if (d < this.radius + other.radius + 5) {
                             let myGroupBenefits = this.getGroupBenefits();
                             let otherGroupBenefits = other.getGroupBenefits();
                             let shield = other.skills.SHIELD || 0;
                             let dmg = (CONFIG.damageRate * 100) * myGroupBenefits.damageBonus / otherGroupBenefits.defenseBonus;
                             // Apply hunt bonus and shield bonus
                             dmg *= this.huntBonus;
                             dmg *= (1 - other.shieldBonus);
                             // SPY WEAKNESS: Spies weaken attack of non-tribe agents near them
                             dmg *= this.getSpyWeaknessMultiplier();
                             dmg = Math.max(1, dmg - shield); 
                             other.health -= dmg;
                             
                             // BLOODY PARTICLE SCATTER EFFECTS - Reduced for performance during intense battles
                             // Only create particles if particle count is reasonable
                             if (sim.particles.length < 200) {
                                 let particleCount = Math.min(2, 1 + Math.floor(dmg / 10)); // Reduced: max 2 particles, scaled by damage
                                 for (let i = 0; i < particleCount; i++) {
                                     let angle = Math.random() * Math.PI * 2;
                                     let dist = Math.random() * 15;
                                     let particleX = other.pos.x + Math.cos(angle) * dist;
                                     let particleY = other.pos.y + Math.sin(angle) * dist;
                                     // Blood particles - red variations with slight scatter
                                     let bloodColors = ['#dc2626', '#b91c1c', '#991b1b', '#ef4444'];
                                     let bloodColor = bloodColors[Math.floor(Math.random() * bloodColors.length)];
                                     sim.particles.push(new Particle(particleX, particleY, bloodColor, 'spark'));
                                 }
                             sim.particles.push(new Particle(other.pos.x, other.pos.y, '#ef4444', 'spark'));
                             }
                             
                             // BATTLE SOUND - Track combat state and play every 10 frames during combat
                             this.inCombat = true;
                             this.lastCombatFrame = (typeof sim !== 'undefined' && sim.frame) ? sim.frame : 0;
                             
                             this.adjustLoyalty(other.id, -50);
                             if(!isKin && this.tribeId!==-1 && other.tribeId!==-1) {
                                 sim.tribes.updateOpinion(other.tribeId, this.tribeId, -1.0);
                             }
                             if(other.health<=0) { 
                                 this.kills++; 
                                 this.energy += 50; 
                                 this.wealth += other.wealth; // Loot
                                 other.wealth = 0;
                             }
                         }
                    } else if (this.role === 'Diplomat' && this.energy > 50 && !isSameTribe) {
                        // Diplomat Pacification and Diplomacy
                        forces.social = this.seek(other.pos).mult(1.5);
                        
                        if (isEnemy) {
                        this.state = "Pacifying";
                        } else if (other.tribeId !== -1) {
                            this.state = "Diplomacy";
                        }
                        
                        if (d < 30 && Math.random() < 0.05) {
                            this.energy -= 10;
                            other.adjustLoyalty(this.id, 10);
                            
                            if (other.tribeId !== -1) {
                                // Diplomats strengthen relations faster than decay (even with non-enemies) - 2X STRONGER
                                sim.tribes.updateOpinion(other.tribeId, this.tribeId, 10.0); // Doubled from 5.0
                                sim.tribes.updateOpinion(this.tribeId, other.tribeId, 10.0); // Doubled from 5.0
                                
                                // Also strengthen diplomatic bonds - 2X STRONGER
                                let myTribe = sim.tribes.tribes[this.tribeId];
                                let theirTribe = sim.tribes.tribes[other.tribeId];
                                if (myTribe && theirTribe) {
                                    myTribe.diplomaticBonds[other.tribeId] = Math.min(100, (myTribe.diplomaticBonds[other.tribeId] || 0) + 6); // Doubled from 3
                                    theirTribe.diplomaticBonds[this.tribeId] = Math.min(100, (theirTribe.diplomaticBonds[this.tribeId] || 0) + 6); // Doubled from 3
                                }
                            }
                            
                            sim.particles.push(new Particle(other.pos.x, other.pos.y, '#fde047', 'spark'));
                            // Diplomacy sound removed - was playing too frequently with varying tones
                            
                            // Recruit Unaffiliated
                            if (other.tribeId === -1 && Math.random() < 0.1) {
                                // Check for safety
                                if (sim.tribes.tribes[this.tribeId]) {
                                    other.tribeId = this.tribeId;
                                    other.color = sim.tribes.tribes[this.tribeId].color;
                                }
                            }
                        }
                    }
                    
                    // TECHNOLOGIST BEHAVIOR: Create spawn points
                    if (this.role === 'Technologist' && myNest && this.energy > 60) {
                        // Technologists create spawn points near their nest
                        let distToNest = Vector.dist(this.pos, myNest.pos);
                        if (distToNest < myNest.radius + 50 && distToNest > myNest.radius + 10) {
                            // Check if there's already a spawn point nearby (don't spam)
                            // PERFORMANCE: Only check spawn points of same tribe (smaller search space)
                            let nearbySpawnPoint = null;
                            for (let sp of sim.spawnPoints) {
                                if (sp.tribeId === this.tribeId && Vector.dist(sp.pos, this.pos) < 40) {
                                    nearbySpawnPoint = sp;
                                    break; // Found one, no need to continue
                                }
                            }
                            
                            if (!nearbySpawnPoint && Math.random() < 0.01) { // 1% chance per frame when conditions met
                                // Cost energy to tribe when creating spawn point
                                if (myNest.wealth >= 20) { // Low to moderate cost
                                    myNest.wealth -= 20;
                                    this.energy -= 30;
                                    
                                    // Create spawn point at technologist's position
                                    let spawnPoint = new SpawnPoint(this.pos.x, this.pos.y, this.tribeId);
                                    spawnPoint.nextSpawn = sim.frame + spawnPoint.spawnInterval;
                                    sim.spawnPoints.push(spawnPoint);
                                    
                                    sim.particles.push(new Particle(this.pos.x, this.pos.y, '#06b6d4', 'ring'));
                                    this.state = "Creating Spawn Point";
                                    active = true;
                                }
                            }
                        }
                    }
                    
                    // SPY BEHAVIOR: Convert agents to tribe by bonding with them
                    if (this.role === 'Spy' && this.energy > 50 && !isSameTribe && other.tribeId !== -1) {
                        // Spies seek out agents from other tribes
                        forces.social = this.seek(other.pos).mult(1.8);
                        this.state = "Infiltration";
                        active = true;
                        
                        if (d < 30 && Math.random() < 0.08) { // 8% chance per frame when close
                            this.energy -= 15;
                            
                            // Increase loyalty to spy (conversion attempt)
                            other.adjustLoyalty(this.id, 5);
                            
                            // Bond with the target agent (conversion attempt) - spies can bond with enemies
                            if (!this.partners.includes(other) && !other.partners.includes(this)) {
                                this.addPartner(other);
                                other.addPartner(this);
                                sim.particles.push(new Particle(other.pos.x, other.pos.y, '#7c3aed', 'spark')); // Purple spark
                            }
                            
                            // Convert agent to spy's tribe if bonded and loyalty is high enough
                            if (this.partners.includes(other) && other.loyalty[this.id] > 30) {
                                let oldTribeId = other.tribeId;
                                other.tribeId = this.tribeId;
                                if (sim.tribes.tribes[this.tribeId]) {
                                    other.color = sim.tribes.tribes[this.tribeId].color;
                                }
                                // Update loyalty
                                other.loyalty[this.tribeId] = 50;
                                if (oldTribeId !== -1) {
                                    other.loyalty[oldTribeId] = (other.loyalty[oldTribeId] || 0) * 0.3; // Reduce old loyalty
                                }
                                sim.particles.push(new Particle(other.pos.x, other.pos.y, '#a78bfa', 'ring')); // Light purple ring for conversion
                            }
                        }
                    }

                    if (loyalty > 20 || isKin) {
                        alignment.add(other.vel);
                        cohesion.add(other.pos);
                        socialCount++;
                        let socialWeight = 0.5;
                        if (isLover) socialWeight = 2.0; 
                        if (isKin) socialWeight += CONFIG.kinAttractionStrength; // Configurable kin attraction
                        if (isSameTribe && !isKin) socialWeight += CONFIG.tribeAttractionStrength; // Configurable tribe attraction
                        forces.social.add(this.seek(other.pos).mult(socialWeight)); 
                    }
                }
                
                if (socialCount > 0) {
                    alignment.div(socialCount).normalize().mult(this.maxSpeed).sub(this.vel).limit(this.maxForce);
                    cohesion.div(socialCount).sub(this.pos).normalize().mult(this.maxSpeed).sub(this.vel).limit(this.maxForce);
                    forces.social.add(alignment).add(cohesion).mult(this.dna.social);
                    if(!active) this.state = "Flocking";
                }

                // BUILDERS NEVER WANDER - They must stay near nest and build
                // CRITICAL: Builders should have already returned early, but double-check here
                if (!active && this.role !== 'Builder') {
                    forces.wander = this.wander().mult(0.8);
                } else if (this.role === 'Builder') {
                    // Ensure builders never get wander forces
                    forces.wander = new Vector(0, 0);
                }

                if (this.stuckCounter > 20) {
                    // BUILDERS NEVER WANDER - Even when stuck, they seek nest instead
                    if (this.role === 'Builder' && myNest) {
                        forces.base = this.seek(myNest.pos).mult(3.0);
                        this.state = "Unsticking to Nest";
                    } else {
                    forces.wander = Vector.random2D().mult(this.maxForce * 5);
                    this.state = "Unsticking";
                    }
                }

                // BUILDERS: Ensure wander force is never applied
                if (this.role === 'Builder') {
                    forces.wander = new Vector(0, 0);
                }
                
                const agentForceList = [
                    forces.base, forces.food, forces.mine,
                    forces.raid, forces.trade, forces.hunt,
                    forces.flee, forces.social, forces.wander,
                    forces.bond
                ];
                let movementForce = new Vector(0, 0);
                let contributionCount = 0;
                agentForceList.forEach(f => {
                    if (!f) return;
                    if (f.mag() < 0.001) return;
                    movementForce.add(f);
                    contributionCount++;
                });
                if (contributionCount > 0) {
                    movementForce.div(contributionCount);
                    this.applyForce(movementForce);
                }
            }

            converterInteract(resources) {
                if (!resources || resources.length === 0) return;
                let target = null;
                let range = Math.min(this.senseRad, 80);
                resources.forEach(r => {
                    if (!r.active || r.type !== this.converterSource) return;
                    let d = Vector.dist(this.pos, r.pos);
                    if (d < range) {
                        if (!target || d < Vector.dist(this.pos, target.pos)) {
                            target = r;
                        }
                    }
                });
                if (target) {
                    target.active = false;
                    let energyGain = (target.config.val || 10) * 0.8 + 15;
                    this.applyGroupEnergyGain(energyGain);
                    this.convertResourceResidue(target.type, target.pos);
                    sim.particles.push(new Particle(this.pos.x, this.pos.y, '#f97316', 'spark'));
                }
            }

            runConverterBonding(sim, agents) {
                if (!this.ownerGroupAgent || !agents || !sim) return;
                let now = sim.frame || 0;
                if (!this.lastBondAttempt) this.lastBondAttempt = -Infinity;
                if (now - this.lastBondAttempt < 220) return;
                let range = 90;
                let converters = agents.filter(a => 
                    a.isConverterUnit && !a.dead && 
                    a.converterOwner === this.ownerGroupAgent &&
                    Vector.dist(this.pos, a.pos) < range
                );
                if (converters.length >= 2) {
                    this.ownerGroupAgent.formConverterBondGroup(converters.slice(0, Math.min(converters.length, 3)), sim);
                    this.lastBondAttempt = now;
                }
            }

            // MATING CHECK
            checkMating(localAgents) {
                if (this.mateCooldown > 0 || !this.isAdult()) return;
                // Reduced energy threshold for mating - small agents need less energy to mate
                let energyThreshold = this.isGroupEntity ? 0.6 : 0.4; // Group agents need more energy
                if (this.energy < this.maxEnergy * energyThreshold) return; 
                if (this.role === 'Monster') return; // Monsters don't breed
                
                // PERFORMANCE: Self-limiting - check local density and recent births
                if (typeof sim !== 'undefined' && sim.frame) {
                    // Count nearby agents (local density check)
                    let nearbyCount = 0;
                    let densityCheckRadius = 100; // Check within 100px
                    for (let agent of localAgents) {
                        if (agent !== this && !agent.dead) {
                            let d = Vector.dist(this.pos, agent.pos);
                            if (d < densityCheckRadius) {
                                nearbyCount++;
                            }
                        }
                    }
                    
                    // If too many agents nearby, reduce mating chance significantly
                    if (nearbyCount > 15) {
                        // Very dense area - 80% reduction in mating chance
                        if (Math.random() > 0.2) return; // 80% chance to skip mating
                    } else if (nearbyCount > 10) {
                        // Dense area - 50% reduction
                        if (Math.random() > 0.5) return;
                    }
                    
                    // Check for recent births in this area (prevent sustained explosions)
                    let gridCellSize = 150; // Match spatial grid cell size
                    let cellX = Math.floor(this.pos.x / gridCellSize);
                    let cellY = Math.floor(this.pos.y / gridCellSize);
                    let cellKey = `${cellX},${cellY}`;
                    
                    // Count recent births in this cell (last 180 frames = 3 seconds)
                    let recentBirthCount = 0;
                    if (sim.recentBirths) {
                        for (let birth of sim.recentBirths) {
                            if (sim.frame - birth.frame < 180) {
                                let birthCellX = Math.floor(birth.x / gridCellSize);
                                let birthCellY = Math.floor(birth.y / gridCellSize);
                                if (birthCellX === cellX && birthCellY === cellY) {
                                    recentBirthCount++;
                                }
                            }
                        }
                    }
                    
                    // If too many recent births in this area, apply cooldown
                    if (recentBirthCount > 20) {
                        // Very high recent birth rate - 90% reduction
                        if (Math.random() > 0.1) return;
                    } else if (recentBirthCount > 10) {
                        // High recent birth rate - 70% reduction
                        if (Math.random() > 0.3) return;
                    }
                    
                    // Check cell cooldown (temporary block after explosion)
                    if (sim.matingExplosionCooldown && sim.matingExplosionCooldown[cellKey]) {
                        if (sim.matingExplosionCooldown[cellKey] > sim.frame) {
                            return; // Cell is in cooldown, skip mating
                        } else {
                            // Cooldown expired, remove it
                            delete sim.matingExplosionCooldown[cellKey];
                        }
                    }
                }

                for(let other of localAgents) {
                    if (other !== this && other.isAdult() && other.mateCooldown === 0) {
                        // Match energy threshold
                        let otherEnergyThreshold = other.isGroupEntity ? 0.6 : 0.4;
                        if (other.energy <= other.maxEnergy * otherEnergyThreshold) continue;
                        let d = Vector.dist(this.pos, other.pos);
                        if (d < this.radius + other.radius) {
                            // GARBAGE COLLECTOR MATING RESTRICTIONS
                            if (this.role === 'Garbage Collector' || other.role === 'Garbage Collector') {
                                let gcAllowedMates = ['Garbage Collector', 'Leader', 'Miner', 'Builder', 'Botanist'];
                                let canMate = gcAllowedMates.includes(this.role) && gcAllowedMates.includes(other.role);
                                if (!canMate) continue; // Skip this pairing
                            }
                            
                            let isKin = this.tribeId === other.tribeId;
                            let isSimilar = isKin || this.role === other.role;
                            let mateChance = isSimilar ? 1.0 : 0.3; 
                            
                            // GROUP SIZE AMPLIFICATION - Larger groups have higher mating rates
                            // BUT: Skip this multiplier for grazers/prey to prevent overpopulation
                            if (!this.isGrazer && !this.isPrey && !other.isGrazer && !other.isPrey) {
                                let myGroup = this.getCachedBondedGroup();
                                let otherGroup = other.getCachedBondedGroup();
                                let myGroupSize = myGroup.length;
                                let otherGroupSize = otherGroup.length;
                                let maxGroupSize = Math.max(myGroupSize, otherGroupSize);
                                
                                // Amplify mating rate based on group size
                                // Group size 2-3: 1.2x, 4-6: 1.5x, 7-10: 2.0x, 11+: 2.5x
                                let groupSizeMultiplier = 1.0;
                                if (maxGroupSize >= 11) {
                                    groupSizeMultiplier = 2.5; // Very large groups: 2.5x mating rate
                                } else if (maxGroupSize >= 7) {
                                    groupSizeMultiplier = 2.0; // Large groups: 2.0x mating rate
                                } else if (maxGroupSize >= 4) {
                                    groupSizeMultiplier = 1.5; // Medium groups: 1.5x mating rate
                                } else if (maxGroupSize >= 2) {
                                    groupSizeMultiplier = 1.2; // Small groups: 1.2x mating rate
                                }
                                // Solo agents (groupSize = 1) keep 1.0x multiplier
                                
                                // Apply group size amplification to mate chance (up to 1.0 cap)
                                mateChance *= groupSizeMultiplier;
                                mateChance = Math.min(1.0, mateChance); // Cap at 1.0
                            }
                            
                            // NEW NEST FERTILITY BOOST - 10% higher mate chance for new nests (first 1000 frames)
                            if (typeof sim !== 'undefined' && sim.tribes) {
                                let myNest = sim.tribes.nests.find(n => n.tribeId === this.tribeId);
                                let otherNest = sim.tribes.nests.find(n => n.tribeId === other.tribeId);
                                let myNestAge = myNest ? (sim.frame - myNest.creationFrame) : Infinity;
                                let otherNestAge = otherNest ? (sim.frame - otherNest.creationFrame) : Infinity;
                                // If either nest is new (< 1000 frames), boost mate chance by 10%
                                if (myNestAge < 1000 || otherNestAge < 1000) {
                                    mateChance *= 1.1;
                                    mateChance = Math.min(1.0, mateChance); // Cap at 1.0
                                }
                            }
                            
                            if (Math.random() < mateChance) {
                                // NEW NEST FERTILITY BOOST - 10% higher birth/mating rates for new nests (first 1000 frames)
                                let newNestBonus = 1.0;
                                if (typeof sim !== 'undefined' && sim.tribes) {
                                    let myNest = sim.tribes.nests.find(n => n.tribeId === this.tribeId);
                                    let otherNest = sim.tribes.nests.find(n => n.tribeId === other.tribeId);
                                    let myNestAge = myNest ? (sim.frame - myNest.creationFrame) : Infinity;
                                    let otherNestAge = otherNest ? (sim.frame - otherNest.creationFrame) : Infinity;
                                    // If either nest is new (< 1000 frames), apply 10% boost
                                    if (myNestAge < 1000 || otherNestAge < 1000) {
                                        newNestBonus = 1.1;
                                    }
                                }
                                
                                // WEALTH EFFECT ON REPRODUCTION
                                let familyWealth = this.wealth + other.wealth;
                                let wealthBonus = Math.min(0.8, familyWealth / 2000); // Up to 80% cooldown reduction
                                
                                // SIGNIFICANTLY INCREASED OFFSPRING - helps tribes grow populations and progress tech faster
                                let r = Math.random();
                                let numChildren = 5; // Base increased from 2 to 5 (2.5x increase)
                                if (r < 0.15) numChildren = 10; // Very large families
                                else if (r < 0.35) numChildren = 9;
                                else if (r < 0.55) numChildren = 8;
                                else if (r < 0.75) numChildren = 7;
                                else if (r < 0.85) numChildren = 6;

                                // Track birth location for self-limiting
                                let birthX = (this.pos.x + other.pos.x) / 2;
                                let birthY = (this.pos.y + other.pos.y) / 2;

                                for(let i=0; i<numChildren; i++) {
                                    sim.spawnChild(this, other);
                                    // Track each birth for self-limiting
                                    if (typeof sim !== 'undefined' && sim.frame && sim.recentBirths) {
                                        sim.recentBirths.push({x: birthX, y: birthY, frame: sim.frame});
                                    }
                                }
                                
                                // PERFORMANCE: If too many births, trigger cell cooldown (self-limiting)
                                if (typeof sim !== 'undefined' && sim.frame) {
                                    let gridCellSize = 150;
                                    let cellX = Math.floor(birthX / gridCellSize);
                                    let cellY = Math.floor(birthY / gridCellSize);
                                    let cellKey = `${cellX},${cellY}`;
                                    
                                    // Count recent births in this cell
                                    let recentBirthCount = 0;
                                    if (sim.recentBirths) {
                                        for (let birth of sim.recentBirths) {
                                            if (sim.frame - birth.frame < 180) {
                                                let birthCellX = Math.floor(birth.x / gridCellSize);
                                                let birthCellY = Math.floor(birth.y / gridCellSize);
                                                if (birthCellX === cellX && birthCellY === cellY) {
                                                    recentBirthCount++;
                                                }
                                            }
                                        }
                                    }
                                    
                                    // If explosion detected (>30 births in 3 seconds), add cooldown
                                    if (recentBirthCount > 30) {
                                        if (!sim.matingExplosionCooldown) sim.matingExplosionCooldown = {};
                                        sim.matingExplosionCooldown[cellKey] = sim.frame + 180; // 3 second cooldown
                                    }
                                }
                                
                                // GROUP SIZE AMPLIFICATION for birth rate (but NOT for grazers/prey)
                                let myGroup = this.getCachedBondedGroup();
                                let otherGroup = other.getCachedBondedGroup();
                                let myGroupSize = myGroup.length;
                                let otherGroupSize = otherGroup.length;
                                let maxGroupSize = Math.max(myGroupSize, otherGroupSize);
                                
                                // Apply group size multiplier to birth rate only if NOT grazers/prey
                                let groupSizeMultiplier = 1.0;
                                if (!this.isGrazer && !this.isPrey && !other.isGrazer && !other.isPrey) {
                                    // Amplify birth rate based on group size (same as mating rate)
                                    if (maxGroupSize >= 11) {
                                        groupSizeMultiplier = 2.5;
                                    } else if (maxGroupSize >= 7) {
                                        groupSizeMultiplier = 2.0;
                                    } else if (maxGroupSize >= 4) {
                                        groupSizeMultiplier = 1.5;
                                    } else if (maxGroupSize >= 2) {
                                        groupSizeMultiplier = 1.2;
                                    }
                                }
                                // Grazers/prey always use 1.0x multiplier (no group bonus)
                                
                                let effectiveBirthRate = CONFIG.birthRate * sim.dynamicBirthRateMult * newNestBonus * groupSizeMultiplier;
                                
                                // GROUP SIZE ENERGY COST REDUCTION - Larger groups have lower mating energy costs
                                
                                // Energy cost reduction based on group size:
                                // Solo (1): 0% reduction (full cost)
                                // Small groups (2-3): 20% reduction
                                // Medium groups (4-6): 40% reduction
                                // Large groups (7-10): 60% reduction
                                // Very large groups (11+): 75% reduction
                                let energyCostReduction = 0.0;
                                if (maxGroupSize >= 11) {
                                    energyCostReduction = 0.75; // 75% cost reduction for very large groups
                                } else if (maxGroupSize >= 7) {
                                    energyCostReduction = 0.60; // 60% cost reduction for large groups
                                } else if (maxGroupSize >= 4) {
                                    energyCostReduction = 0.40; // 40% cost reduction for medium groups
                                } else if (maxGroupSize >= 2) {
                                    energyCostReduction = 0.20; // 20% cost reduction for small groups
                                }
                                // Solo agents (maxGroupSize = 1) have 0% reduction (full cost)
                                
                                let mateCost = CONFIG.mateCost * (1.0 - energyCostReduction);
                                let cd = (300 / effectiveBirthRate) * (1.0 - wealthBonus); // Wealthy breed faster

                                this.energy -= mateCost; 
                                this.mateCooldown = cd; 
                                other.mateCooldown = cd;
                                other.energy -= mateCost; 
                                
                                this.adjustLoyalty(other.id, 50);
                                other.adjustLoyalty(this.id, 50);
                                
                                // LOVE PLAY - Track mating state and play sounds every 10 frames during mating
                                this.isMating = true;
                                this.lastMatingFrame = (typeof sim !== 'undefined' && sim.frame) ? sim.frame : 0;
                                
                                // VFX - Heart particles (self-limiting to prevent particle explosion)
                                // Only create particles if particle count is reasonable to prevent drawing issues
                                if (typeof sim !== 'undefined' && sim.particles && sim.particles.length < 150) {
                                sim.particles.push(new Particle(this.pos.x, this.pos.y, '#ec4899', 'heart')); 
                                    sim.particles.push(new Particle(other.pos.x, other.pos.y, '#ec4899', 'heart')); 
                                    
                                    // Additional romantic sparkles (only if particles are low)
                                    if (sim.particles.length < 100) {
                                        for (let i = 0; i < 3; i++) {
                                            let angle = (i / 3) * Math.PI * 2;
                                            let dist = 10 + Math.random() * 10;
                                            let sparkleX = (this.pos.x + other.pos.x) / 2 + Math.cos(angle) * dist;
                                            let sparkleY = (this.pos.y + other.pos.y) / 2 + Math.sin(angle) * dist;
                                            sim.particles.push(new Particle(sparkleX, sparkleY, '#f472b6', 'star')); // Pink sparkles
                                        }
                                    }
                                }
                                
                                return; 
                            }
                        }
                    }
                }
            }

            addPartner(p, bondType) {
                if (this.isNestTool || (p && p.isNestTool)) return;
                if (!p || this.partners.includes(p)) return;
                
                // BUILDERS CANNOT BOND - They must focus only on building
                if (this.role === 'Builder' || p.role === 'Builder') {
                    return; // Builders don't form bonds with anyone
                }
                
                // PREVENT ENEMY BONDS - Check if agents are enemies
                // SPIES CAN BYPASS: Spies can bond with enemies to convert them
                let isSpyBonding = (this.role === 'Spy' || p.role === 'Spy');
                if (!isSpyBonding && this.tribeId !== -1 && p.tribeId !== -1 && typeof sim !== 'undefined' && sim.tribes) {
                    let tribe1 = sim.tribes.tribes[this.tribeId];
                    let tribe2 = sim.tribes.tribes[p.tribeId];
                    if (tribe1 && tribe2) {
                        // Check if tribes are at war
                        if (tribe1.atWarWith && tribe1.atWarWith[p.tribeId] === true) {
                            return; // Cannot bond with enemies (unless spy)
                        }
                        if (tribe2.atWarWith && tribe2.atWarWith[this.tribeId] === true) {
                            return; // Cannot bond with enemies (unless spy)
                        }
                        // Check if opinion is below hate threshold
                        let opinion = sim.tribes.getOpinion(this.tribeId, p.tribeId);
                        if (opinion < (CONFIG.hateThreshold || -40)) {
                            return; // Cannot bond if opinion is too low (unless spy)
                        }
                    }
                }
                
                let groupSize = this.getBondedGroup().length;
                let withinBand = groupSize >= CONFIG.stableGroupMinMembers && groupSize <= CONFIG.stableGroupMaxMembers;
                let stabilityFraction = ((this.structureStability + (p.structureStability || 0)) / 2) / CONFIG.structureStabilityCap;
                let bandFactor = withinBand ? CONFIG.structureStabilityBandBonus : 0.65;
                let blockChance = Math.min(0.95, stabilityFraction * bandFactor);
                if (Math.random() < blockChance) return;
                    // FOOD CHAIN BONDING RESTRICTIONS
                    // Predators can only bond with predators
                    if (this.isPredator && !p.isPredator) return;
                    if (p.isPredator && !this.isPredator) return;
                    
                    // Prey can only bond with prey or farmers
                    if (this.isPrey && !(p.isPrey || p.role === 'Farmer')) return;
                    if (p.isPrey && !(this.isPrey || this.role === 'Farmer')) return;
                    
                    // Garbage Collectors can only bond with other GCs
                    if (this.role === 'Garbage Collector' && p.role !== 'Garbage Collector') return;
                    if (p.role === 'Garbage Collector' && this.role !== 'Garbage Collector') return;
                    
                    // SOLDIER BONDING RULES
                    // Soldiers bond ONLY with soldiers from same or allied tribes, and with diplomats/merchants from same tribe
                    if (this.role === 'Soldier') {
                        if (p.role === 'Soldier') {
                            // Can bond with soldiers from same or allied tribes
                            let relation = this.tribeId === p.tribeId ? 100 : (typeof sim !== 'undefined' ? sim.tribes.getOpinion(this.tribeId, p.tribeId) : 0);
                            if (relation < 20) return; // Only bond if allied (relation >= 20)
                        } else if (p.role === 'Diplomat' || p.role === 'Merchant') {
                            // Can bond with diplomats/merchants from SAME TRIBE ONLY (to protect them)
                            if (this.tribeId !== p.tribeId) return;
                        } else {
                            // Don't bond with other roles from other tribes
                            if (this.tribeId !== p.tribeId) return;
                        }
                    }
                    
                    // Mirror for partner being soldier
                    if (p.role === 'Soldier') {
                        if (this.role === 'Soldier') {
                            let relation = this.tribeId === p.tribeId ? 100 : (typeof sim !== 'undefined' ? sim.tribes.getOpinion(this.tribeId, p.tribeId) : 0);
                            if (relation < 20) return;
                        } else if (this.role === 'Diplomat' || this.role === 'Merchant') {
                            if (this.tribeId !== p.tribeId) return;
                        } else {
                            if (this.tribeId !== p.tribeId) return;
                        }
                    }
                    
                    // MERCHANT BONDING RULES - Only bond with diplomats, technologists, scientists, merchants, scouts
                    if (this.role === 'Merchant') {
                        let allowedRoles = ['Diplomat', 'Technologist', 'Scientist', 'Merchant', 'Scout'];
                        if (!allowedRoles.includes(p.role)) {
                            return; // Merchants only bond with specific roles
                        }
                    }
                    
                    // DIPLOMAT BONDING RULES - Only bond with merchants, soldiers, spies, technologists, scientists, scouts
                    if (this.role === 'Diplomat') {
                        let allowedRoles = ['Merchant', 'Soldier', 'Spy', 'Technologist', 'Scientist', 'Scout'];
                        if (!allowedRoles.includes(p.role)) {
                            return; // Diplomats only bond with specific roles
                        }
                    }
                    
                    // SCIENTIST/TECHNOLOGIST BONDING RULES - Only bond with each other, merchants, technologists, diplomats, teachers, botanists, spies
                    if (this.role === 'Scientist' || this.role === 'Technologist') {
                        let allowedRoles = ['Scientist', 'Technologist', 'Merchant', 'Diplomat', 'Teacher', 'Botanist', 'Spy'];
                        if (!allowedRoles.includes(p.role)) {
                            return; // Scientists/Technologists only bond with specific roles
                        }
                    }
                    
                    // Mirror rules for partner
                    if (p.role === 'Merchant') {
                        let allowedRoles = ['Diplomat', 'Technologist', 'Scientist', 'Merchant', 'Scout'];
                        if (!allowedRoles.includes(this.role)) {
                            return;
                        }
                    }
                    if (p.role === 'Diplomat') {
                        let allowedRoles = ['Merchant', 'Soldier', 'Spy', 'Technologist', 'Scientist', 'Scout'];
                        if (!allowedRoles.includes(this.role)) {
                            return;
                        }
                    }
                    if (p.role === 'Scientist' || p.role === 'Technologist') {
                        let allowedRoles = ['Scientist', 'Technologist', 'Merchant', 'Diplomat', 'Teacher', 'Botanist', 'Spy'];
                        if (!allowedRoles.includes(this.role)) {
                            return;
                        }
                    }
                    
                    this.partners.push(p);
                    // PERFORMANCE OPTIMIZATION: Invalidate cache when bonds change
                    this._invalidateGroupBenefitsCache();
                    if (p && typeof p._invalidateGroupBenefitsCache === 'function') p._invalidateGroupBenefitsCache();
                    // Invalidate cache when partner is added (but throttled during high activity)
                    this.invalidateGroupCache();
                    if (p && typeof p.invalidateGroupCache === 'function') p.invalidateGroupCache();
                this.invalidateGroupCache();
                if (typeof p.invalidateGroupCache === 'function') p.invalidateGroupCache();
                // Update group formation frame when a new partner is added (only if this is the first partner or group is newly forming)
                if (this.partners.length === 1 || !this.groupFormationFrame) {
                    this.groupFormationFrame = typeof sim !== 'undefined' ? sim.frame : 0;
                }
                if (p && (!p.groupFormationFrame || p.partners.length === 1)) {
                    p.groupFormationFrame = typeof sim !== 'undefined' ? sim.frame : 0;
                }
                    
                    // Determine if bond should be rigid and what type based on both partners' genes
                    let avgRigidPref = (this.dna.rigid_bond_preference + p.dna.rigid_bond_preference) / 2;
                    let isRigid = Math.random() < avgRigidPref; // Additive effect
                    
                    if (isRigid) {
                        // Determine rigid bond type based on combined traits
                        let rigidTypes = {
                            shield: (this.dna.defense + p.dna.defense) / 2, // Defensive pair
                            hunt: (this.dna.aggression + p.dna.aggression) / 2, // Hunting pair
                            gather: (this.dna.botany + this.dna.manufacturing + p.dna.botany + p.dna.manufacturing) / 4, // Resource pair
                            swift: (this.dna.speed + p.dna.speed) / 2 // Movement pair
                        };
                        
                        // Find strongest rigid bond type
                        let maxVal = -1;
                        let rigidType = 'shield';
                        for (let type in rigidTypes) {
                            if (rigidTypes[type] > maxVal) {
                                maxVal = rigidTypes[type];
                                rigidType = type;
                            }
                        }
                        this.rigidBonds[p.id] = rigidType;
                    } else {
                        this.rigidBonds[p.id] = null; // Elastic bond
                    }
                    
                    // Assign bond type based on genes if not specified
                    if (!bondType) {
                        // Calculate weighted preferences
                        let prefs = {
                            family: this.dna.family_bond_pref * (this.kin.includes(p.id) ? 2.0 : 0.5),
                            romantic: this.dna.romantic_bond_pref * (this.getNetLoyalty(p) > 80 ? 1.5 : 0.8),
                            mentor: this.dna.mentor_bond_pref * (Math.abs(this.generation - p.generation) > 3 ? 2.0 : 0.3),
                            alliance: this.dna.alliance_bond_pref * (this.tribeId === p.tribeId && this.tribeId !== -1 ? 1.5 : 0.5),
                            friendship: this.dna.friendship_bond_pref
                        };
                        
                        // Find bond type with highest weighted preference
                        let maxPref = -1;
                        let chosenType = 'friendship';
                        for (let type in prefs) {
                            if (prefs[type] > maxPref) {
                                maxPref = prefs[type];
                                chosenType = type;
                            }
                        }
                        bondType = chosenType;
                    }
                    this.bondTypes[p.id] = bondType;
            }
            
            removePartner(p) {
                this.partners = this.partners.filter(partner => partner !== p);
                if (p && p.id) {
                    delete this.bondTypes[p.id];
                    delete this.rigidBonds[p.id];
                }
                this.invalidateGroupCache();
                if (p && typeof p.invalidateGroupCache === 'function') p.invalidateGroupCache();
                // PERFORMANCE OPTIMIZATION: Invalidate cache when bonds change
                this._invalidateGroupBenefitsCache();
                if (p && typeof p._invalidateGroupBenefitsCache === 'function') p._invalidateGroupBenefitsCache();
            }

            breakAllBonds() {
                this.partners.forEach(p => p.removePartner(this));
                this.partners = [];
                this.bondTypes = {};
                this.rigidBonds = {};
                this.invalidateGroupCache();
                // PERFORMANCE OPTIMIZATION: Invalidate cache when bonds change
                this._invalidateGroupBenefitsCache();
            }
            
            getGroupSize() {
                return this.getBondedGroup().length;
            }

            getRigidBondCount() {
                return (this.rigidBonds ? Object.values(this.rigidBonds).filter(Boolean).length : 0);
            }

            getGroupSynergies(group) {
                let synergy = {
                    propulsion: 1,
                    gatherRange: 1,
                    sensing: 1,
                    conversion: 1,
                    combatFocus: 1,
                    defenseFocus: 1
                };
                // PERFORMANCE: Limit group size for synergy calculations
                let maxMembersForSynergy = 30;
                let membersToProcess = group.length > maxMembersForSynergy ? group.slice(0, maxMembersForSynergy) : group;
                
                membersToProcess.forEach(member => {
                    if (!member || member.dead) return;
                    switch(member.role) {
                        case 'Scout':
                        case 'Raider':
                            synergy.propulsion += 0.08;
                            break;
                        case 'Miner':
                        case 'Artisan':
                            synergy.conversion += 0.12;
                            synergy.gatherRange += 0.05;
                            break;
                        case 'Farmer':
                        case 'Botanist':
                            synergy.gatherRange += 0.1;
                            break;
                        case 'Guardian':
                            synergy.defenseFocus += 0.12;
                            break;
                        case 'Soldier':
                            synergy.combatFocus += 0.15;
                            break;
                        case 'Teacher':
                        case 'Scientist':
                            synergy.sensing += 0.1;
                            break;
                        case 'Diplomat':
                        case 'Merchant':
                            synergy.conversion += 0.08;
                            synergy.sensing += 0.05;
                            break;
                    }
                });
                return synergy;
            }
            
            getGroupStrength(group) {
                group = group || this.getCachedBondedGroup();
                // PERFORMANCE: For large groups, use approximate calculation
                if (group.length > 30) {
                    // Sample-based calculation for large groups
                    let sampleSize = Math.min(30, group.length);
                    let sample = group.slice(0, sampleSize);
                    let avgStrength = 0;
                    let count = 0;
                    for (let member of sample) {
                        if (!member || member.dead) continue;
                        avgStrength += member.health + member.energy + (member.structureStability || 0) * 0.6 + member.radius * 2;
                        count++;
                    }
                    if (count > 0) {
                        avgStrength = avgStrength / count;
                        return avgStrength * group.length + group.length * 25;
                    }
                }
                
                let strength = 0;
                for (let member of group) {
                    if (!member || member.dead) continue;
                    strength += member.health + member.energy + (member.structureStability || 0) * 0.6 + member.radius * 2;
                }
                return strength + group.length * 25;
            }
            
            getGroupBenefits() {
                // SUPERAGENTS: Return baked-in benefits (no expensive calculations)
                if (this.isSuperAgent) {
                    // SuperAgents have all benefits already applied to their stats
                    // Return a simple benefits object based on stored multipliers
                return {
                        rangeBonus: this.superAgentMultipliers?.sensing || 1,
                        damageBonus: this.superAgentMultipliers?.combatEffectiveness || 1,
                        defenseBonus: this.superAgentMultipliers?.defenseBonus || 1,
                        healingBonus: 1 + (this.originalGroupSize || 1) * CONFIG.groupHealingBonus,
                        energyMultiplier: 1 + (this.originalGroupSize || 1) * CONFIG.groupEnergyCost,
                        propulsionBoost: this.superAgentMultipliers?.propulsionBoost || 1,
                        gatherRangeBonus: this.superAgentMultipliers?.gatherRange || 1,
                        conversionBonus: this.superAgentMultipliers?.resourceConversion || 1
                    };
                }
                
                // PERFORMANCE OPTIMIZATION: Cache group benefits for 3-5 frames to reduce expensive calculations
                if (typeof sim !== 'undefined') {
                    let cacheInterval = 3; // Cache for 3 frames
                    if (this._groupBenefitsCache && this._groupBenefitsCacheFrame !== undefined) {
                        let framesSinceCache = sim.frame - this._groupBenefitsCacheFrame;
                        if (framesSinceCache < cacheInterval) {
                            return this._groupBenefitsCache;
                        }
                    }
                }
                
                let group = this.getCachedBondedGroup();
                let groupSize = group.length;
                let synergies = this.getGroupSynergies(group);
                let rigidBonus = 1 + (this.getRigidBondCount() * 0.2);
                let benefits = {
                    rangeBonus: (1 + (groupSize * CONFIG.groupRangeBonus)) * synergies.sensing,
                    damageBonus: (1 + (groupSize * CONFIG.groupDamageBonus)) * synergies.combatFocus * rigidBonus,
                    defenseBonus: (1 + (groupSize * CONFIG.groupDefenseBonus)) * synergies.defenseFocus * rigidBonus,
                    healingBonus: 1 + (groupSize * CONFIG.groupHealingBonus),
                    energyMultiplier: 1 + (groupSize * CONFIG.groupEnergyCost),
                    propulsionBoost: 1 + synergies.propulsion,
                    gatherRangeBonus: 1 + synergies.gatherRange,
                    conversionBonus: synergies.conversion
                };
                
                // Cache the result
                if (typeof sim !== 'undefined') {
                    this._groupBenefitsCache = benefits;
                    this._groupBenefitsCacheFrame = sim.frame;
                }
                
                return benefits;
            }
            
            // PERFORMANCE OPTIMIZATION: Invalidate group benefits cache when bonds change
            _invalidateGroupBenefitsCache() {
                this._groupBenefitsCache = null;
                this._groupBenefitsCacheFrame = undefined;
            }

            attemptGroupAscension() {
                if (typeof sim === 'undefined') return;
                if (this.dead || this.isGroupEntity || this.isSuperAgent) return; // SuperAgents don't ascend again
                if (!this.structureBandActive) return;
                let group = this.getCachedBondedGroup().filter(member => member && !member.dead);
                if (group.length < CONFIG.groupAgentMinMembers || group.length > CONFIG.groupAgentMaxMembers) return;
                if (group.some(member => member.isGroupEntity)) return;
                let avgStability = group.reduce((sum, member) => sum + member.structureStability, 0) / group.length;
                if (avgStability < CONFIG.groupAgentStabilityThreshold) return;
                // Check minimum group age - group must have existed for at least groupAgentMinAge frames
                let minFormationFrame = Math.min(...group.map(m => m.groupFormationFrame || sim.frame));
                let groupAge = sim.frame - minFormationFrame;
                if (groupAge < (CONFIG.groupAgentMinAge || 2000)) return;
                if (sim.frame - this.groupAscendedFrame < CONFIG.groupAgentAscensionCooldown) return;
                if (Math.random() > CONFIG.groupAgentAscensionChance) return;
                this.promoteGroupAgent(group, sim);
            }

            promoteGroupAgent(group, sim) {
                if (!sim || group.length === 0) return;
                let center = new Vector(0, 0);
                group.forEach(member => center.add(member.pos));
                center.div(group.length);
                let aggregatedDna = this.aggregateGroupDNA(group);
                
                // CREATE SUPERAGENT: A single agent with all combined abilities, not a group entity
                // This eliminates expensive getBondedGroup() and getGroupSynergies() calls
                let superAgent = new Agent(center.x, center.y, aggregatedDna, null, this.tribeId);
                superAgent.isSuperAgent = true; // Mark as SuperAgent (not group entity)
                superAgent.originalGroupSize = group.length; // Remember size for bonuses
                
                // Calculate combined abilities from group synergies ONCE (not every frame)
                let synergies = this.calculateGroupSynergiesForSuperAgent(group);
                
                // Apply all synergies to SuperAgent stats (baked in, no recalculation needed)
                let rawRadius = Math.min(CONFIG.groupAgentBaseRadius + group.length * 3, 60);
                superAgent.baseRadius = rawRadius * 0.3;
                superAgent.radius = superAgent.baseRadius;
                superAgent.maxHealth = Math.min(100 + group.length * 12, 1400) * (synergies.defenseBonus || 1);
                superAgent.health = superAgent.maxHealth;
                superAgent.baseSpeed = Math.max(0.25, (superAgent.baseSpeed || 1) * (synergies.propulsionBoost || 1) * 0.9);
                superAgent.maxSpeed = superAgent.baseSpeed;
                superAgent.senseRad = (superAgent.senseRad || 100) * (synergies.sensing || 1);
                superAgent.maxEnergy = (superAgent.maxEnergy || 300) * (1 + group.length * 0.1);
                superAgent.energy = superAgent.maxEnergy;
                
                // Store combined capabilities (no need to recalculate)
                superAgent.superAgentCapabilities = synergies.capabilities || [];
                superAgent.superAgentMultipliers = synergies.multipliers || {};
                
                // Determine role based on group composition (most common role, or special combo)
                let roles = {};
                group.forEach(m => { roles[m.role] = (roles[m.role] || 0) + 1; });
                let mostCommonRole = Object.keys(roles).reduce((a, b) => roles[a] > roles[b] ? a : b, 'Gatherer');
                superAgent.role = mostCommonRole;
                superAgent.assignColor();
                
                // Apply role-specific bonuses from group
                if (roles.Soldier) superAgent.canShootRanged = true;
                if (roles.Raider) superAgent.isPredator = true;
                if (roles.Farmer) superAgent.isPrey = true;
                
                superAgent.structureStability = CONFIG.structureStabilityCap;
                superAgent.structureBandActive = true;
                superAgent.groupAscendedFrame = sim.frame;
                superAgent.groupAscended = true;
                let color = sim.tribes && sim.tribes.tribes[this.tribeId] ? sim.tribes.tribes[this.tribeId].color : '#fff';
                superAgent.color = color;
                
                // Remove all references to original group members - SuperAgent is independent
                group.forEach(member => {
                    member.dead = true;
                    member.breakAllBonds();
                    // Don't store references - SuperAgent doesn't need them
                });
                
                sim.agents.push(superAgent);
                superAgent.createInitialResources();
                sim.particles.push(new Particle(center.x, center.y, '#f472b6', 'star'));
                
                // GROUP AGENT FORMATION SOUND - Soft, gentle "ting" sound (pleasant, varies by group size)
                if (typeof sfx !== 'undefined' && sfx.enabled) {
                    // Vary note based on group size - larger groups get slightly higher notes
                    // Use available harmonics for pleasant tones: C4, E4, A4, C5, E5, G5
                    let groupSize = group.length;
                    let noteOptions = [HARMONICS.C4, HARMONICS.E4, HARMONICS.A4, HARMONICS.C5, HARMONICS.E5, HARMONICS.G5];
                    // Map group size to note: 2-3 = C4, 4-5 = E4, 6-7 = A4, 8-9 = C5, 10-11 = E5, 12+ = G5
                    let noteIndex = Math.min(Math.floor((groupSize - 2) / 2), noteOptions.length - 1);
                    let note = noteOptions[Math.max(0, noteIndex)];
                    // Slightly louder, still gentle
                    sfx.play('bond', note, 0.12, 0.2); // Volume 0.12, short duration (0.2s) for soft "ting"
                }
                
                this.groupAscendedFrame = sim.frame;
                this.groupAscended = true;
            }
            
            calculateGroupSynergiesForSuperAgent(group) {
                // Calculate synergies ONCE when creating SuperAgent (not every frame)
                // This is the same logic as getGroupSynergies but called only once
                let roles = {};
                let dnaAverages = {};
                let totalHealth = 0;
                let totalEnergy = 0;
                
                group.forEach(agent => {
                    if (agent.dead) return;
                    roles[agent.role] = (roles[agent.role] || 0) + 1;
                    for (let gene in agent.dna) {
                        if (typeof agent.dna[gene] === 'number') {
                            dnaAverages[gene] = (dnaAverages[gene] || 0) + agent.dna[gene];
                        }
                    }
                    totalHealth += agent.health / agent.maxHealth;
                    totalEnergy += agent.energy / agent.maxEnergy;
                });
                
                let activeCount = group.filter(a => !a.dead).length;
                for (let gene in dnaAverages) {
                    dnaAverages[gene] /= activeCount;
                }
                
                let synergies = {
                    multipliers: {},
                    capabilities: [],
                    defenseBonus: 1,
                    propulsionBoost: 1,
                    sensing: 1
                };
                
                // Apply role synergies
                if (roles.Builder && roles.Miner) {
                    synergies.multipliers.resourceConversion = 1.3;
                    synergies.capabilities.push('construction_team');
                }
                if (roles.Soldier && roles.Diplomat) {
                    synergies.multipliers.combatEffectiveness = 1.2;
                    synergies.capabilities.push('strategic_warfare');
                }
                if (roles.Merchant && roles.Artisan) {
                    synergies.multipliers.tradeValue = 1.4;
                    synergies.capabilities.push('master_traders');
                }
                if (roles.Scientist && roles.Teacher) {
                    synergies.multipliers.techGain = 1.5;
                    synergies.capabilities.push('research_institute');
                }
                
                // Apply DNA-based bonuses
                if (dnaAverages.aggression && dnaAverages.defense) {
                    let combatPower = (dnaAverages.aggression + dnaAverages.defense) / 2;
                    synergies.defenseBonus = 1 + (combatPower * 0.3);
                    synergies.multipliers.combatEffectiveness = 1 + (combatPower * 0.3);
                }
                if (dnaAverages.speed) {
                    synergies.propulsionBoost = 1 + (dnaAverages.speed * 0.25);
                }
                if (dnaAverages.intelligence) {
                    synergies.sensing = 1 + (dnaAverages.intelligence * 0.2);
                }
                
                // Size bonus
                let sizeBonus = Math.min(1.3, 1 + Math.log(activeCount) * 0.15);
                for (let key in synergies.multipliers) {
                    synergies.multipliers[key] = (synergies.multipliers[key] || 1) * sizeBonus;
                }
                
                return synergies;
            }

            aggregateGroupDNA(group) {
                if (!group.length) return {};
                let sample = group[0].dna;
                let aggregated = {};
                for (let gene in sample) {
                    let value = sample[gene];
                    if (typeof value === 'number') {
                        let total = group.reduce((sum, member) => sum + (member.dna[gene] || 0), 0);
                        let avg = total / group.length;
                        avg += (Math.random() * 0.04 - 0.02);
                        aggregated[gene] = Math.max(0, Math.min(1, avg));
                    } else if (Array.isArray(value)) {
                        let source = group[Math.floor(Math.random() * group.length)].dna[gene];
                        aggregated[gene] = Array.isArray(source) ? [...source] : [...value];
                    } else {
                        aggregated[gene] = value;
                    }
                }
                return aggregated;
            }

            formConverterBondGroup(converters, sim) {
                if (!sim || !converters || converters.length < 2) return;
                converters = converters.filter(c => c && !c.dead);
                if (converters.length < 2) return;
                for (let i = 0; i < converters.length; i++) {
                    for (let j = i + 1; j < converters.length; j++) {
                        converters[i].addPartner(converters[j]);
                        converters[j].addPartner(converters[i]);
                        converters[i].rigidBonds[converters[j].id] = 'convert';
                        converters[j].rigidBonds[converters[i].id] = 'convert';
                    }
                }
                this.converterBondGroups = this.converterBondGroups.filter(g => g && g.converters && !g.converters.every(c => c.dead));
                this.converterBondGroups.push({
                    converters: converters,
                    expiry: sim.frame + 360
                });
            }

            cleanupConverterBonds(sim) {
                if (!sim || !this.converterBondGroups) return;
                let now = sim.frame || 0;
                this.converterBondGroups = this.converterBondGroups.filter(group => {
                    if (now > group.expiry) {
                        group.converters.forEach(c => {
                            if (c && !c.dead) {
                                c.breakAllBonds();
                            }
                        });
                        return false;
                    }
                    return true;
                });
            }

            attemptSpawnConverterBonder(sim) {
                if (!this.isGroupEntity || !sim) return;
                let now = sim.frame || 0;
                if (now - this.lastBonderSpawnFrame < 600) return;
                if (Math.random() < 0.3) {
                    sim.spawnConverterBonder(this);
                    this.lastBonderSpawnFrame = now;
                }
            }

            huntNearbyGroupResources(resources) {
                if (!this.isGroupEntity || !resources || resources.length === 0) return;
                let range = Math.min(CONFIG.groupCombatRange || 230, Math.max(this.radius * 1.2, 40));
                let best = null;
                let bestScore = -Infinity;
                
                // PERFORMANCE OPTIMIZATION: Use spatial grid for group entity resource hunting
                let nearbyResources = [];
                if (typeof sim !== 'undefined' && sim.spatialGrid && sim.gridCols > 0) {
                    let nearby = sim.getNearbyEntities(this.pos.x, this.pos.y, range);
                    nearbyResources = nearby.resources;
                } else {
                    // Fallback to brute force
                    nearbyResources = resources.filter(r => r.active && Vector.dist(this.pos, r.pos) < range);
                }
                
                nearbyResources.forEach(r => {
                    if (!r.active) return;
                    let d = Vector.dist(this.pos, r.pos);
                    if (d > range) return;
                    let weight = 3.0;
                    switch (r.type) {
                        // Resource gathering weights - scaled to match value scale (higher value = higher priority)
                        case 'FOOD': weight = 2.0; break;      // Lowest priority - least valuable
                        case 'SEED': weight = 2.5; break;
                        case 'MAT': weight = 3.5; break;
                        case 'STIM': weight = 4.0; break;
                        case 'HERB': weight = 4.5; break;
                        case 'ORE': weight = 5.5; break;       // High priority - valuable
                        case 'RELIC': weight = 7.0; break;     // Very high priority
                        case 'UNIQUE': weight = 8.0; break;    // Extremely high priority
                        case 'TREASURE': weight = 10.0; break; // Highest priority - super valuable
                    }
                    let score = weight - d * 0.02;
                    if (score > bestScore) {
                        bestScore = score;
                        best = r;
                    }
                });
                if (best) {
                    best.active = false;
                    this.applyGroupEnergyGain(weightedResourceEnergy(best.type));
                    sim.tribes && giveNestWealth(this.tribeId, best.type, best);
                    this.convertResourceResidue(best.type, best.pos);
                    sim.particles.push(new Particle(best.pos.x, best.pos.y, '#f59e0b', 'spark'));
                }
            }

            consumeNearbyEnemiesForEnergy(agents) {
                // DISABLED: Group agents no longer automatically eat other agents on collision
                // They must fight, bond, or ignore through normal interactions instead
                // Group agents can still gain energy/resources when enemies die through normal combat
                // but they don't automatically consume on collision
                return;
            }

            excreteResourcesOnKill(enemy) {
                if (!enemy || !sim) return;
                let dropTypes = ['FOOD', 'MAT', 'ORE'];
                if (enemy.isPredator) dropTypes.push('TREASURE');
                let type = dropTypes[Math.floor(Math.random() * dropTypes.length)];
                let value = Math.random();
                sim.spawnResource(null, enemy.pos.x + (Math.random()*20-10), enemy.pos.y + (Math.random()*20-10), type, false, this.tribeId);
            }

            applyGroupEnergyGain(amount) {
                if (!amount) return;
                this.energy = Math.min(this.maxEnergy, this.energy + amount);
                let nest = sim.tribes && sim.tribes.nests.find(n => n.tribeId === this.tribeId);
                if (nest) {
                    nest.wealth += amount * 0.25;
                }
                let tribe = sim.tribes && sim.tribes.tribes[this.tribeId];
                if (tribe) {
                    tribe.wealth = (tribe.wealth || 0) + amount * 0.15;
                }
            }

            convertResourceResidue(originalType, pos) {
                if (!originalType || typeof sim === 'undefined') return;
                if (Math.random() > 0.5) return; // only drop 50% of what consumed
                const pool = ['FOOD','MAT','ORE','HERB','TREASURE'];
                let idx = Math.floor((this.dna.resource_conversion_preference || 0) * pool.length);
                idx = idx % pool.length;
                let target = pool[idx];
                if (target === originalType) target = pool[(idx + 1) % pool.length];
                let dropPos = new Vector(pos.x + (Math.random()*6-3), pos.y + (Math.random()*6-3));
                sim.spawnResource(null, dropPos.x, dropPos.y, target, false, this.tribeId);
            }

            spawnDeathResource() {
                if (typeof sim === 'undefined') return;
                const deathDrops = [
                    { type: 'FOOD', weight: 3 },
                    { type: 'MAT', weight: 2 },
                    { type: 'ORE', weight: 1 },
                    { type: 'HERB', weight: 1 }
                ];
                let totalWeight = deathDrops.reduce((sum, drop) => sum + drop.weight, 0);
                let pick = Math.random() * totalWeight;
                let chosen = deathDrops[0];
                for (let drop of deathDrops) {
                    if (pick < drop.weight) {
                        chosen = drop;
                        break;
                    }
                    pick -= drop.weight;
                }
                let x = this.pos.x + (Math.random() * 12 - 6);
                let y = this.pos.y + (Math.random() * 12 - 6);
                sim.spawnResource(null, x, y, chosen.type, false, this.tribeId);
            }
            spawnDeathFoodBurst() {
                if (typeof sim === 'undefined') return;
                for (let i = 0; i < 4; i++) {
                    let x = this.pos.x + (Math.random() * 24 - 12);
                    let y = this.pos.y + (Math.random() * 24 - 12);
                    sim.spawnResource(null, x, y, 'FOOD', false, this.tribeId);
                }
            }

            spawnGroupAgentBabies(sim) {
                if (!this.isGroupEntity || typeof sim === 'undefined') return;
                let count = 1 + Math.floor(Math.random() * 3);
                for (let i = 0; i < count; i++) {
                    let dx = (Math.random() * 20 - 10);
                    let dy = (Math.random() * 20 - 10);
                    let dna = { ...this.dna };
                    for (let gene in dna) {
                        if (typeof dna[gene] === 'number') {
                            dna[gene] += (Math.random() * 0.2 - 0.1) * 0.3;
                            dna[gene] = Math.max(0, Math.min(1, dna[gene]));
                        }
                    }
                    let baby = new Agent(this.pos.x + dx, this.pos.y + dy, dna, null, this.tribeId);
                    baby.age = Math.random() * (CONFIG.adultAge * 0.5);
                    baby.health *= 0.5;
                    baby.maxHealth *= 0.7;
                    baby.energy = Math.min(baby.maxEnergy, baby.maxEnergy * 0.6);
                    baby.isGroupEntity = false;
                    baby.color = sim.tribes && sim.tribes.tribes[this.tribeId] ? sim.tribes.tribes[this.tribeId].color : baby.color;
                    sim.agents.push(baby);
                    baby.createInitialResources();
                }
            }

            getGroupShapeSides() {
                // PERFORMANCE OPTIMIZATION: Cache sides calculation (only changes when groupEntityLevel changes)
                if (this._cachedSides !== undefined && this._cachedSidesLevel === this.groupEntityLevel) {
                    return this._cachedSides;
                }
                this._cachedSides = 6 + Math.min(4, Math.floor((this.groupEntityLevel || 1) / 2));
                this._cachedSidesLevel = this.groupEntityLevel;
                return this._cachedSides;
            }
            
            checkMating(allAgents) {
                if (this.dead || !this.isAdult()) return;
                if (typeof sim === 'undefined') return;
                
                // PERFORMANCE OPTIMIZATION: Use spatial grid to only check nearby agents
                let nearbyAgents = [];
                let matingRange = 120; // Max distance for mating
                if (typeof sim !== 'undefined' && sim.spatialGrid && sim.gridCols > 0) {
                    let nearby = sim.getNearbyEntities(this.pos.x, this.pos.y, matingRange);
                    nearbyAgents = nearby.agents;
                } else {
                    // Fallback to brute force if spatial grid not available
                    nearbyAgents = allAgents.filter(a => 
                        a !== this && !a.dead && Vector.dist(this.pos, a.pos) < matingRange
                    );
                }
                
                // PREY REPRODUCTION - Linked to food consumption!
                if (this.isPrey) {
                    // Initialize mate cooldown
                    if (!this.mateCooldown) this.mateCooldown = 0;
                    if (this.mateCooldown > 0) {
                        this.mateCooldown--;
                        return;
                    }
                    
                    // Reproduction rate INCREASES with food eaten
                    let foodEaten = this.foodEaten || 0;
                    let baseReproRate = 0.001; // Base 0.1% per frame
                    let foodBonus = Math.min(2.0, foodEaten / 10); // Up to 2x bonus if eaten 10+ food
                    let reproRate = baseReproRate * (1 + foodBonus) * (sim.dynamicBirthRateMult || 1.0);
                    
                    if (Math.random() < reproRate) {
                        // Find nearby prey to mate with (already filtered by spatial grid)
                        let nearbyPrey = nearbyAgents.filter(a => 
                            a.isPrey && a.isAdult() &&
                            Vector.dist(this.pos, a.pos) < 100 &&
                            (!a.mateCooldown || a.mateCooldown <= 0)
                        );
                        
                        if (nearbyPrey.length > 0) {
                            let mate = nearbyPrey[Math.floor(Math.random() * nearbyPrey.length)];
                            
                            // Spawn offspring
                            let childX = (this.pos.x + mate.pos.x) / 2 + (Math.random() * 40 - 20);
                            let childY = (this.pos.y + mate.pos.y) / 2 + (Math.random() * 40 - 20);
                            
                            let childDna = this.mixDNA(this.dna, mate.dna);
                            // Calculate parent generation safely
                            let p1Gen = (typeof this.generation === 'number' && !isNaN(this.generation)) ? this.generation : 1;
                            let p2Gen = (typeof mate.generation === 'number' && !isNaN(mate.generation)) ? mate.generation : 1;
                            let child = new Agent(childX, childY, childDna, { gen: Math.max(p1Gen, p2Gen), p1: this, p2: mate }, -1);
                            child.isPrey = true;
                            child.role = 'Prey';
                            child.color = '#fde047';
                            
                            sim.agents.push(child);
                            child.createInitialResources();
                            
                            // Set cooldowns
                            this.mateCooldown = 200; // 200 frames cooldown
                            mate.mateCooldown = 200;
                            
                            // Reset food eaten counter
                            this.foodEaten = 0;
                            
                            // VFX
                            sim.particles.push(new Particle(childX, childY, '#fde047', 'star'));
                        }
                    }
                    return;
                }
                
                // PREDATOR REPRODUCTION
                if (this.isPredator) {
                    if (!this.mateCooldown) this.mateCooldown = 0;
                    if (this.mateCooldown > 0) {
                        this.mateCooldown--;
                        return;
                    }
                    
                    // Predators need high energy to reproduce
                    if (this.energy < 80) return;
                    
                    let reproRate = 0.002 * (sim.dynamicBirthRateMult || 1.0); // 0.2% per frame (4√ó increase!)
                    
                    if (Math.random() < reproRate) {
                        // Find nearby predators (already filtered by spatial grid)
                        let nearbyPredators = nearbyAgents.filter(a => 
                            a.isPredator && a.isAdult() &&
                            Vector.dist(this.pos, a.pos) < 120 &&
                            a.energy > 80 &&
                            (!a.mateCooldown || a.mateCooldown <= 0)
                        );
                        
                        if (nearbyPredators.length > 0) {
                            let mate = nearbyPredators[Math.floor(Math.random() * nearbyPredators.length)];
                            
                            let childX = (this.pos.x + mate.pos.x) / 2 + (Math.random() * 40 - 20);
                            let childY = (this.pos.y + mate.pos.y) / 2 + (Math.random() * 40 - 20);
                            
                            let childDna = this.mixDNA(this.dna, mate.dna);
                            // Calculate parent generation safely
                            let p1Gen = (typeof this.generation === 'number' && !isNaN(this.generation)) ? this.generation : 1;
                            let p2Gen = (typeof mate.generation === 'number' && !isNaN(mate.generation)) ? mate.generation : 1;
                            let child = new Agent(childX, childY, childDna, { gen: Math.max(p1Gen, p2Gen), p1: this, p2: mate }, -1);
                            child.isPredator = true;
                            child.role = 'Predator';
                            child.color = '#dc2626';
                            
                            sim.agents.push(child);
                            child.createInitialResources();
                            
                            this.mateCooldown = 300;
                            mate.mateCooldown = 300;
                            this.energy -= 30;
                            mate.energy -= 30;
                            
                            sim.particles.push(new Particle(childX, childY, '#dc2626', 'star'));
                        }
                    }
                    return;
                }
                
                // TRIBAL AGENT REPRODUCTION
                if (this.tribeId === -1) return; // Only tribal agents reproduce
                if (this.energy < 60 || this.health < 50) return; // Need health/energy
                
                // Base reproduction rate (INCREASED 5√ó for stronger tribes!)
                let baseReproRate = 0.0015 * (sim.dynamicBirthRateMult || 1.0);
                let reproductionBoost = (this.isGroupEntity) ? 1.6 : 1.0;
                let reproRate = baseReproRate * reproductionBoost;
                
                // LINKED TRIBE MATING PREFERENCE
                let linkedTribeMateBonus = 1.0;
                if (typeof sim !== 'undefined' && sim.tribes && sim.tribes.tribes[this.tribeId]) {
                    let myTribe = sim.tribes.tribes[this.tribeId];
                    // Check if any linked tribes exist
                    for (let otherId in myTribe.diplomaticBonds) {
                        if (myTribe.diplomaticBonds[otherId] > 40 || myTribe.commercialBonds[otherId] > 40) {
                            linkedTribeMateBonus = 1.5; // 50% bonus if linked tribes exist
                            break;
                        }
                    }
                }
                
                reproRate *= linkedTribeMateBonus;
                
                if (Math.random() < reproRate) {
                    // Find nearby mates (already filtered by spatial grid)
                    let potentialMates = nearbyAgents.filter(a => 
                        a.isAdult() &&
                        a.tribeId !== -1 && // Must be tribal
                        !a.isPrey && !a.isPredator && // Not food chain
                        Vector.dist(this.pos, a.pos) < 100 &&
                        a.energy > 60 && a.health > 50
                    );
                    
                    // PREFER LINKED TRIBE MATES
                    if (linkedTribeMateBonus > 1.0 && potentialMates.length > 0) {
                        let linkedMates = potentialMates.filter(a => {
                            if (a.tribeId === this.tribeId) return true; // Same tribe always OK
                            
                            let myTribe = sim.tribes.tribes[this.tribeId];
                            let dipBond = myTribe.diplomaticBonds[a.tribeId] || 0;
                            let comBond = myTribe.commercialBonds[a.tribeId] || 0;
                            
                            return dipBond > 40 || comBond > 40; // Linked tribes
                        });
                        
                        if (linkedMates.length > 0) {
                            potentialMates = linkedMates; // Prefer linked mates
                        }
                    }
                    
                    if (potentialMates.length > 0) {
                        let mate = potentialMates[Math.floor(Math.random() * potentialMates.length)];
                        
                        let childX = (this.pos.x + mate.pos.x) / 2 + (Math.random() * 40 - 20);
                        let childY = (this.pos.y + mate.pos.y) / 2 + (Math.random() * 40 - 20);
                        
                        let childDna = this.mixDNA(this.dna, mate.dna);
                        // Calculate parent generation safely
                        let p1Gen = (typeof this.generation === 'number' && !isNaN(this.generation)) ? this.generation : 1;
                        let p2Gen = (typeof mate.generation === 'number' && !isNaN(mate.generation)) ? mate.generation : 1;
                        let child = new Agent(childX, childY, childDna, { gen: Math.max(p1Gen, p2Gen), p1: this, p2: mate }, this.tribeId);
                        
                        sim.agents.push(child);
                        child.createInitialResources();
                        
                        this.energy -= 20;
                        mate.energy -= 20;
                        
                        sim.particles.push(new Particle(childX, childY, child.color, 'star'));

                    if (this.isGroupEntity || mate.isGroupEntity) {
                        let owner = this.isGroupEntity ? this : mate;
                        sim.spawnConverterAgent(owner);
                        owner.mateCooldown = Math.max(80, owner.mateCooldown * 0.4);
                        mate.mateCooldown = Math.max(80, mate.mateCooldown * 0.4);
                        owner.energy = Math.min(owner.maxEnergy, owner.energy + 20);
                    }
                    }
                }
            }
            
            mixDNA(dna1, dna2) {
                // Mix two DNA profiles with mutations
                let mixed = {};
                for (let gene in dna1) {
                    if (typeof dna1[gene] === 'number') {
                        // Average with small mutation
                        mixed[gene] = (dna1[gene] + dna2[gene]) / 2 + (Math.random() * 0.1 - 0.05);
                        mixed[gene] = Math.max(0, Math.min(1, mixed[gene])); // Clamp 0-1
                    } else if (Array.isArray(dna1[gene])) {
                        // Mix arrays (oscillation patterns)
                        mixed[gene] = dna1[gene].map((val, i) => {
                            let avg = (val + dna2[gene][i]) / 2;
                            // Mutation chance
                            if (Math.random() < 0.1) {
                                avg = Math.floor(Math.random() * 8); // Random new direction
                            }
                            return avg;
                        });
                    } else {
                        mixed[gene] = Math.random() < 0.5 ? dna1[gene] : dna2[gene];
                    }
                }
                return mixed;
            }

            applyForce(f) { this.acc.add(f); }
            seek(target) {
                let desired = Vector.sub(target, this.pos).normalize().mult(this.maxSpeed);
                return Vector.sub(desired, this.vel).limit(this.maxForce);
            }
            flee(target) {
                let desired = Vector.sub(target, this.pos).normalize().mult(this.maxSpeed * -1);
                return Vector.sub(desired, this.vel).limit(this.maxForce);
            }
            
            getMovementPatternBias(steer) {
                if (!steer || steer.mag() < 0.1 || typeof sim === 'undefined') return new Vector(0,0);
                let pattern = Math.floor(this.dna.movement_pattern || 0) % 6;
                let dir = steer.copy().normalize();
                let perp = new Vector(-dir.y, dir.x);
                let frame = sim.frame || 0;

                switch(pattern) {
                    case 0: // Wiggly favors quick perpendicular jucture
                        return perp.copy().mult(Math.sin(frame * 0.3) * 0.4);
                    case 1: // Straight
                        return new Vector(0,0);
                    case 2: // Spiral right
                        return dir.copy().rotate(0.25).sub(dir).mult(0.6);
                    case 3: // Spiral left
                        return dir.copy().rotate(-0.25).sub(dir).mult(0.6);
                    case 4: // Jagged - random direction per frame
                        return Vector.random2D().mult(0.45);
                    case 5: // Wavy - gentle curve
                        return perp.copy().mult(Math.sin(frame * 0.15) * 0.3);
                    default:
                        return new Vector(0,0);
                }
            }

            getPartnerHash() {
                let ids = this.partners
                    .filter(p => p && !p.dead)
                    .map(p => p.id);
                ids.push(this.id);
                ids.sort((a, b) => a - b);
                return ids.join(',');
            }

            updateStructureStability() {
                let hash = this.getPartnerHash();
                let group = this.getBondedGroup();
                let groupSize = group.length;
                let withinPreferredBand = groupSize >= CONFIG.stableGroupMinMembers && groupSize <= CONFIG.stableGroupMaxMembers;
                let sameHash = hash && hash === this.lastPartnerHash;
                if (sameHash) {
                    let gain = withinPreferredBand ? CONFIG.structureStabilityInsideGain : CONFIG.structureStabilityOutsideGain;
                    this.structureStability = Math.min(CONFIG.structureStabilityCap, this.structureStability + gain);
                } else {
                    let decay = withinPreferredBand ? CONFIG.structureStabilityInsideDecay : CONFIG.structureStabilityOutsideDecay;
                    this.structureStability = Math.max(0, this.structureStability - decay);
                }
                this.structureBandActive = withinPreferredBand && groupSize > 1;
                this.structureStabilityGroupSize = groupSize;
                this.lastPartnerHash = hash;
            }
            
            boundaries() {
                // TORUS MODE: No bouncing - wrapping handles boundaries
                // Position wrapping is handled in update() method before this is called
                // So we don't need to apply bounce forces here
                return;
            }

            draw(ctx, isSelected) {
                ctx.save();
                ctx.translate(this.pos.x, this.pos.y);

                // Draw Bond Line - different styles for rigid vs elastic bonds
                // PERFORMANCE: Limit bond drawing for large groups to prevent lag
                // Handle torus wrapping for bonds that cross screen edges
                let maxBondsToDraw = 20; // Limit bonds drawn per agent
                let bondsDrawn = 0;
                
                // For large groups, only draw bonds to closest partners
                let partnersToDraw = this.partners;
                if (this.partners.length > maxBondsToDraw) {
                    // Sort by distance and only draw closest bonds
                    partnersToDraw = [...this.partners]
                        .filter(p => p && !p.dead)
                        .map(p => ({
                            partner: p,
                            dist: Vector.distTorus(this.pos, p.pos, sim.width, sim.height)
                        }))
                        .sort((a, b) => a.dist - b.dist)
                        .slice(0, maxBondsToDraw)
                        .map(item => item.partner);
                }
                
                partnersToDraw.forEach(p => {
                    if (!p || p.dead || bondsDrawn >= maxBondsToDraw) return;
                    
                    // Skip drawing bonds that are very long (likely not visible)
                    let bondDist = Vector.distTorus(this.pos, p.pos, sim.width, sim.height);
                    if (bondDist > 500) return; // Skip very long bonds
                    
                    ctx.save();
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    
                    // Use toroidal shortest path for bond drawing (handles wrapping)
                    // subTorus(v1, v2) returns direction FROM v1 TO v2, which is what we need
                    let torusDir = Vector.subTorus(this.pos, p.pos, sim.width, sim.height);
                    ctx.lineTo(torusDir.x, torusDir.y);
                    
                    // Visual distinction: rigid bonds are red/orange and thicker
                    let isRigid = (this.rigidBonds && this.rigidBonds[p.id]) || false;
                    if (isRigid) {
                        ctx.strokeStyle = 'rgba(255, 107, 107, 0.8)'; // Red-orange for rigid
                        ctx.lineWidth = 3;
                    } else {
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)'; // White for elastic
                    ctx.lineWidth = 2;
                    }
                    ctx.stroke();
                    ctx.restore();
                    bondsDrawn++;
                });

                // Leader Crown
                if (this.tribeId !== -1 && sim.tribes.tribes[this.tribeId].leaderId === this.id) {
                    ctx.fillStyle = '#facc15'; 
                    ctx.beginPath();
                    ctx.moveTo(-5, -this.radius - 2);
                    ctx.lineTo(0, -this.radius - 10);
                    ctx.lineTo(5, -this.radius - 2);
                    ctx.fill();
                }

                // Draw Tribe Halo
                if (this.tribeId !== -1 && sim.tribes.tribes[this.tribeId]) {
                    ctx.strokeStyle = sim.tribes.tribes[this.tribeId].color;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(0, 0, this.radius + 3, 0, Math.PI*2);
                    ctx.stroke();
                }

                // Draw Tether (if Leader/Guardian) - SPRING LINE
                // Handle torus wrapping for tether lines that cross screen edges
                if (this.role === 'Guardian' || (this.tribeId !== -1 && sim.tribes.tribes[this.tribeId].leaderId === this.id)) {
                    let myNest = sim.tribes.nests.find(n => n.tribeId === this.tribeId);
                    if (myNest && Vector.distTorus(this.pos, myNest.pos, sim.width, sim.height) > 50) {
                        ctx.save();
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        // Use toroidal shortest path for tether drawing (handles wrapping)
                        // subTorus(v1, v2) returns direction FROM v1 TO v2, which is what we need
                        let torusDir = Vector.subTorus(this.pos, myNest.pos, sim.width, sim.height);
                        ctx.lineTo(torusDir.x, torusDir.y);
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
                        ctx.setLineDash([3, 3]); // Dashed spring line
                        ctx.lineWidth = 1;
                        ctx.stroke();
                        ctx.restore();
                    }
                }

                // Draw Selection Halo
                if (isSelected) {
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(0, 0, this.radius + 6, 0, Math.PI*2);
                    ctx.stroke();
                }

                if (this.isGroupEntity) {
                    // PERFORMANCE OPTIMIZATION: Always draw polygon groups, but use simplified version when population is high
                    // This prevents visual jitter from skipping frames while maintaining performance
                    let totalAgents = (typeof sim !== 'undefined' && sim.agents) ? sim.agents.length : 0;
                    
                    // PERFORMANCE: Cache group entity count globally (update every 30 frames)
                    let groupEntityCount = 0;
                    if (typeof sim !== 'undefined' && sim.agents) {
                        if (sim.frame - sim._lastGroupEntityCountUpdate > 30) {
                            sim._cachedGroupEntityCount = sim.agents.filter(a => a.isGroupEntity).length;
                            sim._lastGroupEntityCountUpdate = sim.frame;
                        }
                        groupEntityCount = sim._cachedGroupEntityCount;
                    }
                    
                    // Use simplified circles when population is high OR when there are many group entities
                    // This prevents jitter by always drawing but using faster rendering
                    if (totalAgents > 100 || groupEntityCount > 10) {
                        // Draw simplified version (just circles) - much faster, no jitter
                        ctx.strokeStyle = `rgba(255,255,255,0.6)`;
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
                        ctx.stroke();
                        // Inner circle for visual distinction
                        ctx.strokeStyle = `rgba(255,255,255,0.3)`;
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.arc(0, 0, this.radius * 0.6, 0, Math.PI * 2);
                        ctx.stroke();
                    } else {
                        // Draw full polygon when population is low
                        this.drawGroupPolygon(ctx);
                    }
                } else if (this.isConverterUnit) {
                    this.drawConverterShape(ctx);
                } else if (this.isConverterBonder) {
                    this.drawConverterBonderShape(ctx);
                } else {
                // Draw Body
                ctx.fillStyle = this.color;
                ctx.beginPath();
                if (this.role === 'Monster') {
                     ctx.rect(-this.radius, -this.radius, this.radius*2, this.radius*2);
                } else {
                     ctx.arc(0, 0, this.radius, 0, Math.PI*2);
                }
                ctx.fill();
                }
                
                // Disease Indicator
                if (this.disease > 0) {
                    ctx.fillStyle = '#22c55e';
                    ctx.beginPath();
                    ctx.arc(0, 0, 3, 0, Math.PI*2);
                    ctx.fill();
                }

                // Draw Carrying Item
                if (this.carrying) {
                     ctx.fillStyle = this.carrying.config.color;
                     ctx.beginPath();
                     ctx.arc(0, -this.radius, 3, 0, Math.PI*2);
                     ctx.fill();
                }

                ctx.restore();
            }

            drawGroupPolygon(ctx) {
                // PERFORMANCE OPTIMIZATION: Cache polygon vertices to avoid recalculating every frame
                let sides = this.getGroupShapeSides();
                // Round radius to nearest 0.1 to avoid floating point precision issues causing cache invalidation
                let radius = Math.round(this.radius * 10) / 10;
                let innerRadius = Math.max(radius * 0.6, radius - 6);
                
                // Cache vertices if radius or sides changed
                if (!this._cachedPolygonVertices || 
                    this._cachedPolygonRadius !== radius || 
                    this._cachedPolygonSides !== sides) {
                    // Calculate and cache outer polygon vertices
                    this._cachedPolygonVertices = [];
                    for (let i = 0; i < sides; i++) {
                        let theta = (i / sides) * Math.PI * 2;
                        this._cachedPolygonVertices.push({
                            x: Math.cos(theta) * radius,
                            y: Math.sin(theta) * radius
                        });
                    }
                    
                    // Calculate and cache inner polygon vertices
                    this._cachedInnerVertices = [];
                    for (let i = 0; i < sides; i++) {
                        let theta = ((i + 0.5) / sides) * Math.PI * 2;
                        this._cachedInnerVertices.push({
                            x: Math.cos(theta) * innerRadius,
                            y: Math.sin(theta) * innerRadius
                        });
                    }
                    
                    this._cachedPolygonRadius = radius;
                    this._cachedPolygonSides = sides;
                }
                
                // Draw outer polygon using cached vertices
                ctx.strokeStyle = `rgba(255,255,255,0.8)`;
                ctx.lineWidth = 3;
                ctx.beginPath();
                for (let i = 0; i < this._cachedPolygonVertices.length; i++) {
                    let v = this._cachedPolygonVertices[i];
                    if (i === 0) ctx.moveTo(v.x, v.y);
                    else ctx.lineTo(v.x, v.y);
                }
                ctx.closePath();
                ctx.stroke();

                // Draw inner polygon using cached vertices
                ctx.lineWidth = 2;
                ctx.beginPath();
                for (let i = 0; i < this._cachedInnerVertices.length; i++) {
                    let v = this._cachedInnerVertices[i];
                    if (i === 0) ctx.moveTo(v.x, v.y);
                    else ctx.lineTo(v.x, v.y);
                }
                ctx.closePath();
                ctx.stroke();
            }

            drawConverterShape(ctx) {
                ctx.strokeStyle = '#f97316';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(0, -this.radius);
                ctx.lineTo(this.radius * 0.8, 0);
                ctx.lineTo(0, this.radius);
                ctx.lineTo(-this.radius * 0.8, 0);
                ctx.closePath();
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(-this.radius * 0.5, 0);
                ctx.lineTo(this.radius * 0.5, 0);
                ctx.stroke();
            }

            drawConverterBonderShape(ctx) {
                ctx.strokeStyle = '#22d3ee';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(0, 0, this.radius * 0.9, 0, Math.PI * 2);
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(0, 0, this.radius * 0.5, 0, Math.PI * 2);
                ctx.stroke();
            }
        }

        /* --- SIMULATION ENGINE --- */
        class Simulation {
            constructor() {
                this.canvas = document.getElementById('simCanvas');
                this.ctx = this.canvas.getContext('2d');
                
                // PERFORMANCE OPTIMIZATION: Spatial grid for O(n) distance checks
                this.spatialGrid = null;
                this.gridCellSize = 150; // Size of each grid cell (adjust based on typical sensing range)
                this.gridCols = 0;
                this.gridRows = 0;
                
                // PERFORMANCE OPTIMIZATION: Frame time tracking for adaptive quality
                this.lastFrameTime = performance.now();
                this.frameTimeHistory = [];
                this.lastAgentCount = 0; // Track agent count for adaptive quality
                
                // Status message system for HUD updates
                this.statusMessage = null;
                this.statusMessageExpiry = 0; // Frame when status message expires
                this.avgFrameTime = 16.67; // Target: 60fps = 16.67ms
                
                // PERFORMANCE OPTIMIZATION: Staggered update configuration
                this.updateStaggerSize = 4; // Update 1/4 of agents per frame (4-frame cycle)
                this.tribes = new TribeManager(); 
                this.agents = [];
                this.resources = [];
                this.walls = [];
                this.particles = [];
                this.projectiles = [];
                this.plagues = []; // Plagues
                this.spawnPoints = []; // Spawn points created by technologists
                this.frame = 0;
                this.running = true;
                this.selected = null;
                this.dynamicBirthRateMult = 1.0; // Crisis Multiplier
                this._lastDensityBirthRateMult = 1.0; // Track previous density-based multiplier for decay
                this._densityBonusDecayRate = 0.98; // Decay rate per frame (2% reduction) - dampens bonus over time
                this.actionMode = null; // 'infect', etc.
                
                // PERFORMANCE: Track recent births by location to prevent mating explosions
                this.recentBirths = []; // Array of {x, y, frame} for births in last 180 frames (3 seconds)
                this.matingExplosionCooldown = {}; // Map of grid cell indices to cooldown frames
                
                // PERFORMANCE: Cache global counts to avoid filtering all agents every frame
                this._cachedGroupEntityCount = 0;
                this._lastGroupEntityCountUpdate = 0;
                this._cachedTribeAgentCounts = {}; // Map of tribeId -> {count, lastUpdate}
                
                // PERFORMANCE: Pre-compute active bonds to avoid O(N¬≤) loop in drawing
                this._activeBonds = []; // Array of {n1, n2, type, strength, tribe1, tribe2}
                this._lastBondUpdateFrame = -1;
                
                // PERFORMANCE: Particle throttling to prevent explosion during battles
                this._particlesCreatedThisFrame = 0;
                this._maxParticlesPerFrame = 20; // Limit particles created per frame
                
                // PERFORMANCE: Particle throttling to prevent explosion during battles
                this._particlesCreatedThisFrame = 0;
                this._maxParticlesPerFrame = 20; // Limit particles created per frame

                // CAMERA/DRAG SYSTEM - Click and drag with momentum glide
                this.cameraX = 0;
                this.cameraY = 0;
                this.cameraVelX = 0; // Camera velocity for glide effect
                this.cameraVelY = 0;
                this.isDragging = false;
                this.lastDragX = 0;
                this.lastDragY = 0;
                this.momentumDecay = 0.95; // How quickly momentum decays (0-1, higher = slower decay)
                
                // ZOOM SYSTEM
                this.zoom = 1.0; // Default zoom level (1.0 = 100%)

                // Initialize settings sliders with current config
                this.initSettings();
                
                // Setup zoom control
                this.setupZoomControl();

                this.resize();
                window.addEventListener('resize', () => this.resize());
                this.canvas.addEventListener('mousedown', (e) => this.onMouseDown(e));
                this.canvas.addEventListener('mousemove', (e) => this.onMouseMove(e));
                this.canvas.addEventListener('mouseup', (e) => this.onMouseUp(e));
                this.canvas.addEventListener('mouseleave', (e) => this.onMouseUp(e)); // Stop dragging if mouse leaves
                
                this.init();
            }

            initSettings() {
                for(let key in CONFIG) {
                    let el = document.getElementById(`in-${key}`);
                    if (el) el.value = CONFIG[key];
                    let valEl = document.getElementById(`val-${key}`);
                    if (valEl) valEl.textContent = CONFIG[key];
                }
            }

            updateConfig(key, value) {
                CONFIG[key] = parseFloat(value);
                let valEl = document.getElementById(`val-${key}`);
                if (valEl) valEl.textContent = CONFIG[key];
            }

            restoreDefaults() {
                CONFIG = { ...DEFAULT_CONFIG };
                this.initSettings();
            }

            copySettingsToClipboard() {
                const settingsText = Object.entries(CONFIG).map(([key, value]) => `${key}: ${value}`).join('\n');
                navigator.clipboard.writeText(settingsText).then(() => {
                    alert('Settings copied to clipboard!');
                }).catch(err => {
                    console.error('Failed to copy settings:', err);
                    // Fallback: create a temporary textarea
                    const textarea = document.createElement('textarea');
                    textarea.value = settingsText;
                    document.body.appendChild(textarea);
                    textarea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textarea);
                    alert('Settings copied to clipboard!');
                });
            }

            toggleSettings() {
                let modal = document.getElementById('settings-modal');
                if (modal.classList.contains('hidden')) modal.classList.remove('hidden');
                else modal.classList.add('hidden');
            }

            toggleAbout() {
                let modal = document.getElementById('about-modal');
                if (modal.classList.contains('hidden')) modal.classList.remove('hidden');
                else modal.classList.add('hidden');
            }
            
            setupZoomControl() {
                let zoomSlider = document.getElementById('zoom-slider');
                let zoomValue = document.getElementById('zoom-value');
                if (zoomSlider && zoomValue) {
                    zoomSlider.addEventListener('input', (e) => {
                        let zoom = parseFloat(e.target.value);
                        // Snap to 100% (1.0) when close (within 0.05)
                        if (Math.abs(zoom - 1.0) < 0.05) {
                            zoom = 1.0;
                            zoomSlider.value = 1.0;
                        }
                        this.zoom = zoom;
                        zoomValue.textContent = Math.round(this.zoom * 100) + '%';
                    });
                }
            }

            resize() {
                // DOUBLE WORLD SIZE: World is now 2x larger for testing performance
                this.width = window.innerWidth * 2;
                this.height = window.innerHeight * 2;
                this.canvas.width = this.width;
                this.canvas.height = this.height;
                
                // Rebuild spatial grid when canvas resizes
                this._rebuildSpatialGrid();
            }
            
            // PERFORMANCE OPTIMIZATION: Build spatial grid for efficient distance checks
            _rebuildSpatialGrid() {
                this.gridCols = Math.ceil(this.width / this.gridCellSize);
                this.gridRows = Math.ceil(this.height / this.gridCellSize);
                this.spatialGrid = {
                    agents: Array(this.gridCols * this.gridRows).fill(null).map(() => []),
                    resources: Array(this.gridCols * this.gridRows).fill(null).map(() => [])
                };
            }
            
            // PERFORMANCE OPTIMIZATION: Get grid cell index from position
            _getGridIndex(x, y) {
                let col = Math.floor(x / this.gridCellSize);
                let row = Math.floor(y / this.gridCellSize);
                col = Math.max(0, Math.min(col, this.gridCols - 1));
                row = Math.max(0, Math.min(row, this.gridRows - 1));
                return row * this.gridCols + col;
            }
            
            // PERFORMANCE OPTIMIZATION: Get nearby cells (including adjacent cells for edge cases)
            _getNearbyCellIndices(x, y, radius) {
                let indices = new Set();
                let centerCol = Math.floor(x / this.gridCellSize);
                let centerRow = Math.floor(y / this.gridCellSize);
                let cellRadius = Math.ceil(radius / this.gridCellSize) + 1; // +1 for safety
                
                for (let dr = -cellRadius; dr <= cellRadius; dr++) {
                    for (let dc = -cellRadius; dc <= cellRadius; dc++) {
                        let col = centerCol + dc;
                        let row = centerRow + dr;
                        if (col >= 0 && col < this.gridCols && row >= 0 && row < this.gridRows) {
                            indices.add(row * this.gridCols + col);
                        }
                    }
                }
                return Array.from(indices);
            }
            
            // PERFORMANCE OPTIMIZATION: Build spatial grid from current agents/resources
            // PERFORMANCE: Cleanup after war ends to recover performance
            _cleanupAfterWar() {
                // Reset frame history to allow performance recovery
                if (this.frameTimeHistory.length > 5) {
                    this.frameTimeHistory = this.frameTimeHistory.slice(-3); // Keep only last 3 frames
                }
                // Reset stagger size if it got too high during war
                if (this.updateStaggerSize > 8) {
                    this.updateStaggerSize = Math.max(4, this.updateStaggerSize - 2);
                }
            }
            
            _updateActiveBonds() {
                // Pre-compute active bonds (only bonds > threshold) to avoid O(N¬≤) in drawing loop
                this._activeBonds = [];
                
                for(let tid in this.tribes.tribes) {
                    for(let otherId in this.tribes.tribes) {
                        if (tid < otherId) { // Check each pair only once
                            let tribe1 = this.tribes.tribes[tid];
                            let tribe2 = this.tribes.tribes[otherId];
                            let n1 = this.tribes.nests.find(n => n.tribeId == tid);
                            let n2 = this.tribes.nests.find(n => n.tribeId == otherId);
                            
                            if (!n1 || !n2) continue;
                            
                            // Check for war
                            let isAtWar = (tribe1.atWarWith && tribe1.atWarWith[otherId] === true) || 
                                         (tribe2.atWarWith && tribe2.atWarWith[tid] === true);
                            
                            if (isAtWar) {
                                this._activeBonds.push({n1, n2, type: 'war', strength: 100, tribe1, tribe2});
                                continue; // War takes priority
                            }
                            
                            // Check diplomatic bond
                            let dipBond = (tribe1.diplomaticBonds && tribe1.diplomaticBonds[otherId]) || 0;
                            if (dipBond > 5) {
                                this._activeBonds.push({n1, n2, type: 'diplomatic', strength: dipBond, tribe1, tribe2});
                            }
                            
                            // Check commercial bond
                            let comBond = (tribe1.commercialBonds && tribe1.commercialBonds[otherId]) || 0;
                            if (comBond > 5) {
                                this._activeBonds.push({n1, n2, type: 'commercial', strength: comBond, tribe1, tribe2});
                            }
                        }
                    }
                }
                
                this._lastBondUpdateFrame = this.frame;
            }
            
            _cleanupAfterLargeDieOff() {
                // Aggressive cleanup after large die-offs (similar to war cleanup)
                // Reset frame history to allow performance recovery
                if (this.frameTimeHistory.length > 5) {
                    this.frameTimeHistory = this.frameTimeHistory.slice(-3); // Keep only last 3 frames
                }
                // Reset stagger size if it got too high
                if (this.updateStaggerSize > 8) {
                    this.updateStaggerSize = Math.max(4, this.updateStaggerSize - 2);
                }
                // PERFORMANCE: Lightweight cleanup - avoid expensive filtering that blocks rendering
                // Dead agents are already filtered in main loop, so skip here
                // Only do quick capping if arrays are extremely large to prevent memory issues
                
                // Quick cap check - only if arrays are very large (avoid expensive filtering)
                // This prevents memory explosion without blocking the render thread
                if (this.particles.length > 500) {
                    this.particles = this.particles.slice(-300); // Quick cap without filtering
                }
                if (this.resources.length > CONFIG.maxRes * 2) {
                    this.resources = this.resources.slice(-CONFIG.maxRes); // Quick cap
                }
                if (this.plagues.length > 30) {
                    this.plagues = this.plagues.slice(-15); // Quick cap
                }
                if (this.spawnPoints.length > 60) {
                    this.spawnPoints = this.spawnPoints.slice(-30); // Quick cap
                }
                
                // Detailed filtering is handled by regular periodic cleanup (every 200 frames)
                // This lightweight cleanup just prevents memory explosion without blocking
            }
            
            _updateSpatialGrid() {
                if (!this.spatialGrid || this.gridCols === 0 || this.gridRows === 0) {
                    this._rebuildSpatialGrid();
                }
                
                // Clear grid
                this.spatialGrid.agents.forEach(cell => cell.length = 0);
                this.spatialGrid.resources.forEach(cell => cell.length = 0);
                
                // Populate grid with agents
                for (let agent of this.agents) {
                    if (agent.dead) continue;
                    let idx = this._getGridIndex(agent.pos.x, agent.pos.y);
                    this.spatialGrid.agents[idx].push(agent);
                }
                
                // Populate grid with resources
                for (let resource of this.resources) {
                    if (!resource.active) continue;
                    let idx = this._getGridIndex(resource.pos.x, resource.pos.y);
                    this.spatialGrid.resources[idx].push(resource);
                }
            }
            
            // PERFORMANCE OPTIMIZATION: Get nearby agents/resources using spatial grid
            getNearbyEntities(x, y, radius) {
                if (!this.spatialGrid || this.gridCols === 0) {
                    // Fallback to brute force if grid not initialized
                    return {
                        agents: this.agents.filter(a => !a.dead && Vector.dist({x, y}, a.pos) < radius),
                        resources: this.resources.filter(r => r.active && Vector.dist({x, y}, r.pos) < radius)
                    };
                }
                
                let nearbyAgents = [];
                let nearbyResources = [];
                let cellIndices = this._getNearbyCellIndices(x, y, radius);
                
                for (let idx of cellIndices) {
                    // Check agents in this cell
                    for (let agent of this.spatialGrid.agents[idx]) {
                        if (agent.dead) continue;
                        let dist = Vector.dist({x, y}, agent.pos);
                        if (dist < radius) {
                            nearbyAgents.push(agent);
                        }
                    }
                    
                    // Check resources in this cell
                    for (let resource of this.spatialGrid.resources[idx]) {
                        if (!resource.active) continue;
                        let dist = Vector.dist({x, y}, resource.pos);
                        if (dist < radius) {
                            nearbyResources.push(resource);
                        }
                    }
                }
                
                return { agents: nearbyAgents, resources: nearbyResources };
            }

            init() {
                this.agents = [];
                this.resources = [];
                this.walls = [];
                this.particles = [];
                this.projectiles = [];
                this.plagues = [];
                this.frame = 0;
                this.tribes = new TribeManager(); 
                
                // Initialize spatial grid
                this._rebuildSpatialGrid(); 
                
                // Center camera on initial nests (if any exist)
                if (this.tribes.nests.length > 0) {
                    // Calculate center of all nests
                    let sumX = 0, sumY = 0;
                    this.tribes.nests.forEach(n => {
                        sumX += n.pos.x;
                        sumY += n.pos.y;
                    });
                    this.cameraX = sumX / this.tribes.nests.length;
                    this.cameraY = sumY / this.tribes.nests.length;
                }
                
                // Initialize Nests with starting crews (MORE DIVERSE!)
                this.tribes.nests.forEach(n => {
                    // Builders (essential)
                    for(let i=0; i<3; i++) {
                        let a = new Agent(n.pos.x + (Math.random()*20-10), n.pos.y + (Math.random()*20-10), null, null, n.tribeId);
                        a.role = 'Builder'; a.assignColor(); a.age = 200;
                        this.agents.push(a);
                        a.createInitialResources();
                    }
                    // Guardians (essential)
                    for(let i=0; i<3; i++) {
                        let a = new Agent(n.pos.x + (Math.random()*20-10), n.pos.y + (Math.random()*20-10), null, null, n.tribeId);
                        a.role = 'Guardian'; a.assignColor(); a.age = 200;
                        this.agents.push(a);
                        a.createInitialResources();
                    }
                    // Miners (resource gatherers)
                    for(let i=0; i<2; i++) {
                        let a = new Agent(n.pos.x + (Math.random()*30-15), n.pos.y + (Math.random()*30-15), null, null, n.tribeId);
                        a.role = 'Miner'; a.assignColor(); a.age = 200;
                        this.agents.push(a);
                        a.createInitialResources();
                    }
                    // Botanists (food production)
                    for(let i=0; i<2; i++) {
                        let a = new Agent(n.pos.x + (Math.random()*30-15), n.pos.y + (Math.random()*30-15), null, null, n.tribeId);
                        a.role = 'Botanist'; a.assignColor(); a.age = 200;
                        this.agents.push(a);
                        a.createInitialResources();
                    }
                    // Garbage Collectors (recycling)
                    for(let i=0; i<1; i++) {
                        let a = new Agent(n.pos.x + (Math.random()*30-15), n.pos.y + (Math.random()*30-15), null, null, n.tribeId);
                        a.role = 'Garbage Collector'; a.assignColor(); a.age = 200;
                        this.agents.push(a);
                        a.createInitialResources();
                    }
                    // Scouts (exploration)
                    for(let i=0; i<1; i++) {
                        let a = new Agent(n.pos.x + (Math.random()*30-15), n.pos.y + (Math.random()*30-15), null, null, n.tribeId);
                        a.role = 'Scout'; a.assignColor(); a.age = 200;
                        this.agents.push(a);
                        a.createInitialResources();
                    }
                    // Random others to fill pop (will naturally diversify)
                    for(let i=0; i<6; i++) {
                        let a = new Agent(n.pos.x + (Math.random()*100-50), n.pos.y + (Math.random()*100-50), null, null, n.tribeId);
                        a.age = 200; 
                        this.agents.push(a);
                        a.createInitialResources();
                    }
                });

                for(let i=0; i<50; i++) this.spawnResource(null, null, null, 'FOOD');
                for(let i=0; i<30; i++) this.spawnResource(null, null, null, 'MAT');
                for(let i=0; i<5; i++) this.spawnResource(null, null, null, 'STIM');
                for(let i=0; i<10; i++) this.spawnResource(null, null, null, 'HERB');
                for(let i=0; i<10; i++) this.spawnResource(null, null, null, 'ORE');
                for(let i=0; i<3; i++) this.spawnResource(null, null, null, 'RELIC');
            }

            spawnResource(event, x, y, specificType, isNestSpawned = false, creatorTribeId = -1) {
                let type = 'FOOD';
                if (specificType) type = specificType;
                else {
                    let r = Math.random();
                    if (r < 0.5) type = 'FOOD';
                    else if (r < 0.7) type = 'MAT';
                    else if (r < 0.75) type = 'STIM';
                    else if (r < 0.85) type = 'HERB';
                    else if (r < 0.95) type = 'ORE';
                    else type = 'RELIC';
                }
                
                if (!specificType && Math.random() < CONFIG.treasureSpawnRate) type = 'TREASURE';

                let spawnX = x !== null && x !== undefined ? x : Math.random() * this.width;
                let spawnY = y !== null && y !== undefined ? y : Math.random() * this.height;
                this.resources.push(new Resource(spawnX, spawnY, type, isNestSpawned, creatorTribeId));
            }

            spawnMonster() {
                let m = new Agent(this.width/2, this.height/2, { monster: true });
                this.agents.push(m);
                sim.particles.push(new Particle(m.pos.x, m.pos.y, '#ffffff', 'lightning'));
            }

            spawnMonsterAt(x, y) {
                let m = new Agent(x, y, { monster: true });
                this.agents.push(m);
                sim.particles.push(new Particle(x, y, '#ffffff', 'lightning'));
            }
            
            setTool(tool) {
                let btnNest = document.getElementById('btn-nest');
                let btnBoon = document.getElementById('btn-boon');
                let btnInfect = document.getElementById('btn-infect');
                let btnMonster = document.getElementById('btn-monster');
                let agentSelect = document.getElementById('agent-type-select');
                let alertBox = document.getElementById('tool-alert');
                
                // Toggle behavior: if clicking the same tool that's already active, deactivate it
                if (tool === this.actionMode) {
                    this.actionMode = null;
                    tool = null;
                    if (agentSelect) agentSelect.value = '';
                } else {
                    this.actionMode = tool;
                }
                
                // Clear classes
                if(btnNest) btnNest.classList.remove('active-tool');
                if(btnBoon) btnBoon.classList.remove('active-tool');
                btnInfect.classList.remove('active-tool');
                if(btnMonster) btnMonster.classList.remove('active-tool-monster');
                alertBox.classList.add('hidden');

                if (this.actionMode === 'nest') {
                    if(btnNest) btnNest.classList.add('active-tool');
                    if (agentSelect) agentSelect.value = '';
                    alertBox.textContent = "‚ö†Ô∏è PLACE NEST MODE - CLICK ON CANVAS TO PLACE ‚ö†Ô∏è";
                    alertBox.classList.remove('hidden');
                } else if (this.actionMode === 'boon') {
                    if(btnBoon) btnBoon.classList.add('active-tool');
                    if (agentSelect) agentSelect.value = '';
                    alertBox.textContent = "‚ö†Ô∏è PLACE BOON MODE - CLICK ON CANVAS TO PLACE 50 RESOURCES + 30 FOOD ‚ö†Ô∏è";
                    alertBox.classList.remove('hidden');
                } else if (this.actionMode === 'infect') {
                    btnInfect.classList.add('active-tool');
                    if (agentSelect) agentSelect.value = '';
                    alertBox.textContent = "‚ö†Ô∏è PLACE GERMS MODE - CLICK ON CANVAS TO PLACE ‚ö†Ô∏è";
                    alertBox.classList.remove('hidden');
                } else if (this.actionMode === 'monster') {
                    if(btnMonster) btnMonster.classList.add('active-tool-monster');
                    if (agentSelect) agentSelect.value = '';
                    alertBox.textContent = "‚ö†Ô∏è PLACE MONSTER MODE - CLICK ON CANVAS TO PLACE ‚ö†Ô∏è";
                    alertBox.classList.remove('hidden');
                } else if (this.actionMode && this.actionMode.startsWith('agent-')) {
                    let agentType = this.actionMode.replace('agent-', '');
                    if (agentSelect) agentSelect.value = agentType;
                    alertBox.textContent = `‚ö†Ô∏è PLACE ${agentType.toUpperCase()}S MODE - CLICK ON CANVAS TO PLACE 15 AGENTS ‚ö†Ô∏è`;
                    alertBox.classList.remove('hidden');
                } else {
                    if (agentSelect) agentSelect.value = '';
                }
            }

            triggerOutbreak() {
                // Fallback for automated outbreak logic if needed, but now we use tool
                if (this.agents.length > 0) {
                    let targets = this.agents.filter(a => a.role !== 'Monster');
                    if(targets.length > 0) {
                        let patientZero = targets[Math.floor(Math.random() * targets.length)];
                        patientZero.disease = 1000;
                        sim.particles.push(new Particle(patientZero.pos.x, patientZero.pos.y, '#22c55e'));
                    }
                }
            }

            spawnChild(p1, p2) {
                // Check if scientists are present in the nest to double mutation rate
                let mutationRate = CONFIG.mutationRate;
                if (typeof sim !== 'undefined' && p1.tribeId !== -1) {
                    let myNest = sim.tribes.nests.find(n => n.tribeId === p1.tribeId);
                    if (myNest) {
                        // Check if parents are inside nest
                        let p1Dist = Vector.dist(p1.pos, myNest.pos);
                        let p2Dist = Vector.dist(p2.pos, myNest.pos);
                        if (p1Dist < myNest.radius || p2Dist < myNest.radius) {
                            // Check for scientists inside the nest
                            // PERFORMANCE: Use spatial grid to find scientists near the nest
                            let scientistsInNest = [];
                            if (typeof sim !== 'undefined' && sim.spatialGrid && sim.gridCols > 0) {
                                let nearby = sim.getNearbyEntities(myNest.pos.x, myNest.pos.y, myNest.radius);
                                scientistsInNest = nearby.agents.filter(a => 
                                    a.role === 'Scientist' && 
                                    a.tribeId === p1.tribeId && 
                                    !a.dead
                                );
                            } else if (typeof sim !== 'undefined' && sim.agents) {
                                // Fallback: filter only if spatial grid not available
                                scientistsInNest = sim.agents.filter(a => 
                                    a.role === 'Scientist' && 
                                    a.tribeId === p1.tribeId && 
                                    !a.dead &&
                                    Vector.dist(a.pos, myNest.pos) < myNest.radius
                                );
                            }
                            if (scientistsInNest.length > 0) {
                                mutationRate *= 2.0; // Double mutation rate when scientists are present
                            }
                        }
                    }
                }
                
                let newDna = {};
                for(let k in p1.dna) {
                    // Handle array genes (oscillate_pattern, oscillate_weights)
                    if (Array.isArray(p1.dna[k])) {
                        // Inherit pattern from one parent
                        newDna[k] = (Math.random() < 0.5 ? [...p1.dna[k]] : [...p2.dna[k]]);
                        // Mutate each element in the pattern array
                        if (Math.random() < mutationRate) {
                            let mutIdx = Math.floor(Math.random() * newDna[k].length);
                            if (k === 'oscillate_pattern') {
                                newDna[k][mutIdx] = Math.floor(Math.random() * 8); // New random direction
                            } else if (k === 'oscillate_weights') {
                                newDna[k][mutIdx] = 0.5 + Math.random() * 0.5; // New random weight (0.5-1.0)
                            } else {
                                newDna[k][mutIdx] = Math.floor(Math.random() * 8); // Default for other arrays
                            }
                        }
                    } else {
                        // Handle scalar genes normally
                    if (Math.random() < 0.5) newDna[k] = p1.dna[k];
                    else newDna[k] = p2.dna[k];
                    if (Math.random() < mutationRate) {
                        newDna[k] += (Math.random() * 0.2) - 0.1;
                        newDna[k] = Math.max(0, Math.min(1, newDna[k]));
                        }
                    }
                }
                let x = (p1.pos.x + p2.pos.x) / 2;
                let y = (p1.pos.y + p2.pos.y) / 2;
                // Calculate parent generation safely (handle undefined values)
                let p1Gen = (typeof p1.generation === 'number' && !isNaN(p1.generation)) ? p1.generation : 1;
                let p2Gen = (typeof p2.generation === 'number' && !isNaN(p2.generation)) ? p2.generation : 1;
                let child = new Agent(x, y, newDna, {
                    gen: Math.max(p1Gen, p2Gen),
                    tribeId: p1.tribeId, 
                    skills: p1.skills,
                    p1: p1, // Bond to parents
                    p2: p2
                }, p1.tribeId);
                
                child.loyalty[p1.id] = 80;
                child.loyalty[p2.id] = 80;
                this.agents.push(child);
                // Create initial resources for resource-creating agents
                child.createInitialResources();
            }

            spawnConverterAgent(owner, sourceType) {
                if (!owner) return null;
                const pool = ['FOOD','MAT','ORE','HERB','STIM'];
                let source = sourceType || pool[Math.floor(Math.random() * pool.length)];
                let target = pool[(pool.indexOf(source) + 1) % pool.length];
                let x = owner.pos.x + (Math.random() * 30 - 15);
                let y = owner.pos.y + (Math.random() * 30 - 15);
                let dna = { ...owner.dna };
                let converter = new Agent(x, y, dna, null, owner.tribeId);
                converter.isConverterUnit = true;
                converter.converterSource = source;
                converter.converterTarget = target;
                converter.converterOwner = owner;
                converter.color = '#f97316';
                converter.maxHealth += 20;
                converter.health = converter.maxHealth;
                converter.maxEnergy *= 1.2;
                converter.energy = converter.maxEnergy * 0.7;
                converter.groupEntityParent = owner;
                this.agents.push(converter);
                converter.createInitialResources();
                return converter;
            }

            spawnConverterBonder(owner) {
                if (!owner) return null;
                let x = owner.pos.x + (Math.random() * 30 - 15);
                let y = owner.pos.y + (Math.random() * 30 - 15);
                let bonder = new Agent(x, y, { ...owner.dna }, null, owner.tribeId);
                bonder.isConverterBonder = true;
                bonder.ownerGroupAgent = owner;
                bonder.color = '#22d3ee';
                bonder.maxHealth *= 0.8;
                bonder.health = bonder.maxHealth;
                bonder.maxEnergy *= 0.8;
                bonder.energy = bonder.maxEnergy * 0.6;
                bonder.lastBondAttempt = -Infinity;
                bonder.groupEntityParent = owner;
                this.agents.push(bonder);
                bonder.createInitialResources();
                return bonder;
            }

            spawnAgent(type, nest) {
                if (!nest) return null;
                let spawnX = nest.pos.x + (Math.random() * 40 - 20);
                let spawnY = nest.pos.y + (Math.random() * 40 - 20);
                let agent = new Agent(spawnX, spawnY, null, null, nest.tribeId);
                switch (type) {
                    case 'Soldier':
                        agent.role = 'Soldier';
                        agent.assignColor();
                        agent.health += 30;
                        agent.maxHealth += 30;
                        agent.canShootRanged = true;
                        break;
                    case 'Predator':
                        agent.role = 'Raider';
                        agent.assignColor();
                        agent.isPredator = true;
                        agent.health += 25;
                        agent.maxHealth += 25;
                        agent.color = '#dc2626';
                        break;
                    case 'Prey':
                        agent.role = 'Farmer';
                        agent.assignColor();
                        agent.isPrey = true;
                        agent.isGrazer = true;
                        agent.health += 10;
                        agent.maxHealth += 10;
                        agent.color = '#fde047';
                        break;
                    default:
                        agent.assignColor();
                        break;
                }
                this.agents.push(agent);
                agent.createInitialResources();
                return agent;
            }

            buildWall(x, y, tribeId) {
                // No longer physical wall objects, upgrade nest instead
                // handled in Agent interact
            }

            onMouseDown(e) {
                // Don't trigger canvas click if clicking on UI panels or controls
                if (e.target.closest('.panel') || e.target.closest('.ui-control')) return;
                
                // Try to start audio on first user interaction (browser autoplay policy)
                if (typeof sfx !== 'undefined' && sfx.enabled) {
                    sfx.ensureAudioPlaying();
                }

                const rect = this.canvas.getBoundingClientRect();
                const screenX = e.clientX - rect.left;
                const screenY = e.clientY - rect.top;
                
                // Start dragging
                this.isDragging = true;
                this.lastDragX = screenX;
                this.lastDragY = screenY;
                this.dragStartX = screenX;
                this.dragStartY = screenY;
                
                // Stop any existing glide
                this.cameraVelX = 0;
                this.cameraVelY = 0;
            }

            onMouseMove(e) {
                if (!this.isDragging) return;
                
                const rect = this.canvas.getBoundingClientRect();
                const screenX = e.clientX - rect.left;
                const screenY = e.clientY - rect.top;
                
                // Calculate drag delta in screen space
                const deltaX = screenX - this.lastDragX;
                const deltaY = screenY - this.lastDragY;
                
                // CRITICAL FIX: Convert screen space delta to world space by dividing by zoom
                // When zoomed in (zoom > 1), screen pixels represent less world space
                // When zoomed out (zoom < 1), screen pixels represent more world space
                const worldDeltaX = deltaX / this.zoom;
                const worldDeltaY = deltaY / this.zoom;
                
                // Update camera position in world space
                this.cameraX += worldDeltaX;
                this.cameraY += worldDeltaY;
                
                // Store velocity for glide effect (also in world space)
                this.cameraVelX = worldDeltaX;
                this.cameraVelY = worldDeltaY;
                
                // Update last position
                this.lastDragX = screenX;
                this.lastDragY = screenY;
            }

            onMouseUp(e) {
                if (!this.isDragging) {
                    // If we weren't dragging, check if it was a click
                    if (this.dragStartX !== undefined && this.dragStartY !== undefined) {
                        this.handleClick(e);
                    }
                    return;
                }
                
                // We were dragging - check if it was actually a click (very little movement)
                if (this.dragStartX !== undefined && this.dragStartY !== undefined) {
                    const rect = this.canvas.getBoundingClientRect();
                    const screenX = e.clientX - rect.left;
                    const screenY = e.clientY - rect.top;
                    const dx = screenX - this.dragStartX;
                    const dy = screenY - this.dragStartY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    // If mouse didn't move much, treat as click
                    if (distance < 5) {
                        // Reset camera position and velocity (convert screen space to world space)
                        this.cameraX -= dx / this.zoom;
                        this.cameraY -= dy / this.zoom;
                        this.cameraVelX = 0;
                        this.cameraVelY = 0;
                        this.handleClick(e);
                    }
                    // Otherwise, let it glide with the stored velocity
                }
                
                // Stop dragging
                this.isDragging = false;
                this.dragStartX = undefined;
                this.dragStartY = undefined;
            }

            handleClick(e) {
                // Don't trigger canvas click if clicking on UI panels or controls
                if (e.target.closest('.panel') || e.target.closest('.ui-control')) return;

                const rect = this.canvas.getBoundingClientRect();
                const screenX = e.clientX - rect.left;
                const screenY = e.clientY - rect.top;
                
                // REFACTORED: Use canvas transform matrix to get accurate inverse transform
                // Create a temporary canvas context with the same transforms as render
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = 1;
                tempCanvas.height = 1;
                const tempCtx = tempCanvas.getContext('2d');
                
                // Reset to identity matrix to ensure clean start
                tempCtx.setTransform(1, 0, 0, 1, 0, 0);
                
                // Apply the exact same transforms as render code (in same order)
                const viewportCenterX = this.width / 2;
                const viewportCenterY = this.height / 2;
                // Apply the exact same transforms as render code (in same order)
                // Render code applies: zoom transforms, then camera translate per world copy
                // For primary world copy (worldX=0, worldY=0), camera translate is:
                // translate(viewportCenterX - cameraX, viewportCenterY - cameraY)
                tempCtx.translate(viewportCenterX, viewportCenterY);
                tempCtx.scale(this.zoom, this.zoom);
                tempCtx.translate(-viewportCenterX, -viewportCenterY);
                // Camera translate for primary world copy (worldX=0, worldY=0)
                const worldCameraX = this.cameraX - 0 * this.width; // = this.cameraX
                const worldCameraY = this.cameraY - 0 * this.height; // = this.cameraY
                tempCtx.translate(viewportCenterX - worldCameraX, viewportCenterY - worldCameraY);
                
                // Get the transform matrix and invert it
                const transform = tempCtx.getTransform();
                
                let x, y;
                // Try using DOMMatrix for more accurate inversion if available
                if (typeof DOMMatrix !== 'undefined') {
                    try {
                        // Create a mutable DOMMatrix from the transform values
                        const matrix = new DOMMatrix([transform.a, transform.b, transform.c, transform.d, transform.e, transform.f]);
                        const inverse = matrix.invertSelf();
                        if (!inverse.is2D || isNaN(inverse.a)) {
                            throw new Error('Inversion failed');
                        }
                        // Apply inverse transform using DOMMatrix
                        const point = new DOMPoint(screenX, screenY);
                        const transformed = point.matrixTransform(inverse);
                        x = transformed.x;
                        y = transformed.y;
                    } catch (e) {
                        // Fallback to manual inversion if DOMMatrix fails
                        const a = transform.a, b = transform.b, c = transform.c, d = transform.d, tx = transform.e, ty = transform.f;
                        const det = a * d - b * c;
                        if (Math.abs(det) < 0.0001) {
                            x = (screenX - viewportCenterX) / this.zoom + viewportCenterX - this.cameraX;
                            y = (screenY - viewportCenterY) / this.zoom + viewportCenterY - this.cameraY;
                        } else {
                            const aInv = d / det;
                            const bInv = -b / det;
                            const cInv = -c / det;
                            const dInv = a / det;
                            const txInv = (c * ty - d * tx) / det;
                            const tyInv = (b * tx - a * ty) / det;
                            x = aInv * screenX + cInv * screenY + txInv;
                            y = bInv * screenX + dInv * screenY + tyInv;
                        }
                    }
                } else {
                    // Manual matrix inversion
                    const a = transform.a, b = transform.b, c = transform.c, d = transform.d, tx = transform.e, ty = transform.f;
                    const det = a * d - b * c;
                    
                    if (Math.abs(det) < 0.0001) {
                        // Degenerate transform, fallback to simple calculation
                        x = (screenX - viewportCenterX) / this.zoom + viewportCenterX - this.cameraX;
                        y = (screenY - viewportCenterY) / this.zoom + viewportCenterY - this.cameraY;
                    } else {
                        // Invert the 2D affine transform matrix
                        const aInv = d / det;
                        const bInv = -b / det;
                        const cInv = -c / det;
                        const dInv = a / det;
                        const txInv = (c * ty - d * tx) / det;
                        const tyInv = (b * tx - a * ty) / det;
                        
                        // Apply inverse transform
                        x = aInv * screenX + cInv * screenY + txInv;
                        y = bInv * screenX + dInv * screenY + tyInv;
                    }
                }
                const m = new Vector(x, y);

                // NEST TOOL
                if (this.actionMode === 'nest') {
                    // Create a new tribe
                    const colors = ['#ef4444', '#3b82f6', '#10b981', '#eab308', '#d946ef', '#f97316', '#06b6d4', '#8b5cf6'];
                    const bases = ['Red', 'Blue', 'Green', 'Gold', 'Void', 'Orange', 'Cyan', 'Purple'];
                    const suffixes = ['Claw', 'Fin', 'Leaf', 'Spear', 'Walkers', 'Fang', 'Wing', 'Shield'];
                    const colorIndex = this.tribes.nextId % colors.length;
                    const nameIndex = this.tribes.nextId % bases.length;
                    const tribeName = bases[nameIndex] + ' ' + suffixes[this.tribes.nextId % suffixes.length];
                    const tribeId = this.tribes.createTribe(tribeName, colors[colorIndex]);
                    
                    // Create nest at click location
                    const newNest = new Nest(x, y, tribeId);
                    this.tribes.nests.push(newNest);
                    
                    // Initialize nest with starting agents (similar to init)
                    for(let i=0; i<3; i++) {
                        let a = new Agent(x + (Math.random()*20-10), y + (Math.random()*20-10), null, null, tribeId);
                        a.role = 'Builder'; a.assignColor(); a.age = 200;
                        this.agents.push(a);
                    }
                    for(let i=0; i<3; i++) {
                        let a = new Agent(x + (Math.random()*20-10), y + (Math.random()*20-10), null, null, tribeId);
                        a.role = 'Guardian'; a.assignColor(); a.age = 200;
                        this.agents.push(a);
                    }
                    for(let i=0; i<2; i++) {
                        let a = new Agent(x + (Math.random()*30-15), y + (Math.random()*30-15), null, null, tribeId);
                        a.role = 'Miner'; a.assignColor(); a.age = 200;
                        this.agents.push(a);
                    }
                    for(let i=0; i<2; i++) {
                        let a = new Agent(x + (Math.random()*30-15), y + (Math.random()*30-15), null, null, tribeId);
                        a.role = 'Botanist'; a.assignColor(); a.age = 200;
                        this.agents.push(a);
                    }
                    
                    // NEST BIRTH SOUND
                    if (typeof sfx !== 'undefined' && sfx.enabled) {
                        // TEMPORARILY DISABLED FOR TESTING
                        // sfx.play('birth', getHarmonicFreq([HARMONICS.C5, HARMONICS.E5, HARMONICS.G5, HARMONICS.A5], 10), 0.1);
                    }
                    this.particles.push(new Particle(x, y, '#ffffff', 'spark'));
                    this.setStatusMessage(`üè† NEST PLACED: ${tribeName} at (${Math.floor(x)}, ${Math.floor(y)})`, 300);
                    this.setTool(null);
                    return;
                }

                // BOON TOOL - Place lots of resources including food
                if (this.actionMode === 'boon') {
                    const resourceTypes = ['MAT', 'STIM', 'SEED', 'TREASURE', 'HERB', 'ORE', 'RELIC'];
                    // Place 50 random resources (not food)
                    for (let i = 0; i < 50; i++) {
                        let angle = (i / 50) * Math.PI * 2;
                        let offset = 30 + Math.random() * 40;
                        let spawnX = x + Math.cos(angle) * offset;
                        let spawnY = y + Math.sin(angle) * offset;
                        let resourceType = resourceTypes[Math.floor(Math.random() * resourceTypes.length)];
                        this.spawnResource(null, spawnX, spawnY, resourceType);
                    }
                    // Place lots of food (30 food resources)
                    for (let i = 0; i < 30; i++) {
                        let angle = (i / 30) * Math.PI * 2;
                        let offset = 20 + Math.random() * 50;
                        let spawnX = x + Math.cos(angle) * offset;
                        let spawnY = y + Math.sin(angle) * offset;
                        this.spawnResource(null, spawnX, spawnY, 'FOOD');
                    }
                    this.particles.push(new Particle(x, y, '#fbbf24', 'star'));
                    this.setStatusMessage(`üí∞ BOON PLACED: 50 resources + 30 food scattered at (${Math.floor(x)}, ${Math.floor(y)})`, 300);
                    this.setTool(null);
                    return;
                }

                // INFECTION TOOL
                if (this.actionMode === 'infect') {
                    this.plagues.push(new Plague(x, y));
                    this.setStatusMessage(`üåã CATACLYSM: Plague unleashed at (${Math.floor(x)}, ${Math.floor(y)})`, 300); // Show for 300 frames
                    this.setTool(null); // Reset tool
                    return;
                }

                // MONSTER TOOL
                if (this.actionMode === 'monster') {
                    this.spawnMonsterAt(x, y);
                    this.setTool(null);
                    return;
                }

                // AGENT PLACEMENT TOOL
                if (this.actionMode && this.actionMode.startsWith('agent-')) {
                    let agentType = this.actionMode.replace('agent-', '');
                    
                    // Check if click is on a nest - if so, use that nest's tribe
                    // Use a larger radius check to ensure agents placed near nests get assigned correctly
                    let clickedNest = null;
                    let closestNest = null;
                    let closestDist = Infinity;
                    
                    for (let nest of this.tribes.nests) {
                        let dist = Vector.dist(new Vector(x, y), nest.pos);
                        // Check if inside nest radius
                        if (dist < nest.radius) {
                            clickedNest = nest;
                            break;
                        }
                        // Also track closest nest for fallback
                        if (dist < closestDist) {
                            closestDist = dist;
                            closestNest = nest;
                        }
                    }
                    
                    let targetTribeId;
                    if (clickedNest) {
                        // Use the nest's tribe - CRITICAL: Agents placed in nests must belong to that nest's tribe
                        targetTribeId = clickedNest.tribeId;
                    } else if (closestNest && closestDist < closestNest.radius + 50) {
                        // If very close to a nest (within 50 pixels), use that nest's tribe
                        targetTribeId = closestNest.tribeId;
                    } else {
                        // Randomly choose a tribe
                        let existingTribes = Object.keys(this.tribes.tribes).map(id => parseInt(id)).filter(id => id !== -1);
                        if (existingTribes.length === 0) {
                            this.setStatusMessage(`‚ö†Ô∏è No existing tribes to join!`, 300);
                            this.setTool(null);
                            return;
                        }
                        targetTribeId = existingTribes[Math.floor(Math.random() * existingTribes.length)];
                    }
                    
                    // Spawn 15 agents of the specified type
                    // If placed in a nest, spawn them closer to the nest center
                    let spawnCenterX = x;
                    let spawnCenterY = y;
                    let spawnRadius = 20;
                    if (clickedNest || (closestNest && closestDist < closestNest.radius + 50)) {
                        // Spawn at nest center if placed in nest
                        let nest = clickedNest || closestNest;
                        spawnCenterX = nest.pos.x;
                        spawnCenterY = nest.pos.y;
                        spawnRadius = nest.radius * 0.8; // Spawn within 80% of nest radius
                    }
                    
                    for (let i = 0; i < 15; i++) {
                        let angle = (i / 15) * Math.PI * 2;
                        let offset = spawnRadius * 0.3 + Math.random() * spawnRadius * 0.5;
                        let spawnX = spawnCenterX + Math.cos(angle) * offset;
                        let spawnY = spawnCenterY + Math.sin(angle) * offset;
                        let agent = new Agent(spawnX, spawnY, null, null, targetTribeId);
                        agent.role = agentType;
                        agent.assignColor();
                        agent.age = Math.random() * CONFIG.adultAge;
                        
                        // Apply role-specific bonuses (similar to spawnAgent)
                        if (agentType === 'Soldier') {
                            agent.health += 30;
                            agent.maxHealth += 30;
                            agent.canShootRanged = true;
                        } else if (agentType === 'Raider') {
                            agent.isPredator = true;
                            agent.health += 25;
                            agent.maxHealth += 25;
                            agent.color = '#dc2626';
                        } else if (agentType === 'Farmer') {
                            agent.isPrey = true;
                            agent.isGrazer = true;
                            agent.health += 10;
                            agent.maxHealth += 10;
                            agent.color = '#fde047';
                        }
                        
                        // If builder placed inside a nest, give them MAT to start building immediately
                        if (agentType === 'Builder' && clickedNest) {
                            // Spawn MAT resource near the builder so they can immediately start building
                            let matX = spawnX + (Math.random() * 40 - 20);
                            let matY = spawnY + (Math.random() * 40 - 20);
                            let matResource = new Resource(matX, matY, 'MAT', false, targetTribeId);
                            this.resources.push(matResource);
                            // Builder will pick it up on next update cycle
                        }
                        
                        // Don't call determineRole() - we've already set the role manually
                        // determineRole() would override the manually set role based on DNA
                        // Instead, just ensure role-specific properties are set via assignColor()
                        this.agents.push(agent);
                        agent.createInitialResources();
                    }
                    
                    let tribeName = this.tribes.tribes[targetTribeId]?.name || `Tribe ${targetTribeId}`;
                    let placementMsg = clickedNest ? 
                        `üë• PLACED 15 ${agentType}s joining ${tribeName} (nest) at (${Math.floor(x)}, ${Math.floor(y)})` :
                        `üë• PLACED 15 ${agentType}s joining ${tribeName} (random) at (${Math.floor(x)}, ${Math.floor(y)})`;
                    this.setStatusMessage(placementMsg, 300);
                    this.setTool(null);
                    return;
                }

                let clicked = this.agents.find(a => Vector.dist(m, a.pos) < a.radius + 5);
                
                if (clicked) {
                    this.selected = clicked;
                    document.getElementById('inspector').classList.remove('hidden');
                } else {
                    this.selected = null;
                    document.getElementById('inspector').classList.add('hidden');
                    // Spawn 16 random agents at click location
                    for (let i = 0; i < 16; i++) {
                        let angle = (i / 16) * Math.PI * 2;
                        let offset = 20 + Math.random() * 15;
                        let spawnX = x + Math.cos(angle) * offset;
                        let spawnY = y + Math.sin(angle) * offset;
                        let agent = new Agent(spawnX, spawnY, null, null, -1);
                        agent.age = Math.random() * CONFIG.adultAge;
                        this.agents.push(agent);
                        agent.createInitialResources();
                    }
                }
                this.updateUI();
            }
            
            setStatusMessage(message, durationFrames = 300) {
                // Set a status message to display in the HUD
                this.statusMessage = message;
                this.statusMessageExpiry = this.frame + durationFrames;
            }

            updateUI() {
                if (this.frame % 5 === 0) {
                    if (document.getElementById('pop-count')) document.getElementById('pop-count').textContent = this.agents.length;
                    // Calculate max generation, handling undefined values and empty arrays
                    if (document.getElementById('gen-count')) {
                        if (this.agents.length === 0) {
                            document.getElementById('gen-count').textContent = 0;
                        } else {
                            // Filter out undefined/null generations and find max
                            let generations = this.agents
                                .map(a => a.generation)
                                .filter(gen => typeof gen === 'number' && !isNaN(gen));
                            if (generations.length > 0) {
                                document.getElementById('gen-count').textContent = Math.max(...generations);
                            } else {
                                document.getElementById('gen-count').textContent = 0;
                            }
                        }
                    }
                    if (document.getElementById('time-count')) document.getElementById('time-count').textContent = this.frame;
                    
                    // Crisis Alert - always show status message when not in crisis and no tool active
                    let crisisAlertBox = document.getElementById('crisis-alert');
                    let statusAlertBox = document.getElementById('status-alert');
                    let toolAlertBox = document.getElementById('tool-alert');
                    if (this.dynamicBirthRateMult > 1.5) {
                        crisisAlertBox.classList.remove('hidden');
                        statusAlertBox.classList.add('hidden');
                    } else {
                        crisisAlertBox.classList.add('hidden');
                        // Only show status alert if tool alert is also hidden
                        if (!toolAlertBox || toolAlertBox.classList.contains('hidden')) {
                            statusAlertBox.classList.remove('hidden');
                            
                            // Check if there's a status message to display
                            if (this.statusMessage && this.frame < this.statusMessageExpiry) {
                                statusAlertBox.textContent = this.statusMessage;
                                // Use different color for different message types
                                if (this.statusMessage.includes('WAR DECLARED')) {
                                    statusAlertBox.className = 'text-[10px] text-red-400 font-bold';
                                } else if (this.statusMessage.includes('WAR ENDED')) {
                                    statusAlertBox.className = 'text-[10px] text-green-300 font-bold';
                                } else if (this.statusMessage.includes('CATACLYSM')) {
                                    statusAlertBox.className = 'text-[10px] text-orange-400 font-bold';
                                } else {
                                    statusAlertBox.className = 'text-[10px] text-yellow-300 font-bold';
                                }
                            } else {
                                // Clear expired status message and return to normal
                                if (this.statusMessage && this.frame >= this.statusMessageExpiry) {
                                    this.statusMessage = null;
                                }
                                statusAlertBox.textContent = "‚ú® Life Signs Healthy ‚ú®";
                                statusAlertBox.className = 'text-[10px] text-green-300 font-bold';
                            }
                        }
                    }

                    let counts = { FOOD: 0, MAT: 0, STIM: 0, SEED: 0, TREASURE: 0 };
                    this.resources.forEach(r => { if(counts[r.type] !== undefined) counts[r.type]++; });
                    
                    if (document.getElementById('res-green')) document.getElementById('res-green').textContent = counts.FOOD;
                    if (document.getElementById('res-gold')) document.getElementById('res-gold').textContent = counts.MAT;
                    if (document.getElementById('res-treasure')) document.getElementById('res-treasure').textContent = counts.TREASURE;

                    let infected = this.agents.filter(a => a.disease > 0).length;
                    let immune = this.agents.filter(a => a.immunity > 0).length;
                    if (document.getElementById('stat-infected')) document.getElementById('stat-infected').textContent = infected;
                    if (document.getElementById('stat-immune')) document.getElementById('stat-immune').textContent = immune;

                    let list = document.getElementById('tribe-list');
                    if (list) {
                        list.innerHTML = '';
                        // Collect all active tribes and sort by population
                        let activeTribes = [];
                        for(let tid in this.tribes.tribes) {
                            let t = this.tribes.tribes[tid];
                            // Skip if tribe is undefined or doesn't have required properties
                            if (!t || !t.color) continue;
                            let members = this.agents.filter(a => a.tribeId == tid);
                            let count = members.length;
                            let nest = this.tribes.nests.find(n => n.tribeId == tid);
                            let nestWealth = nest ? Math.floor(nest.wealth) : 0;

                            if(count > 0 || nestWealth > 0) {
                                activeTribes.push({ t, count, nestWealth, tid });
                            }
                        }
                        
                        // Sort by population (largest first) and limit to top 20
                        activeTribes.sort((a, b) => b.count - a.count);
                        activeTribes.slice(0, 20).forEach(({ t, count, nestWealth }) => {
                                let div = document.createElement('div');
                                div.style.color = t.color;
                                div.textContent = `${t.name} [T${t.techTier}]: ${count} | Nest: $${nestWealth} | Lead: ${t.leaderId || 'None'}`;
                                list.appendChild(div);
                        });
                    }
                }

                if (this.selected && !this.selected.dead) {
                    let a = this.selected;
                    if (document.getElementById('ins-id')) document.getElementById('ins-id').textContent = `${a.id} (Gen ${a.generation})`;
                    if (document.getElementById('ins-role-tag')) {
                        document.getElementById('ins-role-tag').textContent = a.role.toUpperCase();
                        document.getElementById('ins-role-tag').style.color = a.color;
                    }
                    if (document.getElementById('ins-wealth')) {
                        document.getElementById('ins-wealth').textContent = `Wealth: $${Math.floor(a.wealth)}`;
                    }
                    
                    let heroEl = document.getElementById('ins-hero');
                    if (heroEl) {
                        heroEl.style.display = a.isHero ? 'block' : 'none';
                    }

                    if (document.getElementById('ins-age')) {
                        let lifeStage = a.isAdult() ? "Adult" : "Child";
                        document.getElementById('ins-age').textContent = `${a.age} (${lifeStage})`;
                    }
                    
                    if (document.getElementById('ins-tribe-tag')) {
                        let tName = a.tribeId === -1 ? "None" : (this.tribes.tribes[a.tribeId]?.name || "Unknown");
                        let tColor = a.tribeId === -1 ? "#fff" : this.tribes.tribes[a.tribeId].color;
                        let tribeEl = document.getElementById('ins-tribe-tag');
                        tribeEl.textContent = tName;
                        tribeEl.style.color = tColor;
                        tribeEl.style.borderColor = tColor;
                    }

                    if (document.getElementById('ins-state')) {
                        document.getElementById('ins-state').textContent = a.state;
                        document.getElementById('ins-state').className = `text-xs font-bold uppercase tracking-wider ${a.state === 'Hunting' ? 'text-red-500' : 'text-yellow-400'}`;
                    }
                    
                    if(document.getElementById('ins-health-status')) {
                        let status = "Healthy";
                        let color = "text-green-400";
                        if(a.disease > 0) { status = "INFECTED"; color = "text-red-500"; }
                        else if(a.immunity > 0) { status = "IMMUNE"; color = "text-blue-400"; }
                        
                        let el = document.getElementById('ins-health-status');
                        el.textContent = status;
                        el.className = `text-[10px] font-bold mt-1 ${color}`;
                    }

                    // NEW: Bond Status in Inspector
                    if(document.getElementById('ins-bond-status')) {
                        let count = a.partners.length;
                        let txt = count > 0 ? `Bonded (${count})` : "Single";
                        if (count >= a.maxBonds) txt += " [MAX]";
                        document.getElementById('ins-bond-status').textContent = txt;
                    }

                    if (document.getElementById('ins-energy')) document.getElementById('ins-energy').style.width = `${(a.energy/a.maxEnergy)*100}%`;
                    if (document.getElementById('ins-health')) document.getElementById('ins-health').style.width = `${(a.health/(a.role==='Monster'?500:100))*100}%`;
                    if (document.getElementById('ins-life')) document.getElementById('ins-life').style.width = `${(a.lifespan/a.maxLifespan)*100}%`;
                    
                    if (document.getElementById('ins-inv')) document.getElementById('ins-inv').textContent = a.carrying ? a.carrying.type : "Empty";
                    if (document.getElementById('ins-home')) document.getElementById('ins-home').textContent = a.home ? "Yes" : "No";
                    if (document.getElementById('ins-charisma')) document.getElementById('ins-charisma').textContent = a.charisma;
                    
                    let loverCount = Object.values(a.loyalty).filter(l => l > CONFIG.loveThreshold).length;
                    if (document.getElementById('ins-lovers')) document.getElementById('ins-lovers').textContent = loverCount;

                    if (document.getElementById('ins-dna-aggro')) document.getElementById('ins-dna-aggro').style.width = `${a.dna.aggression*100}%`;
                    if (document.getElementById('ins-dna-raid')) document.getElementById('ins-dna-raid').style.width = `${a.dna.raiding*100}%`;
                    if (document.getElementById('ins-dna-def')) document.getElementById('ins-dna-def').style.width = `${a.dna.defense*100}%`;
                    if (document.getElementById('ins-dna-botany')) document.getElementById('ins-dna-botany').style.width = `${a.dna.botany*100}%`;
                    if (document.getElementById('ins-dna-build')) document.getElementById('ins-dna-build').style.width = `${a.dna.builder*100}%`;
                    if (document.getElementById('ins-dna-manu')) document.getElementById('ins-dna-manu').style.width = `${a.dna.manufacturing*100}%`;
                    if (document.getElementById('ins-dna-intel')) document.getElementById('ins-dna-intel').style.width = `${a.dna.intelligence*100}%`;
                    if (document.getElementById('ins-dna-comm')) document.getElementById('ins-dna-comm').style.width = `${a.dna.commerce*100}%`;
                    if (document.getElementById('ins-dna-altruism')) document.getElementById('ins-dna-altruism').style.width = `${a.dna.altruism*100}%`;
                    if (document.getElementById('ins-dna-curiosity')) document.getElementById('ins-dna-curiosity').style.width = `${a.dna.curiosity*100}%`;
                    
                    if (document.getElementById('ins-skills')) {
                        let skillsHtml = '';
                        for(let s in a.skills) {
                            if(a.skills[s] > 0) skillsHtml += `<div class="bg-gray-700 rounded p-1">${s}: ${a.skills[s]}</div>`;
                        }
                        document.getElementById('ins-skills').innerHTML = skillsHtml || '<div class="col-span-4 italic text-gray-600">No Skills</div>';
                    }

                    let elHunt = document.getElementById('learn-hunt');
                    if (elHunt) elHunt.textContent = a.prefs.hunt.toFixed(2);
                    let elBuild = document.getElementById('learn-build');
                    if (elBuild) elBuild.textContent = a.prefs.build.toFixed(2);
                    let elSocial = document.getElementById('learn-social');
                    if (elSocial) elSocial.textContent = a.prefs.social.toFixed(2);

                } else if (this.selected && this.selected.dead) {
                    document.getElementById('inspector').classList.add('hidden');
                    this.selected = null;
                }
            }

            reset() {
                this.init();
            }
            
            togglePause() {
                this.running = !this.running;
                document.getElementById('pause-btn').textContent = this.running ? "Pause" : "Resume";
                if (this.running) this.loop();
            }
            
            toggleSound(enabled) {
                if (enabled) {
                    sfx.enable();
                    // Ensure audio context is resumed and audio plays after user interaction
                    if (sfx.audioContext && sfx.audioContext.state === 'suspended') {
                        sfx.audioContext.resume().then(() => {
                            console.log('Audio context resumed via sound toggle');
                            // Try to play background audio if it exists
                            if (sfx.backgroundAudio && sfx.backgroundAudio.paused) {
                                sfx.backgroundAudio.play().catch(e => {
                                    console.error('Error playing background audio after toggle:', e);
                                });
                            }
                        });
                    } else if (sfx.backgroundAudio && sfx.backgroundAudio.paused) {
                        // Audio context is running, try to play directly
                        sfx.backgroundAudio.play().catch(e => {
                            console.error('Error playing background audio:', e);
                        });
                    }
                } else {
                    sfx.disable();
                }
            }
            
            updateVolume(value) {
                CONFIG.sfxVolume = parseFloat(value);
                document.getElementById('volume-display').textContent = Math.round(value * 100) + '%';
                
                // Update background music volume if it's playing
                if (sfx && sfx.backgroundGain && sfx.audioContext) {
                    const mainVolume = Math.max(0.4, CONFIG.sfxVolume) * 0.6;
                    sfx.backgroundGain.gain.setValueAtTime(mainVolume, sfx.audioContext.currentTime);
                }
            }

            loop() {
                if (!this.running) return;
                
                // PERFORMANCE: Reset particle creation counter each frame
                this._particlesCreatedThisFrame = 0;
                
                // PERFORMANCE: Quick particle cap check during battles (every frame to prevent lag)
                if (this.particles.length > 150 && this.agents.length > 80) {
                    // During battles, aggressively cap particles to prevent lag
                    this.particles = this.particles.slice(-100);
                }
                
                // Update camera with momentum/glide effect (only when not dragging)
                if (!this.isDragging) {
                    // Apply camera velocity to position
                    this.cameraX += this.cameraVelX;
                    this.cameraY += this.cameraVelY;
                    
                    // Apply friction to velocity (decay momentum)
                    this.cameraVelX *= this.momentumDecay;
                    this.cameraVelY *= this.momentumDecay;
                    
                    // Stop if velocity is very small
                    if (Math.abs(this.cameraVelX) < 0.1) this.cameraVelX = 0;
                    if (Math.abs(this.cameraVelY) < 0.1) this.cameraVelY = 0;
                }
                
                // Reset per-frame sound throttle flags at start of each frame
                soundThrottle.loveSoundPlayedThisFrame = false;
                soundThrottle.battleSoundPlayedThisFrame = false;

                // Resource spawning with separate food spawn rate
                // Allow spawning up to maxRes, but be more generous
                if (this.resources.length < CONFIG.maxRes) {
                    // Food spawn - spawn multiple times if rate is high
                    let foodSpawnChance = CONFIG.foodSpawnRate;
                    if (foodSpawnChance >= 1.0) {
                        // If rate >= 1.0, spawn guaranteed + chance for extra
                        this.spawnResource(null, null, null, 'FOOD');
                        foodSpawnChance -= 1.0;
                    }
                    if (Math.random() < foodSpawnChance) {
                        this.spawnResource(null, null, null, 'FOOD');
                    }
                    // Non-food resources - resSpawnRate can be > 1.0 for guaranteed spawn
                    let resSpawnChance = CONFIG.resSpawnRate;
                    if (resSpawnChance >= 1.0) {
                        this.spawnResource(null, null, null);
                        resSpawnChance -= 1.0;
                    }
                    if (Math.random() < resSpawnChance) {
                        this.spawnResource(null, null, null);
                    }
                }
                
                // Food spawn near nests (reduced rate and shorter lifespan)
                if (Math.random() < CONFIG.foodSpawnNearNestsRate && this.tribes.nests.length > 0) {
                    let nest = this.tribes.nests[Math.floor(Math.random() * this.tribes.nests.length)];
                    let angle = Math.random() * Math.PI * 2;
                    let dist = nest.radius + 20 + Math.random() * 40; // Spawn 20-60 pixels from nest edge (closer)
                    let nx = nest.pos.x + Math.cos(angle) * dist;
                    let ny = nest.pos.y + Math.sin(angle) * dist;
                    if (nx > 0 && nx < this.width && ny > 0 && ny < this.height) {
                        this.spawnResource(null, nx, ny, 'FOOD', true); // Mark as nest-spawned for shorter life
                    }
                }
                
                // RESOURCE MANUFACTURING TECH - Nests spawn raw materials based on tech level
                if (this.frame % 50 === 0) { // Check every 50 frames
                    this.tribes.nests.forEach(nest => {
                        let tribe = this.tribes.tribes[nest.tribeId];
                        if (!tribe) return;
                        
                        let resourceMfgLevel = tribe.techTree.resource_manufacturing.level;
                        if (resourceMfgLevel > 0) {
                            // Spawn rate increases with tech level
                            let spawnChance = resourceMfgLevel * 0.05; // 5% chance per level
                            
                            if (Math.random() < spawnChance) {
                                // Spawn raw materials (MAT, ORE) near nest
                                let angle = Math.random() * Math.PI * 2;
                                let dist = nest.radius + 30 + Math.random() * 80;
                                let nx = nest.pos.x + Math.cos(angle) * dist;
                                let ny = nest.pos.y + Math.sin(angle) * dist;
                                
                                if (nx > 0 && nx < this.width && ny > 0 && ny < this.height) {
                                    let resourceType = Math.random() < 0.5 ? 'MAT' : 'ORE';
                                    this.spawnResource(null, nx, ny, resourceType);
                                    this.particles.push(new Particle(nx, ny, '#eab308', 'spark'));
                                }
                            }
                        }
                    });
                }
                
                // Unaffiliated agents forming new tribes
                let unaffiliated = this.agents.filter(a => a.tribeId === -1 && a.isAdult() && a.role !== 'Monster');
                if (unaffiliated.length >= 5 && Math.random() < 0.01) {
                    // Find a cluster of unaffiliated agents
                    let leader = unaffiliated[Math.floor(Math.random() * unaffiliated.length)];
                    let nearby = unaffiliated.filter(a => Vector.dist(a.pos, leader.pos) < 150);
                    if (nearby.length >= 3) {
                        // Form new tribe
                        let newTribeId = this.tribes.createTribe(`New Tribe ${this.tribes.nextId}`, null);
                        nearby.forEach(a => {
                            a.tribeId = newTribeId;
                            a.color = this.tribes.tribes[newTribeId].color;
                        });
                        // Create nest at valid position (not too close to other nests)
                        let pos = this.tribes.findValidNestPosition(leader.pos.x, leader.pos.y);
                        let newNest3 = new Nest(pos.x, pos.y, newTribeId);
                        this.tribes.nests.push(newNest3);
                        
                        // NEST BIRTH SOUND - Play birth-like tone when nest is created
                        if (typeof sfx !== 'undefined' && sfx.enabled) {
                            // Vary birth tone - wider range
                        // TEMPORARILY DISABLED FOR TESTING
                        // sfx.play('birth', getHarmonicFreq([HARMONICS.C4, HARMONICS.E4, HARMONICS.A4, HARMONICS.C5, HARMONICS.E5, HARMONICS.G5, HARMONICS.A5], 12), 0.1);
                        }
                        this.particles.push(new Particle(pos.x, pos.y, '#ffffff', 'spark'));
                    }
                }
                
                // PREY ASEXUAL REPRODUCTION NEAR FOOD SOURCES
                let preyAgents = this.agents.filter(a => a.isPrey && a.isAdult() && !a.dead);
                preyAgents.forEach(prey => {
                    // Find nearby food
                    let nearbyFood = this.resources.filter(r => 
                        r.type === 'FOOD' && 
                        r.active && 
                        Vector.dist(prey.pos, r.pos) < CONFIG.preyAsexualReproductionRadius
                    );
                    
                    if (nearbyFood.length > 0 && Math.random() < CONFIG.preyAsexualReproductionRate && prey.energy > 60) {
                        // Asexual reproduction - clone self with slight mutation
                        let cloneDna = {...prey.dna};
                        // Small mutations
                        for (let gene in cloneDna) {
                            if (typeof cloneDna[gene] === 'number' && Math.random() < 0.1) {
                                cloneDna[gene] += (Math.random() - 0.5) * 0.1;
                                cloneDna[gene] = Math.max(0, Math.min(1, cloneDna[gene]));
                            }
                        }
                        
                        let offspring = new Agent(
                            prey.pos.x + (Math.random() * 30 - 15), 
                            prey.pos.y + (Math.random() * 30 - 15), 
                            cloneDna, 
                            null, 
                            -1
                        );
                        offspring.role = 'Prey';
                        offspring.isPrey = true;
                        this.agents.push(offspring);
                        
                        prey.energy -= 40;
                        this.particles.push(new Particle(prey.pos.x, prey.pos.y, '#facc15', 'heart'));
                        // Vary birth tone
                        let birthNotes = [HARMONICS.C4, HARMONICS.E4, HARMONICS.A4, HARMONICS.C5, HARMONICS.E5];
                        // TEMPORARILY DISABLED FOR TESTING
                        // sfx.play('birth', getHarmonicFreq(birthNotes, 6), 0.1);
                    }
                });
                
                // PREY SEXUAL REPRODUCTION (controlled)
                preyAgents.forEach(prey => {
                    if (!prey.mateCooldown) prey.mateCooldown = 0; // Initialize if needed
                    if (prey.mateCooldown > 0) {
                        prey.mateCooldown--;
                        return;
                    }
                    if (prey.energy < CONFIG.preyMateEnergyThreshold) return;
                    
                    // Find nearby prey mate
                    let nearbyMates = preyAgents.filter(p => 
                        p !== prey && 
                        p.mateCooldown === 0 && 
                        p.energy >= CONFIG.preyMateEnergyThreshold &&
                        Vector.dist(prey.pos, p.pos) < 50
                    );
                    
                    if (nearbyMates.length > 0 && Math.random() < CONFIG.preyMateRate) {
                        let mate = nearbyMates[0];
                        
                        // Create offspring with mixed DNA
                        let childDna = {};
                        for (let gene in prey.dna) {
                            childDna[gene] = Math.random() < 0.5 ? prey.dna[gene] : mate.dna[gene];
                            if (Math.random() < 0.1) { // Mutation
                                if (typeof childDna[gene] === 'number') {
                                    childDna[gene] += (Math.random() - 0.5) * 0.15;
                                    childDna[gene] = Math.max(0, Math.min(1, childDna[gene]));
                                }
                            }
                        }
                        
                        let offspring = new Agent(
                            (prey.pos.x + mate.pos.x) / 2, 
                            (prey.pos.y + mate.pos.y) / 2, 
                            childDna, 
                            null, 
                            -1
                        );
                        offspring.role = 'Prey';
                        offspring.isPrey = true;
                        this.agents.push(offspring);
                        
                        prey.energy -= 30;
                        mate.energy -= 30;
                        prey.mateCooldown = CONFIG.preyMateCooldown;
                        mate.mateCooldown = CONFIG.preyMateCooldown;
                        
                        this.particles.push(new Particle(offspring.pos.x, offspring.pos.y, '#facc15', 'heart'));
                        // Vary birth tone
                        let birthNotes2 = [HARMONICS.C4, HARMONICS.E4, HARMONICS.A4, HARMONICS.C5, HARMONICS.C5_SHARP, HARMONICS.E5];
                        // TEMPORARILY DISABLED FOR TESTING
                        // sfx.play('birth', getHarmonicFreq(birthNotes2, 6), 0.1);
                    }
                });
                
                // PREDATOR SEXUAL REPRODUCTION (controlled, slow)
                let predatorAgents = this.agents.filter(a => a.isPredator && a.isAdult() && !a.dead);
                if (!predatorAgents.mateCooldown) {
                    predatorAgents.forEach(p => { if (!p.mateCooldown) p.mateCooldown = 0; });
                }
                predatorAgents.forEach(predator => {
                    if (predator.mateCooldown > 0) {
                        predator.mateCooldown--;
                        return;
                    }
                    if (predator.energy < CONFIG.predatorMateEnergyThreshold) return;
                    
                    // Find nearby predator mate
                    let nearbyMates = predatorAgents.filter(p => 
                        p !== predator && 
                        p.mateCooldown === 0 && 
                        p.energy >= CONFIG.predatorMateEnergyThreshold &&
                        Vector.dist(predator.pos, p.pos) < 60
                    );
                    
                    if (nearbyMates.length > 0 && Math.random() < CONFIG.predatorMateRate) {
                        let mate = nearbyMates[0];
                        
                        // Create offspring with mixed DNA
                        let childDna = {};
                        for (let gene in predator.dna) {
                            childDna[gene] = Math.random() < 0.5 ? predator.dna[gene] : mate.dna[gene];
                            if (Math.random() < 0.08) { // Slight mutation
                                if (typeof childDna[gene] === 'number') {
                                    childDna[gene] += (Math.random() - 0.5) * 0.1;
                                    childDna[gene] = Math.max(0, Math.min(1, childDna[gene]));
                                }
                            }
                        }
                        
                        let offspring = new Agent(
                            (predator.pos.x + mate.pos.x) / 2, 
                            (predator.pos.y + mate.pos.y) / 2, 
                            childDna, 
                            null, 
                            -1
                        );
                        offspring.role = 'Predator';
                        offspring.isPredator = true;
                        this.agents.push(offspring);
                        
                        predator.energy -= 50;
                        mate.energy -= 50;
                        predator.mateCooldown = CONFIG.predatorMateCooldown;
                        mate.mateCooldown = CONFIG.predatorMateCooldown;
                        
                        this.particles.push(new Particle(offspring.pos.x, offspring.pos.y, '#dc2626', 'heart'));
                    }
                });
                
                // PREDATOR SPAWNING IN PAIRS
                if (Math.random() < CONFIG.predatorSpawnRate) {
                    let spawnX = Math.random() * this.width;
                    let spawnY = Math.random() * this.height;
                    
                    for (let i = 0; i < 2; i++) {
                        let offsetX = (Math.random() - 0.5) * CONFIG.predatorPairSpawnRadius;
                        let offsetY = (Math.random() - 0.5) * CONFIG.predatorPairSpawnRadius;
                        
                        let predatorDna = {
                            predator_gene: 0.9,
                            aggression: 0.7 + Math.random() * 0.3,
                            speed: 0.6 + Math.random() * 0.4,
                            size: 0.5 + Math.random() * 0.3,
                            sociability: 0.6 + Math.random() * 0.4
                        };
                        
                        let predator = new Agent(
                            spawnX + offsetX, 
                            spawnY + offsetY, 
                            predatorDna, 
                            null, 
                            -1
                        );
                        predator.role = 'Predator';
                        predator.isPredator = true;
                        this.agents.push(predator);
                        this.particles.push(new Particle(predator.pos.x, predator.pos.y, '#dc2626', 'spark'));
                    }
                }
                
                // PREY SPAWNING IN GROUPS OF 3 NEAR HIGH FOOD CONCENTRATIONS
                if (Math.random() < CONFIG.preySpawnRate) {
                    // Find areas with high food concentration
                    let foodResources = this.resources.filter(r => r.type === 'FOOD' && r.active);
                    if (foodResources.length > 5) {
                        // Pick a random food as spawn center
                        let centerFood = foodResources[Math.floor(Math.random() * foodResources.length)];
                        
                        // Count nearby food
                        let nearbyFoodCount = foodResources.filter(r => 
                            Vector.dist(r.pos, centerFood.pos) < 150
                        ).length;
                        
                        // Only spawn if there's a concentration (3+ food items nearby)
                        if (nearbyFoodCount >= 3) {
                            for (let i = 0; i < 3; i++) {
                                let offsetX = (Math.random() - 0.5) * 80;
                                let offsetY = (Math.random() - 0.5) * 80;
                                
                                let preyDna = {
                                    prey_gene: 0.9,
                                    speed: 0.6 + Math.random() * 0.3,
                                    size: 0.4 + Math.random() * 0.2,
                                    sociability: 0.8 + Math.random() * 0.2
                                };
                                
                                let prey = new Agent(
                                    centerFood.pos.x + offsetX, 
                                    centerFood.pos.y + offsetY, 
                                    preyDna, 
                                    null, 
                                    -1
                                );
                                prey.role = 'Prey';
                                prey.isPrey = true;
                                this.agents.push(prey);
                                this.particles.push(new Particle(prey.pos.x, prey.pos.y, '#facc15', 'spark'));
                            }
                        }
                    }
                }
                
                // AUTO-SPAWN DIPLOMATS & MERCHANTS BASED ON LINK STRENGTH
                if (this.frame % 300 === 0) { // Check every 300 frames
                    this.tribes.nests.forEach(nest => {
                        let tribeMembers = this.agents.filter(a => a.tribeId === nest.tribeId && a.isAdult() && !a.dead);
                        let diplomats = tribeMembers.filter(a => a.role === 'Diplomat').length;
                        let merchants = tribeMembers.filter(a => a.role === 'Merchant').length;
                        
                        let tribe = this.tribes.tribes[nest.tribeId];
                        if (!tribe) return;
                        
                        // Count diplomatic link strength (including to enemies for peace negotiations)
                        let totalDiplomaticStrength = 0;
                        let needsDiplomats = 0;
                        
                        for (let otherId in this.tribes.tribes) {
                            if (otherId == nest.tribeId) continue;
                            let otherNest = this.tribes.nests.find(n => n.tribeId == otherId);
                            if (!otherNest) continue;
                            
                            let distance = Vector.distTorus(nest.pos, otherNest.pos, sim.width, sim.height);
                            if (distance > CONFIG.diplomatSpawnDistance) continue;
                            
                            // Diplomatic bonds create demand for diplomats
                            let dipBond = tribe.diplomaticBonds[otherId] || 0;
                            totalDiplomaticStrength += dipBond;
                            
                            // Wars ALSO create demand for diplomats (to negotiate peace!)
                            if (tribe.atWarWith[otherId]) {
                                needsDiplomats += 2; // Wars demand diplomats
                                totalDiplomaticStrength += 50; // Treat as strong link
                            } else if (dipBond > 20) {
                                needsDiplomats += 1;
                            }
                        }
                        
                        // Count commercial link strength
                        let totalCommercialStrength = 0;
                        let needsMerchants = 0;
                        
                        for (let otherId in this.tribes.tribes) {
                            if (otherId == nest.tribeId) continue;
                            let otherNest = this.tribes.nests.find(n => n.tribeId == otherId);
                            if (!otherNest) continue;
                            
                            let distance = Vector.distTorus(nest.pos, otherNest.pos, sim.width, sim.height);
                            if (distance > CONFIG.merchantSpawnDistance) continue;
                            
                            // Skip if at war - no trade
                            if (tribe.atWarWith[otherId]) continue;
                            
                            let comBond = tribe.commercialBonds[otherId] || 0;
                            totalCommercialStrength += comBond;
                            
                            if (comBond > 20) {
                                needsMerchants += 1;
                            }
                        }
                        
                        // ALWAYS maintain minimum diplomats/merchants per tribe (FIX: chicken-egg problem)
                        let diplomatNeed = Math.max(3, Math.ceil(needsDiplomats * (1 + totalDiplomaticStrength / 200))); // Min 3 (was 2)
                        let merchantNeed = Math.max(3, Math.ceil(needsMerchants * (1 + totalCommercialStrength / 200))); // Min 3 (was 2)
                        
                        // ALWAYS spawn diplomat if tribe has < minimum (even without existing bonds!)
                        if (diplomats < diplomatNeed && tribeMembers.length >= 3) { // Lowered from 5 to 3
                            let candidates = tribeMembers.filter(a => 
                                a.role !== 'Diplomat' && 
                                a.role !== 'Merchant' && // Don't convert merchants
                                a.role !== 'Leader' && 
                                a.role !== 'Guardian'
                            );
                            if (candidates.length > 0) {
                                let newDiplomat = candidates[Math.floor(Math.random() * candidates.length)];
                                newDiplomat.role = 'Diplomat';
                                newDiplomat.isSustainedByTribe = true; // Don't seek food/resources
                                newDiplomat.canDefendSelf = false; // Cannot attack
                                newDiplomat.maxHealth = 150; // Higher health (harder to kill)
                                newDiplomat.health = 150;
                                newDiplomat.assignColor();
                                this.particles.push(new Particle(newDiplomat.pos.x, newDiplomat.pos.y, '#fde047', 'star'));
                                sfx.play('diplomacy', 540, 0.12);
                            }
                        }
                        
                        // ALWAYS spawn merchant if tribe has < minimum and enough wealth
                        if (merchants < merchantNeed && nest.wealth > 30 && tribeMembers.length >= 3) { // Reduced from 50 to 30, members from 5 to 3
                            let candidates = tribeMembers.filter(a => 
                                a.role !== 'Merchant' && 
                                a.role !== 'Diplomat' && // Don't convert diplomats
                                a.role !== 'Leader' && 
                                a.role !== 'Guardian'
                            );
                            if (candidates.length > 0) {
                                let newMerchant = candidates[Math.floor(Math.random() * candidates.length)];
                                newMerchant.role = 'Merchant';
                                newMerchant.isSustainedByTribe = true; // Tribe-sustained, but CAN harvest resources for trade
                                newMerchant.canDefendSelf = false; // Cannot attack
                                newMerchant.maxHealth = 150; // Higher health (harder to kill)
                                newMerchant.health = 150;
                                newMerchant.assignColor();
                                this.particles.push(new Particle(newMerchant.pos.x, newMerchant.pos.y, '#be123c', 'coin'));
                                // Vary trade tone
                                let tradeNotes3 = [HARMONICS.A4, HARMONICS.C5, HARMONICS.D5, HARMONICS.E5];
                                sfx.play('trade', getHarmonicFreq(tradeNotes3, 6), 0.15);
                            }
                        }
                    });
                }
                
                // TECH TREE PROGRESSION & DECAY
                if (this.frame % 200 === 0) { // Check every 200 frames
                    for (let tid in this.tribes.tribes) {
                        // Tech decay over time (must maintain through activity)
                        this.tribes.decayTech(tid);
                        
                        // Passive tech gains based on tribe activities
                        let tribe = this.tribes.tribes[tid];
                        let tribeMembers = this.agents.filter(a => a.tribeId == tid && !a.dead);
                        
                        // Agriculture tech from farmers and botanists (100x faster!)
                        let farmers = tribeMembers.filter(a => a.role === 'Farmer' || a.role === 'Botanist').length;
                        if (farmers > 0) this.tribes.progressTech(tid, 'agriculture', farmers * 20);
                        
                        // Construction tech from builders (200x faster!)
                        let builders = tribeMembers.filter(a => a.role === 'Builder').length;
                        if (builders > 0) this.tribes.progressTech(tid, 'construction', builders * 20);
                        
                        // Manufacturing tech from artisans (200x faster!)
                        let artisans = tribeMembers.filter(a => a.role === 'Artisan').length;
                        if (artisans > 0) this.tribes.progressTech(tid, 'manufacturing', artisans * 20);
                        
                        // Medicine tech from healers (200x faster!)
                        let healers = tribeMembers.filter(a => a.role === 'Healer').length;
                        if (healers > 0) this.tribes.progressTech(tid, 'medicine', healers * 20);
                        
                        // Science tech from scientists (300x faster!)
                        let scientists = tribeMembers.filter(a => a.role === 'Scientist').length;
                        if (scientists > 0) this.tribes.progressTech(tid, 'science', scientists * 30);
                        
                        // Education tech from teachers (200x faster!)
                        let teachers = tribeMembers.filter(a => a.role === 'Teacher').length;
                        if (teachers > 0) this.tribes.progressTech(tid, 'education', teachers * 20);
                        
                        // Combat tech from soldiers and guardians (150x faster!)
                        let combatants = tribeMembers.filter(a => a.role === 'Soldier' || a.role === 'Guardian').length;
                        if (combatants > 0) this.tribes.progressTech(tid, 'combat', combatants * 15);
                        
                        // Warfare tech from raiders (200x faster!)
                        let raiders = tribeMembers.filter(a => a.role === 'Raider').length;
                        if (raiders > 0) this.tribes.progressTech(tid, 'warfare', raiders * 20);
                        
                        // Diplomacy tech from diplomats (passive gain, 160x faster!)
                        let diplomats = tribeMembers.filter(a => a.role === 'Diplomat').length;
                        if (diplomats > 0) this.tribes.progressTech(tid, 'diplomacy', diplomats * 16);
                        
                        // Commerce tech from merchants (passive gain, 160x faster!)
                        let merchants = tribeMembers.filter(a => a.role === 'Merchant').length;
                        if (merchants > 0) this.tribes.progressTech(tid, 'commerce', merchants * 16);
                    }
                }
                
                // DENSITY-DEPENDENT REPRODUCTION (S-CURVE OSCILLATION)
                // Population density relative to cap
                let density = this.agents.length / CONFIG.popCap;
                
                // Calculate target multiplier based on current density
                let targetMult = 1.0;
                // S-curve reproduction rate based on density
                // Low density (<0.2): low birth rate (sparse population)
                // Optimal density (~0.5): peak birth rate (healthy population)
                // High density (>0.9): reduced birth rate (crowding/resource competition)
                if (density < CONFIG.reproductionDensityMin) {
                    // Too sparse - low reproduction
                    let sparsityFactor = density / CONFIG.reproductionDensityMin;
                    targetMult = CONFIG.reproductionMinMultiplier + 
                        (1.0 - CONFIG.reproductionMinMultiplier) * sparsityFactor;
                } else if (density < CONFIG.reproductionDensityOptimal) {
                    // Growing towards optimal - increasing reproduction
                    let growthFactor = (density - CONFIG.reproductionDensityMin) / 
                        (CONFIG.reproductionDensityOptimal - CONFIG.reproductionDensityMin);
                    targetMult = 1.0 + 
                        (CONFIG.reproductionMaxMultiplier - 1.0) * growthFactor;
                } else if (density < CONFIG.reproductionDensityMax) {
                    // Optimal to crowded - decreasing reproduction
                    let crowdingFactor = (density - CONFIG.reproductionDensityOptimal) / 
                        (CONFIG.reproductionDensityMax - CONFIG.reproductionDensityOptimal);
                    targetMult = CONFIG.reproductionMaxMultiplier - 
                        (CONFIG.reproductionMaxMultiplier - 1.0) * crowdingFactor;
                } else {
                    // Overcrowded - minimal reproduction
                    let overCrowdFactor = Math.min(1.0, (density - CONFIG.reproductionDensityMax) / 0.1);
                    targetMult = 1.0 - (1.0 - CONFIG.reproductionMinMultiplier) * overCrowdFactor;
                }
                
                // PERFORMANCE FIX: Apply exponential decay to prevent sustained high multipliers
                // The multiplier dampens over time even if density conditions remain favorable
                // This prevents performance issues from sustained high reproduction rates
                if (this._lastDensityBirthRateMult !== undefined) {
                    // Decay the previous multiplier towards 1.0
                    let decayedMult = 1.0 + (this._lastDensityBirthRateMult - 1.0) * this._densityBonusDecayRate;
                    // Interpolate between decayed value and new target (70% towards target, 30% decayed)
                    // This allows the multiplier to respond to density changes but still decay over time
                    this.dynamicBirthRateMult = decayedMult * 0.3 + targetMult * 0.7;
                } else {
                    this.dynamicBirthRateMult = targetMult;
                }
                
                // Store current multiplier for next frame's decay calculation
                this._lastDensityBirthRateMult = this.dynamicBirthRateMult;

                // CRITICAL FIX: Update ALL agents every frame to prevent jitter from staggered updates
                // Staggered updates cause agents to move at different rates, creating visual jitter
                // Instead, update all agents every frame but skip expensive operations for some
                let totalAgents = this.agents.length;
                let groupEntityCount = this.agents.filter(a => a.isGroupEntity).length;
                let useLightweightUpdates = totalAgents > 120 || groupEntityCount > 15;
                
                if (useLightweightUpdates) {
                    // Update all agents every frame, but stagger expensive operations
                    let expensiveOpStagger = totalAgents > 150 ? 4 : 3; // Skip expensive ops for some agents
                    for (let i = 0; i < this.agents.length; i++) {
                        let agent = this.agents[i];
                        // Always do basic position/movement updates
                        let doExpensiveOps = (i % expensiveOpStagger) === (this.frame % expensiveOpStagger);
                        // Pass flag to skip expensive operations
                        agent.update(this.resources, this.agents, doExpensiveOps);
                        // Mating check less frequently
                        if (doExpensiveOps && sim.agents.length < CONFIG.popCap) {
                            agent.checkMating(this.agents);
                        }
                    }
                } else {
                    // Normal update for small populations
                this.agents.forEach(a => {
                        a.update(this.resources, this.agents, true);
                        if (sim.agents.length < CONFIG.popCap) a.checkMating(this.agents);
                    });
                }
                
                // PERFORMANCE OPTIMIZATION: Update spatial grid much less frequently when population is high
                // This reduces expensive grid rebuilds that cause jitter
                // Reuse totalAgents from staggered updates section above
                let gridUpdateInterval = 2; // Default: every 2 frames
                if (totalAgents > 120) {
                    gridUpdateInterval = 8; // Every 8 frames when population is high - much less frequent
                } else if (totalAgents > 100) {
                    gridUpdateInterval = 6; // Every 6 frames
                } else if (totalAgents > 100) {
                    gridUpdateInterval = 4; // Every 4 frames when population is moderate
                }
                if (this.frame % gridUpdateInterval === 0) {
                    this._updateSpatialGrid();
                }
                
                // PERFORMANCE OPTIMIZATION: Update particles less frequently when population is high
                let particleUpdateInterval = 1; // Default: every frame
                if (totalAgents > 120) {
                    particleUpdateInterval = 2; // Every 2 frames when population is high
                }
                if (this.frame % particleUpdateInterval === 0) {
                this.particles.forEach(p => p.update());
                }
                // CRITICAL: Always clean up particles every frame, even if not updated
                // This prevents accumulation when update interval is > 1
                // PERFORMANCE: Quick particle capping - skip expensive filtering, use slice
                // Detailed filtering happens in periodic cleanup (every 200 frames)
                if (this.particles.length > 300) {
                    // Quick cap without filtering during battles
                    this.particles = this.particles.slice(-200);
                } else if (this.particles.length > 200) {
                    // Quick cap when approaching limit
                    this.particles = this.particles.slice(-200);
                }
                // Skip filtering every frame - particles will be filtered in periodic cleanup
                
                // PERFORMANCE: Clean up old birth records (keep only last 180 frames = 3 seconds)
                if (this.recentBirths) {
                    this.recentBirths = this.recentBirths.filter(birth => this.frame - birth.frame < 180);
                }
                
                // GRAZER CLEANUP: Remove dead grazers periodically to prevent accumulation
                if (this.frame % 300 === 0) { // Every 300 frames (5 seconds at 60fps)
                    // PERFORMANCE: Lightweight grazer count check - only do expensive cleanup if needed
                    let grazerCount = 0;
                    for (let a of this.agents) {
                        if (a.isGrazer && !a.dead) grazerCount++;
                    }
                    
                    if (grazerCount > 200) { // If too many grazers, cap population
                        // PERFORMANCE: Quick cap without expensive filtering - just mark oldest for removal
                        let grazerAges = [];
                        for (let a of this.agents) {
                            if (a.isGrazer && !a.dead) {
                                grazerAges.push({agent: a, age: a.age});
                            }
                        }
                        if (grazerAges.length > 150) {
                            // Quick partial sort - only sort what we need to remove
                            grazerAges.sort((a, b) => b.age - a.age);
                            let toRemove = grazerAges.slice(150);
                            for (let item of toRemove) {
                                item.agent.dead = true; // Mark for removal, will be filtered in main loop
                            }
                        }
                    }
                }
                
                this.plagues.forEach(p => p.update());
                this.plagues = this.plagues.filter(p => p.life > 0);
                // Cap plagues if too many
                if (this.plagues.length > 20) {
                    this.plagues = this.plagues.slice(-20);
                }
                
                // Update spawn points
                this.spawnPoints.forEach(sp => sp.update(this));
                this.spawnPoints = this.spawnPoints.filter(sp => sp.life > 0);
                // Cap spawn points if too many
                if (this.spawnPoints.length > 50) {
                    this.spawnPoints = this.spawnPoints.slice(-50);
                }
                
                this.projectiles = this.projectiles.filter(p => p.life > 0);
                // Cap projectiles if too many
                if (this.projectiles.length > 100) {
                    this.projectiles = this.projectiles.slice(-100);
                }

                // Plague infection logic - reduced damage
                this.plagues.forEach(p => {
                    // Damage agents in plague radius
                    this.agents.forEach(a => {
                        if (Vector.dist(a.pos, p.pos) < p.radius) {
                            // Highly damaging plague - severe disease and direct health damage
                            a.disease = Math.max(a.disease, 800); // Severe disease (was 200)
                            // Direct health damage - quite damaging
                            a.health -= 3; // Direct damage per frame while in plague
                            // Also damage energy
                            a.energy -= 1.5; // More energy drain
                            // Visual feedback
                            if (this.frame % 5 === 0) {
                                this.particles.push(new Particle(a.pos.x, a.pos.y, '#22c55e', 'spark')); // Green particles for plague damage
                            }
                        }
                    });
                    
                    // Damage nests in plague radius
                    this.tribes.nests.forEach(nest => {
                        if (Vector.dist(nest.pos, p.pos) < p.radius + nest.radius) {
                            // Plague damages nest health and wealth
                            nest.hp -= 2; // Direct HP damage per frame
                            nest.health = Math.min(nest.maxHealth, nest.hp);
                            nest.wealth -= 1; // Also damages wealth
                            // Visual feedback for nest damage
                            if (this.frame % 10 === 0) {
                                this.particles.push(new Particle(nest.pos.x, nest.pos.y, '#22c55e', 'spark')); // Green particles for nest plague damage
                            }
                        }
                    });
                });
                this.plagues = this.plagues.filter(p => p.life > 0);
                
                // NEST UPDATE
                this.tribes.nests.forEach(n => n.update());
                
                // PERFORMANCE: Update active bonds cache every 10 frames (bonds don't change often)
                if (this.frame % 10 === 0) {
                    this._updateActiveBonds();
                }
                
                // Track nest count before filtering to detect nest deaths
                let nestsBefore = this.tribes.nests.length;
                
                // Remove dead nests (HP <= 0)
                this.tribes.nests = this.tribes.nests.filter(n => n.hp > 0);
                
                // Track agent count before filtering to detect large die-offs
                let agentsBefore = this.agents.length;
                this.agents = this.agents.filter(a => !a.dead);
                let agentsAfter = this.agents.length;
                
                // Aggressive cleanup after nest death
                if (nestsBefore > this.tribes.nests.length) {
                    console.log(`Nest(s) died: ${nestsBefore} -> ${this.tribes.nests.length}, triggering cleanup`);
                    this._cleanupAfterLargeDieOff();
                }
                
                // Aggressive cleanup after large die-off (more than 30% of agents died)
                if (agentsBefore > 0 && (agentsBefore - agentsAfter) > agentsBefore * 0.3) {
                    console.log(`Large die-off detected: ${agentsBefore} -> ${agentsAfter} (${Math.round((agentsBefore - agentsAfter) / agentsBefore * 100)}% died), triggering cleanup`);
                    this._cleanupAfterLargeDieOff();
                }

                // TRIBE BENEFITS FROM SPECIALISTS & LINKED NEST RESOURCE SHARING
                if (this.frame % 100 === 0) { // Check every 100 frames
                    this.tribes.nests.forEach(nest => {
                        let tribeMembers = this.agents.filter(a => a.tribeId === nest.tribeId && !a.dead);
                        
                        // Get tribe object for this nest
                        let myTribe = this.tribes.tribes[nest.tribeId];
                        
                        // Check for COMMERCIAL BONDS - Economic benefits multiplier
                        let myTribeForEconomics = myTribe;
                        let hasCommercialBonds = false;
                        let commercialBondCount = 0;
                        if (myTribeForEconomics && myTribeForEconomics.commercialBonds) {
                            for (let otherId in myTribeForEconomics.commercialBonds) {
                                if (myTribeForEconomics.commercialBonds[otherId] > 10) {
                                    hasCommercialBonds = true;
                                    commercialBondCount++;
                                }
                            }
                        }
                        let economicBonus = hasCommercialBonds ? (1.0 + (commercialBondCount * 0.25)) : 1.0; // 25% per bond (increased from 12%)
                        
                        // ARTISAN BENEFITS - increase tribe wealth, health, healing (MASSIVELY INCREASED!)
                        let artisansList = tribeMembers.filter(a => a.role === 'Artisan');
                        if (artisansList.length > 0) {
                            let baseWealth = artisansList.length * 15; // +15 wealth per artisan
                            nest.wealth += baseWealth * economicBonus; // Boosted by economic bonds
                            nest.health = Math.min(nest.maxHealth, (nest.health || nest.maxHealth) + artisansList.length * 0.5); // Healing
                            
                            // Heal nearby tribe members
                            let nearbyMembers = tribeMembers.filter(a => Vector.dist(a.pos, nest.pos) < 150);
                            nearbyMembers.forEach(member => {
                                member.health = Math.min(member.maxHealth, member.health + artisansList.length * 0.2);
                            });
                            
                            // ECONOMIC BOND: Increased treasure production from Artisans
                            if (hasCommercialBonds && Math.random() < 0.15) { // 15% chance per cycle
                                sim.spawnResource(null, nest.pos.x + (Math.random() * 40 - 20), nest.pos.y + (Math.random() * 40 - 20), 'TREASURE', false, nest.tribeId);
                                this.particles.push(new Particle(nest.pos.x, nest.pos.y, '#fbbf24', 'coin'));
                            }
                            
                            // ARTISANS MAKE MUSICAL TONES (pleasant, brief)
                            if (Math.random() < 0.3) { // 30% chance per cycle
                                let artisan = artisansList[Math.floor(Math.random() * artisansList.length)];
                                // Musical scale frequencies: C, D, E, G, A (pentatonic - harmonic)
                                let musicalNotes = [HARMONICS.C5, HARMONICS.D5, HARMONICS.E5, HARMONICS.G5, HARMONICS.A5];
                                let note = musicalNotes[Math.floor(Math.random() * musicalNotes.length)];
                                sfx.play('artisan_tone', note, 0.15);
                                this.particles.push(new Particle(artisan.pos.x, artisan.pos.y, '#a5f3fc', 'star'));
                            }
                        }
                        
                        // ECONOMIC BOND: Increased agriculture production (Farmers/Botanists)
                        let farmersList = tribeMembers.filter(a => a.role === 'Farmer' || a.role === 'Botanist');
                        if (farmersList.length > 0 && hasCommercialBonds) {
                            // Increased food production during economic bonds (INCREASED BENEFITS)
                            if (Math.random() < 0.20 * commercialBondCount) { // 20% per bond (increased from 12%)
                                sim.spawnResource(null, nest.pos.x + (Math.random() * 50 - 25), nest.pos.y + (Math.random() * 50 - 25), 'FOOD', false, nest.tribeId);
                                this.particles.push(new Particle(nest.pos.x, nest.pos.y, '#4ade80', 'leaf'));
                            }
                        }
                        
                        // ECONOMIC BOND: Increased raw materials production (Miners/Gatherers)
                        let minersList = tribeMembers.filter(a => a.role === 'Miner' || a.role === 'Gatherer');
                        if (minersList.length > 0 && hasCommercialBonds) {
                            // Increased raw materials production during economic bonds (INCREASED BENEFITS)
                            if (Math.random() < 0.18 * commercialBondCount) { // 18% per bond (increased from 10%)
                                let materialType = Math.random() < 0.5 ? 'MAT' : 'ORE';
                                sim.spawnResource(null, nest.pos.x + (Math.random() * 50 - 25), nest.pos.y + (Math.random() * 50 - 25), materialType, false, nest.tribeId);
                                this.particles.push(new Particle(nest.pos.x, nest.pos.y, '#94a3b8', 'spark'));
                            }
                        }
                        
                        // SUSTAIN SPECIALISTS (Artisan, Scientist, Teacher)
                        let specialists = tribeMembers.filter(a => 
                            a.isSustainedByTribe && 
                            (a.role === 'Artisan' || a.role === 'Scientist' || a.role === 'Teacher')
                        );
                        
                        specialists.forEach(spec => {
                            if (spec.energy < 50 && nest.wealth > 5) {
                                spec.energy += 2;
                                nest.wealth -= 0.1; // Reduced from 0.8 to 0.1 (87% cost reduction!)
                            }
                            if (nest.wealth < 20) { // Lowered from 50 to 20
                                spec.health -= 0.5; // Starve if tribe poor
                            }
                        });
                        
                        // POPULATION-BASED WEALTH GENERATION - Fine balance
                        // Nests generate wealth based on their population (economic activity)
                        // This must be finely balanced to support nests without breaking economy
                        if (tribeMembers.length > 0) {
                            // Base generation per agent: very small (0.05 wealth per agent per cycle)
                            // This scales slowly with population - too high and it breaks economy
                            let basePerAgent = 0.05; // Very small base rate
                            
                            // Diminishing returns: more agents = less per-agent efficiency
                            // Prevents large nests from generating excessive wealth
                            let populationEfficiency = Math.min(1.0, 15 / Math.max(tribeMembers.length, 1)); // Diminishing returns after 15 agents
                            
                            // Calculate wealth generation
                            let populationWealth = tribeMembers.length * basePerAgent * populationEfficiency;
                            
                            // Bonus for productive roles (they contribute more to economy)
                            let productiveRoles = tribeMembers.filter(a => 
                                ['Merchant', 'Artisan', 'Miner', 'Farmer', 'Builder', 'Gatherer'].includes(a.role)
                            ).length;
                            let productivityBonus = productiveRoles * 0.03; // Small bonus per productive agent
                            
                            // Total wealth generation (finely balanced)
                            let totalWealthGeneration = populationWealth + productivityBonus;
                            
                            // Cap generation to prevent excessive wealth (max 5 per cycle)
                            totalWealthGeneration = Math.min(5.0, totalWealthGeneration);
                            
                            nest.wealth += totalWealthGeneration;
                        }
                        
                        // ECONOMIC BOND MUTUAL BENEFIT - Bidirectional wealth flow for both parties
                        // Commercial bonds create mutual prosperity: both parties generate wealth from the relationship
                        // Diplomatic bonds have their own humanitarian aid system (see below)
                        if (myTribe) {
                            // Find nests with commercial bonds (economic relationships only)
                            for (let otherNestId in myTribe.commercialBonds) {
                                let commBond = myTribe.commercialBonds[otherNestId] || 0;
                                
                                // Only process meaningful commercial bonds
                                if (commBond > 10) {
                                    let otherNest = this.tribes.nests.find(n => n.tribeId == otherNestId && n !== nest);
                                    if (!otherNest || otherNest.hp <= 0) continue;
                                    
                                    // MUTUAL ECONOMIC BENEFIT: Both parties generate wealth from trade
                                    // The stronger party generates more, but both benefit to keep the relationship profitable
                                    let bondStrength = Math.min(commBond / 100, 1.0); // 0.1 to 1.0
                                    
                                    // Calculate trade value based on both parties' economic activity
                                    // Base trade value increases with bond strength (INCREASED BENEFITS)
                                    let baseTradeValue = 5 + (bondStrength * 12); // 5-17 wealth per cycle (increased from 3-10)
                                    
                                    // Both parties receive trade benefits (mutual prosperity)
                                    // Wealthier party gets slightly more (better trading position), but both gain
                                    let thisWealthRatio = Math.min(nest.wealth / 500, 1.0); // Normalize to 500
                                    let otherWealthRatio = Math.min(otherNest.wealth / 500, 1.0);
                                    
                                    // Calculate benefits for each party
                                    // Minimum benefit ensures both parties stay profitable
                                    let thisBenefit = baseTradeValue * (0.6 + (thisWealthRatio * 0.4)); // 60-100% of base
                                    let otherBenefit = baseTradeValue * (0.6 + (otherWealthRatio * 0.4)); // 60-100% of base
                                    
                                    // Add wealth to both parties (mutual benefit from trade)
                                    nest.wealth += thisBenefit;
                                    otherNest.wealth += otherBenefit;
                                    
                                    // BALANCED WEALTH REDISTRIBUTION: If one party is much weaker, additional support
                                    // This prevents weaker parties from dying while still benefiting both
                                    let wealthDifference = Math.abs(nest.wealth - otherNest.wealth);
                                    let weakerNest = (nest.wealth < otherNest.wealth) ? nest : otherNest;
                                    let strongerNest = (nest.wealth < otherNest.wealth) ? otherNest : nest;
                                    
                                    // If wealth difference is large and weaker nest is struggling, provide support
                                    if (wealthDifference > 100 && weakerNest.wealth < 150) {
                                        let supportAmount = Math.min(
                                            (wealthDifference - 100) * 0.15, // 15% of excess difference
                                            strongerNest.wealth * 0.05, // Max 5% of stronger party's wealth
                                            30 // Cap at 30 to prevent abuse
                                        );
                                        
                                        // Only provide support if stronger party can afford it
                                        if (strongerNest.wealth > supportAmount * 3 && supportAmount > 2) {
                                            strongerNest.wealth -= supportAmount;
                                            weakerNest.wealth += supportAmount;
                                        }
                                    }
                                    
                                    // Occasional VFX for trade activity (not too spammy)
                                    if (Math.random() < 0.05) {
                                        this.particles.push(new Particle(
                                            (nest.pos.x + otherNest.pos.x) / 2,
                                            (nest.pos.y + otherNest.pos.y) / 2,
                                            '#10b981', 'coin'
                                        ));
                                        sfx.play('water_drop', BATTLE_TONES[Math.floor(Math.random() * BATTLE_TONES.length)], 0.008); // 80% quieter: 0.04 * 0.2 = 0.008
                                    }
                                }
                            }
                            
                            // DIPLOMATIC HUMANITARIAN AID - Allies help struggling nests
                            // Nests with diplomatic bonds receive aid from their allies
                            // But allies only help if it doesn't put their own nest/tribe at risk
                            // INCREASED: Diplomatic allies also help war winners during baby boom reconstruction
                            let isInBabyBoom = nest.babyBoom > 0;
                            let diplomaticAllies = [];
                            for (let otherNestId in myTribe.diplomaticBonds) {
                                let diploBond = myTribe.diplomaticBonds[otherNestId] || 0;
                                if (diploBond > 30) { // Strong diplomatic bond
                                    let allyNest = this.tribes.nests.find(n => n.tribeId == otherNestId && n !== nest);
                                    if (allyNest) {
                                        let allyTribe = this.tribes.tribes[otherNestId];
                                        // Check if nest needs aid:
                                        // 1. In distress (low HP or low wealth)
                                        // 2. OR in baby boom (post-war reconstruction - priority aid!)
                                        let nestHpRatio = nest.hp / nest.maxHealth;
                                        let nestWealthRatio = nest.wealth / 1000; // Normalize to 1000
                                        let isInDistress = nestHpRatio < 0.5 || nest.wealth < 300;
                                        let needsReconstructionAid = isInBabyBoom && (nestHpRatio < 0.8 || nest.wealth < nest.maxHealth * 0.6);
                                        
                                        if (isInDistress || needsReconstructionAid) {
                                            // Ally calculates cost and risk
                                            let allyHpRatio = allyNest.hp / allyNest.maxHealth;
                                            let allyWealthRatio = allyNest.wealth / 1000;
                                            let allyWarCount = 0;
                                            if (allyTribe && allyTribe.atWarWith) {
                                                for (let warId in allyTribe.atWarWith) {
                                                    if (allyTribe.atWarWith[warId] === true) allyWarCount++;
                                                }
                                            }
                                            
                                            // Ally helps ONLY if:
                                            // 1. Ally is healthy (HP > 60%) AND wealthy (wealth > 200)
                                            // 2. Ally is not in too many wars (max 2 wars)
                                            // 3. Aid cost won't drop ally below safety threshold
                                            // SPECIAL: War winners in baby boom get more lenient requirements (allies help more generously)
                                            let canHelp = (allyHpRatio > 0.6 && allyNest.wealth > 200 && allyWarCount <= 2);
                                            let canHelpReconstruction = needsReconstructionAid && (allyHpRatio > 0.5 && allyNest.wealth > 150 && allyWarCount <= 3); // More lenient for reconstruction
                                            
                                            if (canHelp || canHelpReconstruction) {
                                                // Calculate aid amount (proportional to bond strength)
                                                // INCREASED: War winners in baby boom get more aid (reconstruction priority)
                                                let bondStrength = diploBond / 100; // 0.3 to 1.0
                                                let aidMultiplier = needsReconstructionAid ? 2.0 : 1.0; // 2x aid for war winners
                                                let aidWealth = Math.min(needsReconstructionAid ? 60 : 30, allyNest.wealth * (needsReconstructionAid ? 0.15 : 0.08) * bondStrength * aidMultiplier); // More generous for reconstruction
                                                let aidHp = Math.min(needsReconstructionAid ? 30 : 15, Math.floor(allyNest.hp * (needsReconstructionAid ? 0.1 : 0.05) * bondStrength * aidMultiplier)); // More HP aid for reconstruction
                                                
                                                // Safety check: Don't give aid if it would drop ally below safety threshold
                                                let allyWealthAfterAid = allyNest.wealth - aidWealth;
                                                let allyHpAfterAid = allyNest.hp - aidHp;
                                                
                                                if (allyWealthAfterAid >= 150 && allyHpAfterAid >= allyNest.maxHealth * 0.5) {
                                                    // Provide humanitarian aid
                                                    nest.wealth += aidWealth;
                                                    nest.hp = Math.min(nest.maxHealth, nest.hp + aidHp);
                                                    allyNest.wealth -= aidWealth;
                                                    allyNest.hp = Math.max(200, allyNest.hp - aidHp);
                                                    
                                                    // VFX for aid transfer
                                                    if (Math.random() < 0.3) {
                                                        this.particles.push(new Particle(nest.pos.x, nest.pos.y, '#3b82f6', 'spark')); // Blue for aid
                                                        this.particles.push(new Particle(allyNest.pos.x, allyNest.pos.y, '#60a5fa', 'star')); // Light blue for giver
                                                        sfx.play('water_drop', BATTLE_TONES[Math.floor(Math.random() * BATTLE_TONES.length)], 0.02); // 80% quieter: 0.1 * 0.2 = 0.02
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            
                            // EMERGENCY BORROWING - Only if very poor (using diplomatic/commercial bonds)
                            // This is a last resort when nest is extremely poor and existing systems haven't helped enough
                            if (nest.wealth < 50 && myTribe) {
                                // Find allies with strong bonds (diplomatic or commercial) who can afford to help
                                for (let otherNestId in myTribe.diplomaticBonds) {
                                    let diploBond = myTribe.diplomaticBonds[otherNestId] || 0;
                                    let commBond = myTribe.commercialBonds[otherNestId] || 0;
                                    let bondStrength = Math.max(diploBond, commBond);
                                    
                                    if (bondStrength > 30) { // Strong bond
                                        let allyNest = this.tribes.nests.find(n => n.tribeId == otherNestId && n !== nest && n.hp > 0);
                                        if (allyNest && allyNest.wealth > 400) {
                                        // Emergency loan
                                            let loanAmount = Math.min(80, allyNest.wealth * 0.08);
                                            allyNest.wealth -= loanAmount;
                                        nest.wealth += loanAmount;
                                        
                                        // VFX
                                            if (Math.random() < 0.5) {
                                        this.particles.push(new Particle(nest.pos.x, nest.pos.y, '#22c55e', 'spark'));
                                        sfx.play('water_drop', 500, 0.1);
                                            }
                                        
                                        // Strengthen bonds slightly
                                            if (diploBond > commBond) {
                                                myTribe.diplomaticBonds[otherNestId] = Math.min(100, diploBond + 0.5);
                                            } else {
                                                myTribe.commercialBonds[otherNestId] = Math.min(100, commBond + 0.5);
                                            }
                                        
                                        break; // Only one loan per cycle
                                        }
                                    }
                                }
                            }
                        }
                        
                        // NEST DEATH - If not profitable and can't sustain itself
                        if (nest.wealth < 10 && nest.hp < 200) {
                            // Check if nest has been unprofitable for long
                            if (!nest.unprofitableFrames) nest.unprofitableFrames = 0;
                            nest.unprofitableFrames++;
                            
                            if (nest.unprofitableFrames > 500) { // 500 frames of being unprofitable
                                // Nest collapses and dies
                                console.log(`Nest of tribe ${nest.tribeId} collapsed due to lack of resources!`);
                                
                                // Calculate total nest value: wealth + structural health (HP) + energy from agents + resources
                                let totalWealth = nest.wealth;
                                let structuralHealth = nest.maxHealth; // Structural health represented as treasure
                                let totalEnergy = 0;
                                let totalResources = [];
                                
                                // Collect energy and resources from all tribe members
                                let losingTribeMembers = this.agents.filter(a => a.tribeId === nest.tribeId && !a.dead);
                                losingTribeMembers.forEach(agent => {
                                    // Collect energy (convert to wealth/resources)
                                    if (agent.energy > 50) {
                                        totalEnergy += agent.energy * 0.3; // 30% of agent energy
                                    }
                                    // Collect resources they're carrying
                                    if (agent.carrying && agent.carrying.active) {
                                        totalResources.push(agent.carrying.type);
                                        agent.carrying.active = false;
                                        agent.carrying = null;
                                    }
                                });
                                
                                // Convert energy to wealth
                                totalWealth += totalEnergy * 0.5; // 50% efficiency
                                
                                // Nest's structural health becomes treasure (represents accumulated infrastructure)
                                let treasureFromStructure = Math.floor(structuralHealth / 10); // 1 treasure per 10 HP
                                
                                // Find all nests at war with this nest
                                let warringNests = [];
                                if (typeof this.tribes !== 'undefined' && this.tribes.tribes) {
                                    let deadTribe = this.tribes.tribes[nest.tribeId];
                                    if (deadTribe && deadTribe.atWarWith) {
                                        for (let otherId in deadTribe.atWarWith) {
                                            if (deadTribe.atWarWith[otherId] === true) {
                                                // Find nests of this enemy tribe
                                                let enemyNests = this.tribes.nests.filter(n => n.tribeId == otherId && n !== nest && n.hp > 0);
                                                warringNests.push(...enemyNests);
                                            }
                                        }
                                    }
                                    
                                    // Also check reverse - nests that are at war with this nest
                                    for (let tid in this.tribes.tribes) {
                                        let otherTribe = this.tribes.tribes[tid];
                                        if (otherTribe && otherTribe.atWarWith && otherTribe.atWarWith[nest.tribeId] === true) {
                                            let enemyNests = this.tribes.nests.filter(n => n.tribeId == tid && n !== nest && n.hp > 0);
                                            warringNests.push(...enemyNests);
                                        }
                                    }
                                }
                                
                                // DISTRIBUTE ALL VALUE TO WAR WINNERS OR SCATTER IF NO WINNERS
                                if (warringNests.length > 0) {
                                    // CONVERT ALL LOSING TRIBE MEMBERS TO WINNERS - Divide citizens among winning nests
                                    let losingTribeMembers = tribeMembers; // Already filtered to this tribe
                                    
                                    // DISTRIBUTE TO WAR WINNERS - Handle quantities of 1 and remainders randomly
                                    // Wealth distribution
                                    let wealthRemainder = totalWealth;
                                    let wealthPerNest = totalWealth > 0 ? Math.floor(totalWealth / warringNests.length) : 0;
                                    wealthRemainder = totalWealth - (wealthPerNest * warringNests.length);
                                    
                                    // If total wealth is less than number of nests, randomly assign to one nest
                                    if (totalWealth > 0 && totalWealth < warringNests.length) {
                                        let randomNestIndex = Math.floor(Math.random() * warringNests.length);
                                        wealthPerNest = 0; // Reset base amount
                                        wealthRemainder = totalWealth; // All goes to one random nest
                                    }
                                    
                                    // Treasure distribution
                                    let treasureRemainder = treasureFromStructure;
                                    let treasurePerNest = Math.floor(treasureFromStructure / warringNests.length);
                                    treasureRemainder = treasureFromStructure - (treasurePerNest * warringNests.length);
                                    
                                    // If treasure is less than number of nests, randomly assign to one nest
                                    if (treasureFromStructure > 0 && treasureFromStructure < warringNests.length) {
                                        let randomNestIndex = Math.floor(Math.random() * warringNests.length);
                                        treasurePerNest = 0; // Reset base amount
                                        treasureRemainder = treasureFromStructure; // All goes to one random nest
                                    }
                                    
                                    // HP distribution
                                    let hpRemainder = Math.max(0, nest.hp - 200);
                                    let hpPerNest = hpRemainder > 0 ? Math.floor(hpRemainder / warringNests.length) : 0;
                                    hpRemainder = hpRemainder - (hpPerNest * warringNests.length);
                                    
                                    // Resources distribution - shuffle and randomly assign remainders
                                    let resourcesRemainder = totalResources.length;
                                    let resourcesPerNest = Math.floor(totalResources.length / warringNests.length);
                                    resourcesRemainder = totalResources.length - (resourcesPerNest * warringNests.length);
                                    
                                    // If resources count is less than number of nests, randomly assign to one nest
                                    if (totalResources.length > 0 && totalResources.length < warringNests.length) {
                                        let randomNestIndex = Math.floor(Math.random() * warringNests.length);
                                        resourcesPerNest = 0; // Reset base amount
                                        resourcesRemainder = totalResources.length; // All goes to one random nest
                                    }
                                    
                                    // Shuffle resources for random distribution
                                    let shuffledResources = [...totalResources];
                                    for (let i = shuffledResources.length - 1; i > 0; i--) {
                                        let j = Math.floor(Math.random() * (i + 1));
                                        [shuffledResources[i], shuffledResources[j]] = [shuffledResources[j], shuffledResources[i]];
                                    }
                                    
                                    // Members distribution
                                    let membersRemainder = losingTribeMembers.length;
                                    let membersPerNest = Math.floor(losingTribeMembers.length / warringNests.length);
                                    membersRemainder = losingTribeMembers.length - (membersPerNest * warringNests.length);
                                    
                                    // If members count is less than number of nests, randomly assign to one nest
                                    if (losingTribeMembers.length > 0 && losingTribeMembers.length < warringNests.length) {
                                        let randomNestIndex = Math.floor(Math.random() * warringNests.length);
                                        membersPerNest = 0; // Reset base amount
                                        membersRemainder = losingTribeMembers.length; // All goes to one random nest
                                    }
                                    
                                    // Shuffle members for random distribution
                                    let shuffledMembers = [...losingTribeMembers];
                                    for (let i = shuffledMembers.length - 1; i > 0; i--) {
                                        let j = Math.floor(Math.random() * (i + 1));
                                        [shuffledMembers[i], shuffledMembers[j]] = [shuffledMembers[j], shuffledMembers[i]];
                                    }
                                    
                                    // Randomly assign remainders to nests
                                    let remainderAssignments = {
                                        wealth: [],
                                        treasure: [],
                                        hp: [],
                                        resources: [],
                                        members: []
                                    };
                                    
                                    // Create array of nest indices and shuffle for random remainder assignment
                                    let nestIndices = warringNests.map((_, i) => i);
                                    for (let i = nestIndices.length - 1; i > 0; i--) {
                                        let j = Math.floor(Math.random() * (i + 1));
                                        [nestIndices[i], nestIndices[j]] = [nestIndices[j], nestIndices[i]];
                                    }
                                    
                                    // Assign remainders randomly
                                    for (let i = 0; i < wealthRemainder; i++) {
                                        remainderAssignments.wealth.push(nestIndices[i % nestIndices.length]);
                                    }
                                    for (let i = 0; i < treasureRemainder; i++) {
                                        remainderAssignments.treasure.push(nestIndices[i % nestIndices.length]);
                                    }
                                    for (let i = 0; i < hpRemainder; i++) {
                                        remainderAssignments.hp.push(nestIndices[i % nestIndices.length]);
                                    }
                                    for (let i = 0; i < resourcesRemainder; i++) {
                                        remainderAssignments.resources.push(nestIndices[i % nestIndices.length]);
                                    }
                                    for (let i = 0; i < membersRemainder; i++) {
                                        remainderAssignments.members.push(nestIndices[i % nestIndices.length]);
                                    }
                                    
                                    let resourceIndex = 0;
                                    let memberIndex = 0;
                                    
                                    warringNests.forEach((winnerNest, nestIndex) => {
                                        // POST-WAR RECONSTRUCTION: Double the winner's wealth immediately
                                        winnerNest.wealth = winnerNest.wealth * 2;
                                        
                                        // Add spoils from defeated nest (wealth, energy converted to wealth, structural treasure)
                                        let thisNestWealth = wealthPerNest + remainderAssignments.wealth.filter(i => i === nestIndex).length;
                                        if (thisNestWealth > 0) {
                                            winnerNest.wealth += thisNestWealth;
                                        }
                                        let thisNestHp = hpPerNest + remainderAssignments.hp.filter(i => i === nestIndex).length;
                                        if (thisNestHp > 0) {
                                            winnerNest.hp = Math.min(winnerNest.maxHealth, winnerNest.hp + thisNestHp);
                                        }
                                        
                                        // Distribute structural treasure (represents infrastructure value)
                                        let thisNestTreasure = treasurePerNest + remainderAssignments.treasure.filter(i => i === nestIndex).length;
                                        for (let i = 0; i < thisNestTreasure; i++) {
                                            let angle = Math.random() * Math.PI * 2;
                                            let dist = 20 + Math.random() * 30;
                                            this.spawnResource(null,
                                                winnerNest.pos.x + Math.cos(angle) * dist,
                                                winnerNest.pos.y + Math.sin(angle) * dist,
                                                'TREASURE', false, winnerNest.tribeId
                                            );
                                        }
                                        
                                        // Distribute resources from defeated nest
                                        let thisNestResources = resourcesPerNest + remainderAssignments.resources.filter(i => i === nestIndex).length;
                                        for (let i = 0; i < thisNestResources; i++) {
                                            if (shuffledResources[resourceIndex]) {
                                                let angle = Math.random() * Math.PI * 2;
                                                let dist = 20 + Math.random() * 30;
                                                this.spawnResource(null,
                                                    winnerNest.pos.x + Math.cos(angle) * dist,
                                                    winnerNest.pos.y + Math.sin(angle) * dist,
                                                    shuffledResources[resourceIndex], false, winnerNest.tribeId
                                                );
                                                resourceIndex++;
                                            }
                                        }
                                        
                                        // CONVERT LOSING TRIBE MEMBERS TO WINNER'S TRIBE
                                        // Assign citizens to this winning nest (divide equally, with random remainder assignment)
                                        let thisNestMembers = membersPerNest + remainderAssignments.members.filter(i => i === nestIndex).length;
                                        let membersToConvert = shuffledMembers.slice(memberIndex, memberIndex + thisNestMembers);
                                        
                                        membersToConvert.forEach(member => {
                                            let oldTribeId = member.tribeId;
                                            member.tribeId = winnerNest.tribeId;
                                            member.nest = winnerNest;
                                            
                                            // Update loyalty to new tribe
                                            member.loyalty[winnerNest.tribeId] = 50; // Initial loyalty
                                            member.loyalty[oldTribeId] = (member.loyalty[oldTribeId] || 0) * 0.5; // Reduce old loyalty
                                            
                                            // VFX for conversion
                                            this.particles.push(new Particle(member.pos.x, member.pos.y, '#10b981', 'spark'));
                                        });
                                        
                                        memberIndex += thisNestMembers;
                                        
                                        // START RECONSTRUCTION FESTIVAL - Note: This property is set but not currently used in spawning logic
                                        winnerNest.reconstructionFestival = 100;
                                        
                                        // Massive celebration VFX
                                        for (let i = 0; i < 10; i++) {
                                            let angle = (i / 10) * Math.PI * 2;
                                            let dist = 30 + Math.random() * 20;
                                            this.particles.push(new Particle(
                                                winnerNest.pos.x + Math.cos(angle) * dist,
                                                winnerNest.pos.y + Math.sin(angle) * dist,
                                                '#fbbf24', 'star'
                                            ));
                                        }
                                        this.particles.push(new Particle(winnerNest.pos.x, winnerNest.pos.y, '#10b981', 'explosion')); // Green for victory
                                    });
                                    
                                    console.log(`Nest of tribe ${nest.tribeId} destroyed! ${losingTribeMembers.length} citizens converted to ${warringNests.length} winning tribes. Post-war reconstruction: doubled wealth + spoils + 750-frame baby boom!`);
                                } else {
                                    // NO WAR WINNERS - SCATTER ALL VALUE WIDELY AROUND NEST IN RANDOM FORMS
                                    // Scatter wealth, energy, resources, and structural treasure as random resources
                                    let totalValue = totalWealth + (totalEnergy * 0.5) + (structuralHealth / 2);
                                    let scatterCount = Math.min(50, Math.floor(totalValue / 20)); // Scatter up to 50 resources
                                    
                                    let resourceTypes = ['FOOD', 'MAT', 'ORE', 'TREASURE', 'HERB', 'STIM', 'RELIC', 'UNIQUE'];
                                    
                                    for (let i = 0; i < scatterCount; i++) {
                                        let angle = Math.random() * Math.PI * 2;
                                        let dist = 50 + Math.random() * 150; // Wide scatter (50-200 pixels from nest)
                                        let resourceType = resourceTypes[Math.floor(Math.random() * resourceTypes.length)];
                                        
                                        // Weighted random - more valuable resources are rarer
                                        let rand = Math.random();
                                        if (rand < 0.4) resourceType = 'FOOD'; // 40% food
                                        else if (rand < 0.6) resourceType = 'MAT'; // 20% materials
                                        else if (rand < 0.75) resourceType = 'ORE'; // 15% ore
                                        else if (rand < 0.85) resourceType = 'HERB'; // 10% herbs
                                        else if (rand < 0.92) resourceType = 'STIM'; // 7% stims
                                        else if (rand < 0.97) resourceType = 'TREASURE'; // 5% treasure
                                        else if (rand < 0.99) resourceType = 'RELIC'; // 2% relics
                                        else resourceType = 'UNIQUE'; // 1% unique
                                        
                                        this.spawnResource(null,
                                            nest.pos.x + Math.cos(angle) * dist,
                                            nest.pos.y + Math.sin(angle) * dist,
                                            resourceType, false, -1 // Unaffiliated resources
                                        );
                                    }
                                    
                                    // Also scatter remaining resources from agents
                                    totalResources.forEach(resourceType => {
                                        let angle = Math.random() * Math.PI * 2;
                                        let dist = 50 + Math.random() * 150;
                                        this.spawnResource(null,
                                            nest.pos.x + Math.cos(angle) * dist,
                                            nest.pos.y + Math.sin(angle) * dist,
                                            resourceType, false, -1
                                        );
                                    });
                                    
                                    console.log(`Nest of tribe ${nest.tribeId} destroyed! No war winners - ${scatterCount} resources scattered widely around nest location.`);
                                }
                                
                                // Trigger aggressive cleanup after nest death
                                this._cleanupAfterLargeDieOff();
                                
                                // Remove nest
                                let nestIndex = this.tribes.nests.indexOf(nest);
                                if (nestIndex > -1) {
                                    this.tribes.nests.splice(nestIndex, 1);
                                }
                                
                                // Members already converted above, so no need to kill/disperse them
                                
                                // VFX
                                this.particles.push(new Particle(nest.pos.x, nest.pos.y, '#dc2626', 'explosion'));
                                this.particles.push(new Particle(nest.pos.x, nest.pos.y, '#9ca3af', 'smoke'));
                                
                                return; // Skip rest of update for this nest
                            }
                        } else {
                            // Reset counter if profitable again
                            nest.unprofitableFrames = 0;
                        }
                        
                        // TRIBE PROFITS FROM MEMBER ACTIVITY
                        // TRIBES TAX POPULATIONS ON ALL FORMS OF VALUE AND CONVERT TO WHAT TRIBE NEEDS
                        // Regular taxation: energy, wealth, and resources
                        let needsWealth = nest.wealth < nest.maxHealth * 0.3; // Need wealth if below 30% of max health
                        let needsHp = nest.hp < nest.maxHealth * 0.5; // Need HP if below 50%
                        let needsResources = nest.wealth < 100; // Need resources if very poor
                        
                        tribeMembers.forEach(member => {
                            // TAX WEALTH - Direct wealth transfer
                            if (member.wealth > 10 && Math.random() < 0.05) {
                                let contribution = member.wealth * CONFIG.tribalTaxRate; // Use config tax rate
                                member.wealth -= contribution;
                                
                                if (needsHp && nest.hp < nest.maxHealth) {
                                    // Convert wealth to HP (tribe needs health)
                                    let hpGain = contribution * 0.1; // 10% efficiency
                                    nest.hp = Math.min(nest.maxHealth, nest.hp + hpGain);
                                    nest.health = Math.min(nest.maxHealth, nest.hp);
                                } else {
                                    // Add wealth directly
                                nest.wealth += contribution;
                                }
                            }
                            
                            // TAX ENERGY - Convert to what tribe needs
                            if (member.energy > 50 && Math.random() < 0.03) {
                                let energyTax = member.energy * CONFIG.tribalTaxRate * 0.5; // 50% of tax rate for energy
                                member.energy -= energyTax;
                                
                                if (needsHp && nest.hp < nest.maxHealth) {
                                    // Convert energy to HP (tribe needs health)
                                    let hpGain = energyTax * 0.1; // 10% efficiency
                                    nest.hp = Math.min(nest.maxHealth, nest.hp + hpGain);
                                    nest.health = Math.min(nest.maxHealth, nest.hp);
                                } else {
                                    // Convert energy to wealth (tribe needs money)
                                    let wealthGain = energyTax * 0.5; // 50% efficiency
                                    nest.wealth += wealthGain;
                                }
                            }
                            
                            // TAX RESOURCES - Extract from agents carrying resources
                            if (member.carrying && member.carrying.active && Math.random() < 0.02) {
                                let resourceType = member.carrying.type;
                                let resourceValue = weightedResourceEnergy(resourceType) || 30;
                                
                                // Convert resource to what tribe needs
                                if (needsHp && (resourceType === 'HERB' || resourceType === 'STIM')) {
                                    // Herbs/Stims can heal nest
                                    let hpGain = resourceValue * 0.2;
                                    nest.hp = Math.min(nest.maxHealth, nest.hp + hpGain);
                                    nest.health = Math.min(nest.maxHealth, nest.hp);
                                    // Remove resource after taxing
                                    member.carrying.active = false;
                                    member.carrying = null;
                                } else {
                                    // Convert resource value to wealth
                                    let resourceTax = resourceValue * CONFIG.tribalTaxRate * 0.3; // 30% of resource value
                                    nest.wealth += resourceTax;
                                    // Optionally remove resource (or let agent keep it)
                                    if (Math.random() < 0.3) { // 30% chance to confiscate
                                        member.carrying.active = false;
                                        member.carrying = null;
                                    }
                                }
                            }
                        });
                    });
                }
                
                // WAR DECLARATION & MANAGEMENT
                if (this.frame % 200 === 0) { // Check every 200 frames
                    for (let tid1 in this.tribes.tribes) {
                        for (let tid2 in this.tribes.tribes) {
                            if (tid1 >= tid2) continue; // Check each pair once
                            
                            let relation = this.tribes.getOpinion(tid1, tid2);
                            let atWar = this.tribes.isAtWar(tid1, tid2);
                            
                            // AUTO-DECLARE WAR if relations drop below threshold
                            if (!atWar && relation < CONFIG.warDeclarationThreshold) {
                                this.tribes.declareWar(tid1, tid2);
                                
                                // SOLDIERS UNBOND IF ALLIANCE BREAKS
                                // Break soldier bonds between now-enemy tribes
                                this.agents.forEach(agent => {
                                    if (agent.dead || agent.role !== 'Soldier') return;
                                    if (agent.tribeId != tid1 && agent.tribeId != tid2) return;
                                    
                                    // Check all partners
                                    agent.partners = agent.partners.filter(partner => {
                                        if (partner.role !== 'Soldier') return true; // Keep non-soldier bonds
                                        
                                        // Break soldier-soldier bonds between enemy tribes
                                        let sameTribes = (agent.tribeId == tid1 && partner.tribeId == tid2) ||
                                                        (agent.tribeId == tid2 && partner.tribeId == tid1);
                                        if (sameTribes) {
                                            // Remove partner's reference too
                                            partner.partners = partner.partners.filter(p => p !== agent);
                                            return false; // Break bond
                                        }
                                        return true; // Keep bond
                                    });
                                });
                                
                                // VFX at both nests
                                let nest1 = this.tribes.nests.find(n => n.tribeId == tid1);
                                let nest2 = this.tribes.nests.find(n => n.tribeId == tid2);
                                if (nest1 && nest2) {
                                    this.particles.push(new Particle(nest1.pos.x, nest1.pos.y, '#dc2626', 'lightning'));
                                    this.particles.push(new Particle(nest2.pos.x, nest2.pos.y, '#dc2626', 'lightning'));
                                    // TEMPORARILY DISABLED FOR TESTING
                                    // sfx.play('attack', 250, 0.2);
                                }
                            }
                            
                            // Check for surrender or peace
                            if (atWar) {
                                let tribe1 = this.tribes.tribes[tid1];
                                let tribe2 = this.tribes.tribes[tid2];
                                let exhaustion1 = tribe1.warExhaustion[tid2] || 0;
                                let exhaustion2 = tribe2.warExhaustion[tid2] || 0;
                                
                                // SURRENDER if exhaustion too high
                                if (exhaustion1 > tribe1.surrenderThreshold) {
                                    this.tribes.endWar(tid1, tid2, false); // Surrender, no treaty
                                    // PERFORMANCE: Cleanup after war ends
                                    this._cleanupAfterWar();
                                    // Loser pays reparations
                                    let nest1 = this.tribes.nests.find(n => n.tribeId == tid1);
                                    let nest2 = this.tribes.nests.find(n => n.tribeId == tid2);
                                    if (nest1 && nest2 && nest1.wealth > 100) {
                                        let reparations = nest1.wealth * 0.3;
                                        nest1.wealth -= reparations;
                                        nest2.wealth += reparations;
                                    }
                                } else if (exhaustion2 > tribe2.surrenderThreshold) {
                                    this.tribes.endWar(tid1, tid2, false);
                                    // PERFORMANCE: Cleanup after war ends
                                    this._cleanupAfterWar();
                                    let nest1 = this.tribes.nests.find(n => n.tribeId == tid1);
                                    let nest2 = this.tribes.nests.find(n => n.tribeId == tid2);
                                    if (nest1 && nest2 && nest2.wealth > 100) {
                                        let reparations = nest2.wealth * 0.3;
                                        nest2.wealth -= reparations;
                                        nest1.wealth += reparations;
                                    }
                                }
                            }
                        }
                    }
                }
                
                // BOND UPDATES & REINFORCEMENT
                if (this.frame % 50 === 0) { // Check bonds frequently (every 50 frames)
                    for (let tid in this.tribes.tribes) {
                        this.tribes.updateBonds(tid);
                    }
                }
                
                // DIPLOMATIC RELATION DECAY (very slow)
                if (this.frame % 100 === 0) {
                    for (let tid1 in this.tribes.tribes) {
                        for (let tid2 in this.tribes.tribes) {
                            if (tid1 !== tid2) {
                                let currentRelation = this.tribes.getOpinion(tid1, tid2);
                                // Decay toward neutral (0) very slowly
                                if (currentRelation > 0) {
                                    this.tribes.updateOpinion(tid1, tid2, -0.1);
                                } else if (currentRelation < 0) {
                                    this.tribes.updateOpinion(tid1, tid2, 0.1);
                                }
                            }
                        }
                    }
                }
                
                // DIPLOMATIC AFFINITY BONUS
                // Agents from diplomatically linked tribes (relation > 30) have increased personal affinity
                if (this.frame % 50 === 0) {
                    for (let a of this.agents) {
                        if (a.tribeId === -1) continue;
                        for (let other of this.agents) {
                            if (other.tribeId === -1 || other.tribeId === a.tribeId || other === a) continue;
                            
                            let tribalRelation = this.tribes.getOpinion(a.tribeId, other.tribeId);
                            // If tribes have positive diplomatic relations, boost personal affinity
                            if (tribalRelation > 30) {
                                let boost = Math.min(0.5, tribalRelation / 200); // Max 0.5 boost
                                a.adjustLoyalty(other.id, boost);
                            }
                        }
                    }
                }

                // NEST SPLITTING (when too populous OR too large)
                if (this.frame % 200 === 0) {
                    this.tribes.nests.forEach(n => {
                        let tribeMembers = this.agents.filter(a => a.tribeId === n.tribeId && a.isAdult());
                        let radius = Math.sqrt(n.hp / Math.PI);
                        let isTooLarge = radius > (CONFIG.nestSplitMaxRadius || 150);
                        let isTooPopulous = tribeMembers.length > CONFIG.nestSplitPopulation;
                        if (isTooPopulous || isTooLarge) {
                            // Create new allied nest nearby
                            let angle = Math.random() * Math.PI * 2;
                            let dist = 200 + Math.random() * 100; // 200-300 pixels away
                            let newX = n.pos.x + Math.cos(angle) * dist;
                            let newY = n.pos.y + Math.sin(angle) * dist;
                            
                            // Find valid position
                            let pos = this.tribes.findValidNestPosition(newX, newY, 150);
                            
                            // Create new tribe (same parent tribe, but new ID)
                            let newTribeId = this.tribes.createTribe(`${this.tribes.tribes[n.tribeId].name} Colony`, this.tribes.tribes[n.tribeId].color);
                            
                            // 20% chance the new tribe becomes an enemy instead of an ally
                            let becomesEnemy = Math.random() < 0.2;
                            if (becomesEnemy) {
                                // Set hostile relations - declare war
                                this.tribes.updateOpinion(n.tribeId, newTribeId, -60);
                                this.tribes.updateOpinion(newTribeId, n.tribeId, -60);
                                // Declare war between the tribes
                                this.tribes.tribes[n.tribeId].atWarWith[newTribeId] = true;
                                this.tribes.tribes[newTribeId].atWarWith[n.tribeId] = true;
                                
                                // WAR BOND CREATED - Dark ominous sound
                                if (typeof sfx !== 'undefined' && sfx.enabled) {
                                    // TEMPORARILY DISABLED FOR TESTING
                    // sfx.play('death', HARMONICS.E4, 0.2); // Low, ominous war declaration sound
                                }
                            } else {
                            // Set strong alliance between parent and colony
                            this.tribes.updateOpinion(n.tribeId, newTribeId, 80);
                            this.tribes.updateOpinion(newTribeId, n.tribeId, 80);
                            }
                            
                            // Create new nest
                            let newNest = new Nest(pos.x, pos.y, newTribeId);
                            this.tribes.nests.push(newNest);
                            
                            // Transfer wealth using CONFIG split ratio (parent keeps more, child gets less)
                            let childRatio = CONFIG.nestSplitChildReceive;
                            let parentRatio = CONFIG.nestSplitParentRetain;
                            newNest.wealth = Math.floor(n.wealth * childRatio);
                            n.wealth = Math.floor(n.wealth * parentRatio);
                            
                            // Reassign members to new nest using child ratio (those closest to it)
                            tribeMembers.sort((a, b) => {
                                let dA = Vector.dist(a.pos, newNest.pos);
                                let dB = Vector.dist(b.pos, newNest.pos);
                                return dA - dB;
                            });
                            
                            let splitCount = Math.floor(tribeMembers.length * childRatio);
                            for (let i = 0; i < splitCount; i++) {
                                tribeMembers[i].tribeId = newTribeId;
                                tribeMembers[i].color = this.tribes.tribes[newTribeId].color;
                            }
                            
                            this.particles.push(new Particle(pos.x, pos.y, this.tribes.tribes[newTribeId].color, 'spark'));
                            sfx.play('split', 380, 0.25);
                        }
                    });
                }
                
                // NEST MERGING (when adjacent)
                if (this.frame % 250 === 0 && this.tribes.nests.length > 1) {
                    let nestsToRemove = [];
                    
                    for (let i = 0; i < this.tribes.nests.length; i++) {
                        for (let j = i + 1; j < this.tribes.nests.length; j++) {
                            let n1 = this.tribes.nests[i];
                            let n2 = this.tribes.nests[j];
                            
                            if (nestsToRemove.includes(n1) || nestsToRemove.includes(n2)) continue;
                            
                            let distance = Vector.dist(n1.pos, n2.pos);
                            
                            // If nests are adjacent and have positive relations
                            if (distance < CONFIG.nestMergeDistance) {
                                let relation = this.tribes.getOpinion(n1.tribeId, n2.tribeId);
                                
                                // Only merge if they like each other
                                if (relation > 30) {
                                    // Determine larger and smaller nest by population
                                    let n1Members = this.agents.filter(a => a.tribeId === n1.tribeId);
                                    let n2Members = this.agents.filter(a => a.tribeId === n2.tribeId);
                                    
                                    let larger, smaller, largerMembers, smallerMembers;
                                    if (n1Members.length >= n2Members.length) {
                                        larger = n1; smaller = n2;
                                        largerMembers = n1Members; smallerMembers = n2Members;
                                    } else {
                                        larger = n2; smaller = n1;
                                        largerMembers = n2Members; smallerMembers = n1Members;
                                    }
                                    
                                    // Merge: Smaller absorbed into larger
                                    // 1. Combine wealth
                                    larger.wealth += smaller.wealth;
                                    
                                    // 2. Transfer all members to larger tribe
                                    smallerMembers.forEach(a => {
                                        a.tribeId = larger.tribeId;
                                        a.color = this.tribes.tribes[larger.tribeId].color;
                                    });
                                    
                                    // 3. MASS MATING EVENT - genetic mixing with mutations
                                    let adultLarger = largerMembers.filter(a => a.isAdult());
                                    let adultSmaller = smallerMembers.filter(a => a.isAdult());
                                    
                                    // Pair up random members from each tribe for genetic exchange
                                    let pairingCount = Math.min(adultLarger.length, adultSmaller.length, 10); // Max 10 new babies
                                    for (let k = 0; k < pairingCount; k++) {
                                        let parent1 = adultLarger[Math.floor(Math.random() * adultLarger.length)];
                                        let parent2 = adultSmaller[Math.floor(Math.random() * adultSmaller.length)];
                                        
                                        if (parent1.energy > 60 && parent2.energy > 60) {
                                            // Create child at merge point
                                            let mergePoint = Vector.sub(larger.pos, smaller.pos).mult(0.5).add(smaller.pos);
                                            let child = new Agent(mergePoint.x, mergePoint.y, null, [parent1, parent2], larger.tribeId);
                                            this.agents.push(child);
                                            
                                            // Energy cost
                                            parent1.energy -= 20;
                                            parent2.energy -= 20;
                                            
                                            // Update loyalty
                                            parent1.adjustLoyalty(parent2.id, 30);
                                            parent2.adjustLoyalty(parent1.id, 30);
                                        }
                                    }
                                    
                                    // 4. Everyone mutates during merge
                                    // Check if scientists are present in the larger nest to double mutation rate
                                    let mergeMutationRate = 0.1; // Base mutation chance during merge
                                    if (typeof sim !== 'undefined' && larger.tribeId !== -1) {
                                        let scientistsInNest = this.agents.filter(a => 
                                            a.role === 'Scientist' && 
                                            a.tribeId === larger.tribeId && 
                                            !a.dead &&
                                            Vector.dist(a.pos, larger.pos) < larger.radius
                                        );
                                        if (scientistsInNest.length > 0) {
                                            mergeMutationRate *= 2.0; // Double mutation rate when scientists are present
                                        }
                                    }
                                    
                                    [...largerMembers, ...smallerMembers].forEach(a => {
                                        // Small mutation to each gene
                                        for (let gene in a.dna) {
                                            if (typeof a.dna[gene] === 'number' && Math.random() < mergeMutationRate) {
                                                let mutation = (Math.random() - 0.5) * 0.2; // ¬±10%
                                                a.dna[gene] = Math.max(0, Math.min(1, a.dna[gene] + mutation));
                                            }
                                        }
                                    });
                                    
                                    // 5. Remove smaller nest and tribe
                                    nestsToRemove.push(smaller);
                                    
                                    // Visual feedback
                                    // Self-limiting: Only create particles if particle count is reasonable
                                    if (this.particles && this.particles.length < 150) {
                                    this.particles.push(new Particle(larger.pos.x, larger.pos.y, '#ffffff', 'heart'));
                                    this.particles.push(new Particle(smaller.pos.x, smaller.pos.y, '#ffffff', 'heart'));
                                    }
                                    sfx.play('merge', 300, 0.4);
                                    
                                    // Break out of inner loop
                                    break;
                                }
                            }
                        }
                    }
                    
                    // Remove merged nests
                    this.tribes.nests = this.tribes.nests.filter(n => !nestsToRemove.includes(n));
                }
                
                // GARDENS: Spawn food and unique resources near nests
                if (this.frame % 50 === 0) {
                    this.tribes.nests.forEach(n => {
                        // Festivals (High Wealth)
                        if (n.wealth > 500 && Math.random() < 0.01) {
                            n.wealth -= 100;
                            // Self-limiting: Only create particle if particle count is reasonable
                            if (sim.particles && sim.particles.length < 150) {
                            sim.particles.push(new Particle(n.pos.x, n.pos.y, '#ffffff', 'heart')); // Burst
                            }
                            sim.agents.filter(a => a.tribeId === n.tribeId).forEach(a => {
                                a.energy = Math.min(a.energy + 50, a.maxEnergy);
                                a.health = Math.min(a.health + 20, a.maxHealth);
                            });
                        }

                        // Regular food
                        if (Math.random() < 0.3) {
                            let angle = Math.random() * Math.PI * 2;
                            let dist = 30 + Math.random() * 40;
                            sim.spawnResource(null, n.pos.x + Math.cos(angle)*dist, n.pos.y + Math.sin(angle)*dist, 'FOOD', false, n.tribeId);
                        }
                        
                        // Unique resource for this nest (amplifies specific gene)
                        if (Math.random() < 0.15) {
                            let angle = Math.random() * Math.PI * 2;
                            let dist = 25 + Math.random() * 35;
                            let res = {
                                pos: new Vector(n.pos.x + Math.cos(angle)*dist, n.pos.y + Math.sin(angle)*dist),
                                type: 'UNIQUE',
                                config: { color: n.resourceColor, val: 30, type: 'unique', radius: 5 },
                                radius: 5,
                                carrier: null,
                                active: true,
                                nestId: n.tribeId,
                                creatorTribe: n.tribeId,
                                decayTimer: CONFIG.resourceDecayTimers.UNIQUE || CONFIG.matDecay,
                                geneBoost: n.uniqueGene // Which gene this amplifies
                            };
                            this.resources.push(res);
                        }
                    });
                }
                
                // Leader Succession Logic
                if (this.frame % 100 === 0) {
                    this.tribes.updateRoles(this.agents);
                    for(let tid in this.tribes.tribes) {
                        let members = this.agents.filter(a => a.tribeId == tid);
                        let currentLeader = members.find(a => a.id === this.tribes.tribes[tid].leaderId);
                        
                        if (!currentLeader && members.length > 0) {
                             // Promote wealthiest
                             members.sort((a, b) => b.wealth - a.wealth);
                             this.tribes.tribes[tid].leaderId = members[0].id;
                             members[0].health = 2000; // Buff new leader
                             members[0].maxHealth = 2000;
                        }
                    }
                }

                for (let i = this.resources.length - 1; i >= 0; i--) {
                    let r = this.resources[i];
                    if (r.decayTimer !== undefined && r.decayTimer !== null) {
                        r.decayTimer--;
                        if (r.decayTimer <= 0) {
                            r.active = false;
                            continue;
                        }
                    }
                    if (r.type === 'SEED') {
                        r.age++;
                        if (r.age > CONFIG.seedGrowthTime) {
                            r.type = 'FOOD';
                            r.config = RES_TYPES.FOOD;
                            r.decayTimer = (CONFIG.resourceDecayTimers && CONFIG.resourceDecayTimers.FOOD) || CONFIG.matDecay;
                        }
                    }
                }

                // AGGRESSIVE CLEANUP: Remove dead agents immediately (every frame)
                let agentsBeforeFilter = this.agents.length;
                // PERFORMANCE: Separate dead agent processing from filtering to avoid expensive work in filter
                let deadAgents = [];
                let aliveAgents = [];
                
                for (let a of this.agents) {
                    if (a.dead) {
                        deadAgents.push(a);
                    } else {
                        aliveAgents.push(a);
                    }
                }
                
                // Process dead agents (create resources/particles) - but limit to prevent explosion
                let processedDead = 0;
                for (let a of deadAgents) {
                    if (processedDead++ > 20) break; // Limit processing to prevent lag
                    
                    let drops = Math.floor(a.radius / 5);
                    if(a.role === 'Monster') drops = 30; 
                    // Limit drops to prevent resource explosion
                    drops = Math.min(drops, 10);
                    for(let i=0; i<drops; i++) {
                        let r = new Resource(a.pos.x + (Math.random()*40-20), a.pos.y + (Math.random()*40-20), 'FOOD', false, a.tribeId);
                        this.resources.push(r);
                    }
                    // Skulls - use throttled particle creation
                    if (this._particlesCreatedThisFrame < this._maxParticlesPerFrame) {
                        sim.particles.push(new Particle(a.pos.x, a.pos.y, '#fff', 'skull'));
                        this._particlesCreatedThisFrame++;
                    }
                }
                
                this.agents = aliveAgents;
                let agentsAfterFilter = this.agents.length;
                
                // PERFORMANCE: Lightweight resource cleanup - only filter if count is high
                let resourcesBeforeFilter = this.resources.length;
                if (this.resources.length > CONFIG.maxRes * 1.2) {
                    // Only do expensive filtering if resources are accumulating
                    this.resources = this.resources.filter(r => {
                        if (!r.active) return false;
                        // Remove blocks that have decayed (life <= 0)
                        if (r.type === 'BLOCK' && r.life !== undefined && r.life <= 0) return false;
                        return true;
                    });
                }
                let resourcesAfterFilter = this.resources.length;
                
                // Aggressive cleanup after large die-off detected here (more than 20% of agents died - more sensitive)
                if (agentsBeforeFilter > 0 && (agentsBeforeFilter - agentsAfterFilter) > agentsBeforeFilter * 0.2) {
                    console.log(`Large die-off detected in filter: ${agentsBeforeFilter} -> ${agentsAfterFilter} (${Math.round((agentsBeforeFilter - agentsAfterFilter) / agentsBeforeFilter * 100)}% died), triggering cleanup`);
                    this._cleanupAfterLargeDieOff();
                }
                
                // Also trigger cleanup if too many resources accumulated
                if (resourcesAfterFilter > CONFIG.maxRes * 1.2) {
                    this._cleanupAfterLargeDieOff();
                }
                
                // Periodic aggressive cleanup every 300 frames (5 seconds) to prevent accumulation
                if (this.frame % 300 === 0) {
                    this._cleanupAfterLargeDieOff();
                }
                // FOOD DECAY SYSTEM - food dies if not eaten or fertilized
                this.resources.forEach(r => {
                    if ((r.type === 'FOOD' || r.type === 'SEED') && r.life !== Infinity) {
                        r.life -= CONFIG.foodDecayRate;
                        if (r.life <= 0) r.active = false; // Food dies
                    }
                    // Decay MAT resources over time
                    if (r.type === 'MAT' && !r.carrier) {
                        r.decayTimer--;
                        if (r.decayTimer <= 0) r.active = false;
                    }
                    // Decay BLOCK resources over time
                    if (r.type === 'BLOCK' && r.life !== Infinity) {
                        // Blocks decay 1000% slower (10x slower = 1 life per 40 frames instead of 1 per 4 frames)
                        if (this.frame % 40 === 0) {
                            r.life -= 1;
                        }
                        if (r.life <= 0) r.active = false; // Block decays away
                    }
                });
                
                // AGGRESSIVE CLEANUP: Remove inactive resources and dead blocks
                this.resources = this.resources.filter(r => {
                    if (!r.active) return false;
                    // Remove blocks that have decayed (life <= 0)
                    if (r.type === 'BLOCK' && r.life !== undefined && r.life <= 0) return false;
                    return true;
                });
                
                // Cap resources more aggressively if too many accumulated
                if (this.resources.length > CONFIG.maxRes * 1.1) {
                    this.resources = this.resources.slice(-CONFIG.maxRes);
                }
                if (this.resources.length > CONFIG.maxRes * 1.5) {
                    // If resources exceed max by 50%, remove oldest inactive ones
                    // Sort by some property or just keep the most recent
                    this.resources = this.resources.slice(-CONFIG.maxRes);
                }
                // Particles already cleaned up above - don't duplicate
                
                // Update projectiles
                this.projectiles.forEach(p => p.update(this.agents, this.tribes.nests));
                // Projectiles removed - no cleanup needed

                // AGGRESSIVE PERIODIC CLEANUP: More frequent cleanup every 200 frames (was 1000) to prevent memory accumulation
                if (this.frame % 200 === 0) {
                    // Force cleanup of any lingering dead references
                    this.agents = this.agents.filter(a => !a.dead);
                    // Remove inactive resources and dead blocks
                    this.resources = this.resources.filter(r => {
                        if (!r.active) return false;
                        // Remove blocks that have decayed (life <= 0)
                        if (r.type === 'BLOCK' && r.life !== undefined && r.life <= 0) return false;
                        return true;
                    });
                    this.particles = this.particles.filter(p => p.life > 0);
                    this.projectiles = this.projectiles.filter(p => p.active && p.life > 0);
                    this.plagues = this.plagues.filter(p => p.life > 0);
                    this.spawnPoints = this.spawnPoints.filter(sp => sp.life > 0);
                    
                    // Aggressive capping - more aggressive during battles
                    if (this.particles.length > 200) {
                        // During intense periods, cap more aggressively
                        if (this.agents.length > 100) {
                            this.particles = this.particles.slice(-150); // Lower cap during battles
                        } else {
                            this.particles = this.particles.slice(-200);
                        }
                    }
                    // Also cap particles more frequently during battles (every 50 frames instead of 200)
                    if (this.frame % 50 === 0 && this.particles.length > 100 && this.agents.length > 80) {
                        this.particles = this.particles.slice(-100); // Quick cap during battles
                    }
                    // Projectiles removed - no capping needed
                    if (this.plagues.length > 15) this.plagues = this.plagues.slice(-15);
                    if (this.spawnPoints.length > 30) this.spawnPoints = this.spawnPoints.slice(-30);
                    if (this.resources.length > CONFIG.maxRes) {
                        this.resources = this.resources.slice(-CONFIG.maxRes);
                    }
                    
                    // Cap arrays if they're still too large
                    if (this.particles.length > 300) this.particles = this.particles.slice(-300);
                    if (this.projectiles.length > 100) this.projectiles = this.projectiles.slice(-100);
                    if (this.plagues.length > 20) this.plagues = this.plagues.slice(-20);
                    if (this.resources.length > CONFIG.maxRes * 1.5) {
                        this.resources = this.resources.slice(-CONFIG.maxRes);
                    }
                }

                if (this.frame % 3000 === 0) { // Reduced Frequency
                    // Disasters
                    if (Math.random() < 0.5) { // Reduced Chance
                        let disaster = Math.random();
                        if (disaster < 0.3) {
                            // Drought
                            this.resources = this.resources.filter(r => r.type !== 'FOOD');
                            this.setStatusMessage(`üåµ CATACLYSM: Drought - all food resources removed`, 300);
                        } else if (disaster < 0.6) {
                            // Boom
                            for(let i=0; i<20; i++) this.spawnResource(null, null, null, 'TREASURE');
                            this.setStatusMessage(`üí∞ CATACLYSM: Treasure boom - resources scattered`, 300);
                        } else {
                            // Pestilence
                            let plagueX = Math.random()*this.width;
                            let plagueY = Math.random()*this.height;
                            this.plagues.push(new Plague(plagueX, plagueY));
                            this.setStatusMessage(`üåã CATACLYSM: Plague unleashed at (${Math.floor(plagueX)}, ${Math.floor(plagueY)})`, 300);
                        }
                    }

                    for(let tid in this.tribes.tribes) {
                        let members = this.agents.filter(a => a.tribeId == tid);
                        if(members.length > CONFIG.unrestThreshold) {
                            let chance = Math.pow(members.length / CONFIG.unrestThreshold, 2) * 0.1;
                            if (Math.random() < chance) {
                                this.tribes.fractureTribe(parseInt(tid), members);
                            }
                        }
                    }
                }

                this.ctx.fillStyle = '#111827';
                this.ctx.fillRect(0, 0, this.width, this.height);
                
                const viewportCenterX = this.width / 2;
                const viewportCenterY = this.height / 2;
                
                this.ctx.save();
                this.ctx.translate(viewportCenterX, viewportCenterY);
                this.ctx.scale(this.zoom, this.zoom);
                this.ctx.translate(-viewportCenterX, -viewportCenterY);
                
                // Handle camera wrapping - draw world multiple times to fill screen
                // Calculate visible world dimensions
                const viewWidth = this.width / this.zoom;
                const viewHeight = this.height / this.zoom;
                
                // Calculate visible world bounds accounting for zoom
                const viewLeft = this.cameraX - viewWidth / 2;
                const viewRight = this.cameraX + viewWidth / 2;
                const viewTop = this.cameraY - viewHeight / 2;
                const viewBottom = this.cameraY + viewHeight / 2;
                
                // Calculate which world copies we need to draw to fill the entire visible area
                // Use larger margin (50%) to ensure we cover all visible area, especially at high zoom levels
                const margin = Math.max(viewWidth, viewHeight) * 0.5; // 50% margin for safety during panning at zoom
                const minWorldX = Math.floor((viewLeft - margin) / this.width);
                const maxWorldX = Math.ceil((viewRight + margin) / this.width);
                const minWorldY = Math.floor((viewTop - margin) / this.height);
                const maxWorldY = Math.ceil((viewBottom + margin) / this.height);
                
                // Save context state (clip disabled for now)
                this.ctx.save();
                
                for (let worldX = minWorldX; worldX <= maxWorldX; worldX++) {
                    for (let worldY = minWorldY; worldY <= maxWorldY; worldY++) {
                        this.ctx.save();
                        // Calculate the screen position for this world copy
                        // The world wraps, so we translate to show this copy
                        // After zoom transforms, we need to translate by the camera offset
                        // The camera position should appear at the viewport center
                        const worldCameraX = this.cameraX - worldX * this.width;
                        const worldCameraY = this.cameraY - worldY * this.height;
                        // Translate so camera appears at viewport center (which is at origin after zoom transforms)
                        this.ctx.translate(viewportCenterX - worldCameraX, viewportCenterY - worldCameraY);
                        
                        // DRAW NESTS - Must be drawn inside world tiling loop so they appear in all world copies
                        // This prevents nests from vanishing during panning when zoomed in
                        this.tribes.nests.forEach(n => {
                            n.draw(this.ctx);
                        });
                        
                        // DRAW DIPLOMATIC, COMMERCIAL, AND WAR BONDS BETWEEN NESTS
                        // PERFORMANCE: Use pre-computed active bonds list instead of O(N¬≤) nested loop
                        const ctx = this.ctx;
                        
                        // Viewport bounds for culling (with margin for bonds that extend beyond viewport)
                        const viewMargin = Math.max(viewWidth, viewHeight) * 0.2; // 20% margin
                        const viewLeftWithMargin = viewLeft - viewMargin;
                        const viewRightWithMargin = viewRight + viewMargin;
                        const viewTopWithMargin = viewTop - viewMargin;
                        const viewBottomWithMargin = viewBottom + viewMargin;
                        
                        // Draw only active bonds that are in or near viewport
                        for (let bond of (this._activeBonds || [])) {
                            let n1 = bond.n1;
                            let n2 = bond.n2;
                            
                            // Viewport culling: only draw if at least one nest is in viewport (with margin)
                            let n1InView = (n1.pos.x >= viewLeftWithMargin && n1.pos.x <= viewRightWithMargin &&
                                           n1.pos.y >= viewTopWithMargin && n1.pos.y <= viewBottomWithMargin);
                            let n2InView = (n2.pos.x >= viewLeftWithMargin && n2.pos.x <= viewRightWithMargin &&
                                           n2.pos.y >= viewTopWithMargin && n2.pos.y <= viewBottomWithMargin);
                            
                            if (!n1InView && !n2InView) continue; // Skip bonds completely outside viewport
                            
                            // Draw based on bond type
                            if (bond.type === 'war') {
                                    // DRAW WAR BOND - Angry red bond with animated particles going both ways
                                    // Use torus distance and direction for proper wrapping
                                    let bondLength = Vector.distTorus(n1.pos, n2.pos, this.width, this.height);
                                    let torusDir = Vector.subTorus(n1.pos, n2.pos, this.width, this.height);
                                    let normalizedDir = bondLength > 0 ? new Vector(torusDir.x / bondLength, torusDir.y / bondLength) : new Vector(0, 0);
                                    
                                    // Draw the war bond line (thick, angry red)
                                    ctx.beginPath();
                                    ctx.moveTo(n1.pos.x, n1.pos.y);
                                    ctx.lineTo(n1.pos.x + torusDir.x, n1.pos.y + torusDir.y);
                                    ctx.strokeStyle = 'rgba(220, 38, 38, 0.9)'; // Angry red
                                    ctx.lineWidth = 5;
                                    ctx.setLineDash([8, 4]); // Dashed for visual effect
                                    ctx.stroke();
                                    ctx.setLineDash([]); // Reset
                                    
                                    // Animated particles moving both ways along the bond
                                    let animOffset = (this.frame * 2) % (bondLength * 2); // Animation speed
                                    let particleSize = 3;
                                    
                                    // Particles moving from n1 to n2 (left to right)
                                    for (let i = 0; i < 3; i++) {
                                        let progress = (animOffset / bondLength + i * 0.33) % 1.0;
                                        if (progress > 0 && progress < 1) {
                                            let px = n1.pos.x + torusDir.x * progress;
                                            let py = n1.pos.y + torusDir.y * progress;
                                            
                                            // Draw particle with trail effect
                                            ctx.fillStyle = 'rgba(255, 100, 100, 0.9)';
                                            ctx.beginPath();
                                            ctx.arc(px, py, particleSize, 0, Math.PI * 2);
                                            ctx.fill();
                                            
                                            // Bright center
                                            ctx.fillStyle = 'rgba(255, 200, 200, 1.0)';
                                            ctx.beginPath();
                                            ctx.arc(px, py, particleSize * 0.5, 0, Math.PI * 2);
                                            ctx.fill();
                                        }
                                    }
                                    
                                    // Particles moving from n2 to n1 (right to left, opposite direction)
                                    for (let i = 0; i < 3; i++) {
                                        let progress = ((1 - animOffset / bondLength) + i * 0.33) % 1.0;
                                        if (progress > 0 && progress < 1) {
                                            let px = n1.pos.x + torusDir.x * progress;
                                            let py = n1.pos.y + torusDir.y * progress;
                                            
                                            // Draw particle with trail effect
                                            ctx.fillStyle = 'rgba(200, 50, 50, 0.9)';
                                            ctx.beginPath();
                                            ctx.arc(px, py, particleSize, 0, Math.PI * 2);
                                            ctx.fill();
                                            
                                            // Bright center
                                            ctx.fillStyle = 'rgba(255, 150, 150, 1.0)';
                                            ctx.beginPath();
                                            ctx.arc(px, py, particleSize * 0.5, 0, Math.PI * 2);
                                            ctx.fill();
                                        }
                                    }
                                    
                            } else if (bond.type === 'diplomatic') {
                                let dipBond = bond.strength;
                                    // Use torus distance and direction for proper wrapping
                                    let bondLength = Vector.distTorus(n1.pos, n2.pos, this.width, this.height);
                                    let torusDir = Vector.subTorus(n1.pos, n2.pos, this.width, this.height);
                                    let normalizedDir = bondLength > 0 ? new Vector(torusDir.x / bondLength, torusDir.y / bondLength) : new Vector(0, 0);
                                    
                                    // Draw blue striped line
                                 ctx.beginPath();
                                 ctx.moveTo(n1.pos.x, n1.pos.y);
                                    ctx.lineTo(n1.pos.x + torusDir.x, n1.pos.y + torusDir.y);
                                    let alpha = Math.min(0.8, dipBond / 80);
                                    ctx.strokeStyle = `rgba(59, 130, 246, ${alpha})`; // Blue
                                    ctx.lineWidth = Math.min(8, 1 + dipBond / 15);
                                    ctx.setLineDash([10, 5]); // Striped pattern
                                 ctx.stroke();
                                    ctx.setLineDash([]); // Reset
                                    
                                    // Animated purple dots moving along the bond in both directions
                                    let animOffset = (this.frame * 1.5) % (bondLength * 2);
                                    let dotSize = 4;
                                    
                                    // Dots moving from n1 to n2
                                    for (let i = 0; i < 2; i++) {
                                        let progress = (animOffset / bondLength + i * 0.5) % 1.0;
                                        if (progress > 0 && progress < 1) {
                                            let px = n1.pos.x + torusDir.x * progress;
                                            let py = n1.pos.y + torusDir.y * progress;
                                            
                                            ctx.fillStyle = 'rgba(168, 85, 247, 0.9)'; // Purple
                                            ctx.beginPath();
                                            ctx.arc(px, py, dotSize, 0, Math.PI * 2);
                                            ctx.fill();
                                            
                                            // Bright center
                                            ctx.fillStyle = 'rgba(192, 132, 252, 1.0)';
                                            ctx.beginPath();
                                            ctx.arc(px, py, dotSize * 0.5, 0, Math.PI * 2);
                                            ctx.fill();
                                        }
                                    }
                                    
                                    // Dots moving from n2 to n1 (opposite direction)
                                    for (let i = 0; i < 2; i++) {
                                        let progress = ((1 - animOffset / bondLength) + i * 0.5) % 1.0;
                                        if (progress > 0 && progress < 1) {
                                            let px = n1.pos.x + torusDir.x * progress;
                                            let py = n1.pos.y + torusDir.y * progress;
                                            
                                            ctx.fillStyle = 'rgba(147, 51, 234, 0.9)'; // Darker purple
                                            ctx.beginPath();
                                            ctx.arc(px, py, dotSize, 0, Math.PI * 2);
                                            ctx.fill();
                                            
                                            // Bright center
                                            ctx.fillStyle = 'rgba(192, 132, 252, 1.0)';
                                            ctx.beginPath();
                                            ctx.arc(px, py, dotSize * 0.5, 0, Math.PI * 2);
                                            ctx.fill();
                                        }
                                    }
                                    
                                    // Draw bond strength indicator
                                    if (dipBond > 10) {
                                        let midX = (n1.pos.x + n2.pos.x) / 2;
                                        let midY = (n1.pos.y + n2.pos.y) / 2;
                                        ctx.fillStyle = `rgba(59, 130, 246, ${Math.min(0.9, dipBond / 100)})`;
                                        ctx.font = '10px monospace';
                                        ctx.textAlign = 'center';
                                        ctx.fillText(Math.floor(dipBond), midX, midY - 5);
                                    }
                            } else if (bond.type === 'commercial') {
                                let comBond = bond.strength;
                                    // Use torus distance and direction for proper wrapping
                                    let bondLength = Vector.distTorus(n1.pos, n2.pos, this.width, this.height);
                                    let torusDir = Vector.subTorus(n1.pos, n2.pos, this.width, this.height);
                                    let normalizedDir = bondLength > 0 ? new Vector(torusDir.x / bondLength, torusDir.y / bondLength) : new Vector(0, 0);
                                    
                                    // Draw green striped line
                                    ctx.beginPath();
                                    ctx.moveTo(n1.pos.x, n1.pos.y);
                                    ctx.lineTo(n1.pos.x + torusDir.x, n1.pos.y + torusDir.y);
                                    let alpha = Math.min(0.8, comBond / 80);
                                    ctx.strokeStyle = `rgba(34, 197, 94, ${alpha})`; // Green
                                    ctx.lineWidth = Math.min(8, 1 + comBond / 15);
                                    ctx.setLineDash([10, 5]); // Striped pattern
                                    ctx.stroke();
                                    ctx.setLineDash([]); // Reset
                                    
                                    // Animated gold money dots moving along the bond in both directions
                                    let animOffset = (this.frame * 2) % (bondLength * 2);
                                    let dotSize = 4;
                                    
                                    // Gold dots moving from n1 to n2
                                    for (let i = 0; i < 2; i++) {
                                        let progress = (animOffset / bondLength + i * 0.5) % 1.0;
                                        if (progress > 0 && progress < 1) {
                                            let px = n1.pos.x + torusDir.x * progress;
                                            let py = n1.pos.y + torusDir.y * progress;
                                            
                                            ctx.fillStyle = 'rgba(251, 191, 36, 0.9)'; // Gold
                                            ctx.beginPath();
                                            ctx.arc(px, py, dotSize, 0, Math.PI * 2);
                                            ctx.fill();
                                            
                                            // Bright center
                                            ctx.fillStyle = 'rgba(253, 224, 71, 1.0)';
                                            ctx.beginPath();
                                            ctx.arc(px, py, dotSize * 0.5, 0, Math.PI * 2);
                                            ctx.fill();
                                        }
                                    }
                                    
                                    // Gold dots moving from n2 to n1 (opposite direction)
                                    for (let i = 0; i < 2; i++) {
                                        let progress = ((1 - animOffset / bondLength) + i * 0.5) % 1.0;
                                        if (progress > 0 && progress < 1) {
                                            let px = n1.pos.x + torusDir.x * progress;
                                            let py = n1.pos.y + torusDir.y * progress;
                                            
                                            ctx.fillStyle = 'rgba(234, 179, 8, 0.9)'; // Darker gold
                                            ctx.beginPath();
                                            ctx.arc(px, py, dotSize, 0, Math.PI * 2);
                                            ctx.fill();
                                            
                                            // Bright center
                                            ctx.fillStyle = 'rgba(253, 224, 71, 1.0)';
                                            ctx.beginPath();
                                            ctx.arc(px, py, dotSize * 0.5, 0, Math.PI * 2);
                                            ctx.fill();
                                        }
                                    }
                                    
                                    // Draw bond strength indicator
                                    if (comBond > 10) {
                                        let midX = (n1.pos.x + n2.pos.x) / 2;
                                        let midY = (n1.pos.y + n2.pos.y) / 2;
                                        ctx.fillStyle = `rgba(34, 197, 94, ${Math.min(0.9, comBond / 100)})`; // Green
                                        ctx.font = '10px monospace';
                                        ctx.textAlign = 'center';
                                        ctx.fillText(Math.floor(comBond), midX, midY + 10);
                                    }
                            }
                        }

                        // DRAW SPAWN POINT CIRCLES - Large colored circles at nest centers (tribe color)
                        // Drawn AFTER bonds so they appear on top (z-order: top)
                        this.tribes.nests.forEach(n => {
                            if (n.tribeId !== -1 && this.tribes.tribes[n.tribeId]) {
                                let tribe = this.tribes.tribes[n.tribeId];
                                let spawnRadius = 25 / 3; // 3X smaller than before (was 25, now ~8.33)
                                
                                // Draw large colored circle at nest center (spawn point) - fully opaque
                                this.ctx.fillStyle = tribe.color;
                                this.ctx.globalAlpha = 1.0; // Fully opaque
                                this.ctx.beginPath();
                                this.ctx.arc(n.pos.x, n.pos.y, spawnRadius, 0, Math.PI * 2);
                                this.ctx.fill();
                                
                                // Draw border for better visibility - fully opaque
                                this.ctx.strokeStyle = tribe.color;
                                this.ctx.globalAlpha = 1.0; // Fully opaque
                                this.ctx.lineWidth = 3;
                                this.ctx.stroke();
                                
                                // Reset alpha (already 1.0, but keeping for clarity)
                                this.ctx.globalAlpha = 1.0;
                            }
                        });
                        
                        // DRAW ALL OTHER ENTITIES INSIDE WORLD TILING LOOP
                        // This ensures they move together with the camera and nests
                        // Helper function to check if position is visible (accounting for torus wrapping)
                        const isVisible = (x, y, radius = 0) => {
                            // Check all wrapped copies - entity is visible if any copy is in viewport
                            for (let wx = -1; wx <= 1; wx++) {
                                for (let wy = -1; wy <= 1; wy++) {
                                    let wrappedX = x + wx * this.width;
                                    let wrappedY = y + wy * this.height;
                                    // Add margin for entity radius
                                    if (wrappedX + radius >= viewLeft && wrappedX - radius <= viewRight &&
                                        wrappedY + radius >= viewTop && wrappedY - radius <= viewBottom) {
                                        return true;
                                    }
                                }
                            }
                            return false;
                        };
                        
                        // Draw walls
                        this.walls.forEach(w => {
                            if (isVisible(w.pos.x, w.pos.y, w.radius)) {
                                w.draw(this.ctx);
                            }
                        });
                        
                        // Draw resources
                this.resources.forEach(r => {
                            if (!r || !r.active) return;
                            if (!isVisible(r.pos.x, r.pos.y, r.radius || r.config?.radius || 5)) return;
                    if (r.draw) r.draw(this.ctx);
                    else if (r.type === 'UNIQUE') {
                                if (!r.config || !r.config.color) return;
                        this.ctx.fillStyle = r.config.color;
                        this.ctx.beginPath();
                        this.ctx.arc(r.pos.x, r.pos.y, r.radius, 0, Math.PI * 2);
                        this.ctx.fill();
                        this.ctx.strokeStyle = '#ffffff';
                        this.ctx.lineWidth = 1;
                        this.ctx.stroke();
                    }
                });
                
                        // Draw agents
                        this.agents.forEach(a => {
                            if (isVisible(a.pos.x, a.pos.y, a.radius)) {
                                a.draw(this.ctx, a === this.selected);
                            }
                        });
                        
                        // Draw projectiles
                        this.projectiles.forEach(p => {
                            if (isVisible(p.pos.x, p.pos.y, p.radius || 3)) {
                                p.draw(this.ctx);
                            }
                        });
                        
                        // Draw spawn points
                        this.spawnPoints.forEach(sp => {
                            if (isVisible(sp.pos.x, sp.pos.y, sp.radius || 10)) {
                                sp.draw(this.ctx);
                            }
                        });
                        
                        // Draw plagues
                        this.plagues.forEach(p => {
                            if (p.life > 0 && isVisible(p.pos.x, p.pos.y, p.radius)) {
                                let alpha = 0.3 + 0.2 * Math.sin(this.frame * 0.1);
                                this.ctx.fillStyle = `rgba(34, 197, 94, ${alpha})`;
                                this.ctx.beginPath();
                                this.ctx.arc(p.pos.x, p.pos.y, p.radius, 0, Math.PI * 2);
                                this.ctx.fill();
                                this.ctx.strokeStyle = `rgba(34, 197, 94, 0.6)`;
                                this.ctx.lineWidth = 2;
                                this.ctx.stroke();
                            }
                        });
                        
                        // Draw particles (with reduced frequency for performance)
                        // Skip drawing if too many particles to prevent drawing issues during battles
                        if (this.particles.length < 250) {
                            let particleDrawInterval = 1;
                            let totalAgentsForParticles = this.agents.length;
                            if (totalAgentsForParticles > 120) {
                                particleDrawInterval = 2;
                            }
                            if (this.frame % particleDrawInterval === 0) {
                                // Skip drawing some particles if there are many (draw every other one)
                                let skipFactor = this.particles.length > 150 ? 2 : 1;
                                this.particles.forEach((p, idx) => {
                                    if (idx % skipFactor === 0 && isVisible(p.pos.x, p.pos.y, 2)) {
                                        p.draw(this.ctx);
                                    }
                                });
                            }
                        }
                        
                        this.ctx.restore(); // Restore context after drawing this world copy
                    }
                }
                this.ctx.restore(); // Restore clip region

                // ALL ENTITIES ARE NOW DRAWN INSIDE THE WORLD TILING LOOP (above)
                // This ensures they all move together with the camera and don't move independently
                
                // Restore zoom transformation
                this.ctx.restore();

                for (let tid in this.tribes.tribes) {
                    let tribe = this.tribes.tribes[tid];
                    if (!tribe || !tribe.leaderUnderAttack) continue;
                    let attacker = this.agents.find(a => a.id === tribe.leaderUnderAttackTargetId);
                    let leader = this.agents.find(a => a.id === tribe.leaderId);
                    if (!attacker || attacker.dead || !leader || leader.health <= 0 || Vector.dist(attacker.pos, leader.pos) > 500) {
                        tribe.leaderUnderAttack = false;
                        tribe.leaderUnderAttackTargetId = null;
                    }
                }

                // PERFORMANCE OPTIMIZATION: Track frame time for adaptive quality
                let currentFrameTime = performance.now();
                let frameDelta = currentFrameTime - this.lastFrameTime;
                this.lastFrameTime = currentFrameTime;
                
                // Get current agent count
                let currentAgentCount = this.agents.length;
                
                // If agent count dropped significantly (more than 30%), reset frame history and adjust stagger
                // This prevents the system from being stuck in slow mode after agent count decreases
                if (this.lastAgentCount > 0 && currentAgentCount < this.lastAgentCount * 0.7) {
                    // Agent count dropped significantly - reset frame history to allow quick recovery
                    this.frameTimeHistory = [];
                    // Reset stagger size based on current agent count
                    if (currentAgentCount <= 80) {
                        this.updateStaggerSize = 4; // Reset to minimum for low agent count
                    } else if (currentAgentCount <= 120) {
                        this.updateStaggerSize = Math.min(6, this.updateStaggerSize); // Cap at 6
                    } else {
                        this.updateStaggerSize = Math.min(8, this.updateStaggerSize); // Cap at 8
                    }
                }
                this.lastAgentCount = currentAgentCount;
                
                // Track frame time history (keep last 10 frames, but shorter if agent count is low)
                let historyLength = currentAgentCount > 120 ? 10 : 5; // Shorter history when agent count is low
                this.frameTimeHistory.push(frameDelta);
                if (this.frameTimeHistory.length > historyLength) {
                    this.frameTimeHistory.shift();
                }
                
                // Calculate average frame time
                if (this.frameTimeHistory.length > 0) {
                    this.avgFrameTime = this.frameTimeHistory.reduce((a, b) => a + b, 0) / this.frameTimeHistory.length;
                }
                
                // Adaptive quality: Consider both frame time AND agent count
                // If agent count is low, be more aggressive about reducing stagger
                let targetStaggerForCount = 4; // Default
                if (currentAgentCount > 150) {
                    targetStaggerForCount = 12;
                } else if (currentAgentCount > 120) {
                    targetStaggerForCount = 8;
                } else if (currentAgentCount > 80) {
                    targetStaggerForCount = 6;
                }
                
                // Adaptive quality: If frame time is too high, increase stagger size dramatically
                if (this.avgFrameTime > 30) { // > 30ms = < 33fps - CRITICAL
                    this.updateStaggerSize = Math.min(16, this.updateStaggerSize + 2); // Increase stagger aggressively
                } else if (this.avgFrameTime > 25) { // > 25ms = < 40fps
                    this.updateStaggerSize = Math.min(12, this.updateStaggerSize + 1); // Increase stagger
                } else if (this.avgFrameTime < 18) { // < 18ms = > 55fps - good performance
                    // Decrease stagger more aggressively when agent count is low
                    if (currentAgentCount <= 80) {
                        this.updateStaggerSize = Math.max(4, this.updateStaggerSize - 2); // Decrease faster for low count
                    } else if (currentAgentCount <= 120) {
                        this.updateStaggerSize = Math.max(4, this.updateStaggerSize - 1); // Decrease normally
                    } else {
                        // For high agent count, decrease slowly but also consider target for count
                        this.updateStaggerSize = Math.max(targetStaggerForCount, this.updateStaggerSize - 1);
                    }
                }
                
                // Also adjust based on agent count if frame time is reasonable
                if (this.avgFrameTime < 25 && this.updateStaggerSize > targetStaggerForCount) {
                    // Frame time is good but stagger is higher than needed for current agent count
                    this.updateStaggerSize = Math.max(targetStaggerForCount, this.updateStaggerSize - 1);
                }
                
                // CRITICAL: Skip frame entirely if frame time is extremely high (prevent jitter)
                if (this.avgFrameTime > 50) { // > 50ms = < 20fps - skip update entirely
                    // Still need to draw (with camera offset and wrapping) even if skipping update
                    this.ctx.fillStyle = '#111827';
                    this.ctx.fillRect(0, 0, this.width, this.height);
                    // Draw wrapped world (minimal - just background)
                    for (let dx = -1; dx <= 1; dx++) {
                        for (let dy = -1; dy <= 1; dy++) {
                            this.ctx.save();
                            this.ctx.translate(this.cameraX + dx * this.width, this.cameraY + dy * this.height);
                            // Minimal drawing here if needed
                            this.ctx.restore();
                        }
                    }

                this.updateUI();
                this.frame++;
                    requestAnimationFrame(() => this.loop());
                    return; // Skip this frame's update
                }

                    this.updateUI();
                    this.frame++;
                    
                    // PERFORMANCE: Periodic cleanup every 300 frames (5 seconds at 60fps)
                    if (this.frame % 300 === 0) {
                        // Aggressive cleanup after intense periods
                        // PERFORMANCE: Quick count check without expensive filtering
                        let deadCount = 0;
                        let inactiveCount = 0;
                        for (let a of this.agents) {
                            if (a.dead) deadCount++;
                        }
                        for (let r of this.resources) {
                            if (!r.active) inactiveCount++;
                        }
                        
                        // If there are many dead entities, trigger cleanup
                        if (deadCount > 50 || inactiveCount > 100) {
                            this._cleanupAfterLargeDieOff();
                        }
                        
                        // Cleanup particles - use quick slice instead of filter if possible
                        if (this.particles.length > 200) {
                            // Quick cap without filtering - particles will be filtered in periodic cleanup
                            this.particles = this.particles.slice(-200);
                        }
                        if (this.projectiles.length > 50) {
                            // Projectiles removed - no cleanup needed
                        }
                        if (this.plagues.length > 15) {
                            this.plagues = this.plagues.filter(p => p.life > 0).slice(-15);
                        }
                    }
                
                requestAnimationFrame(() => this.loop());
            }
        }

        function togglePanel(panelId, toggleId, forceOpen) {
            const panel = document.getElementById(panelId);
            const toggle = document.getElementById(toggleId);
            if (!panel || !toggle) return;
            const isOpen = !panel.classList.contains('hidden');
            const shouldOpen = forceOpen === undefined ? !isOpen : Boolean(forceOpen);
            panel.classList.toggle('hidden', !shouldOpen);
            toggle.classList.toggle('hidden', shouldOpen);
        }

        function toggleTribePanel(forceOpen) {
            togglePanel('tribe-panel', 'tribe-toggle-btn', forceOpen);
        }

        function toggleLegendPanel(forceOpen) {
            togglePanel('legend-panel', 'legend-toggle-btn', forceOpen);
        }

        function toggleHUDPanel(forceOpen) {
            const panel = document.getElementById('hud-panel');
            const collapsed = document.getElementById('hud-collapsed-btn');
            if (!panel || !collapsed) return;
            const isOpen = !panel.classList.contains('hidden');
            const shouldOpen = forceOpen === undefined ? !isOpen : Boolean(forceOpen);
            panel.classList.toggle('hidden', !shouldOpen);
            collapsed.classList.toggle('hidden', shouldOpen);
        }

        var sim = new Simulation();
        sim.loop();
        
    </script>
</body>
</html>
