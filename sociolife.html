
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SocioLife: Social Artificial Life</title>
    <!--
        SOCIOLIFE - Social Artificial Life Simulation
        
        Author: Nova Spivack
        Website: www.novaspivack.com
        License: Creative Commons Attribution-NonCommercial 4.0 International (CC BY-NC 4.0)
        License URL: https://creativecommons.org/licenses/by-nc/4.0/
        
        You are free to share and adapt this work for non-commercial purposes with proper attribution to Nova Spivack.
        
        BACKGROUND MUSIC ATTRIBUTION:
        "Life Ambient" by Serge Quadrado
        Source: Free Music Archive
        License: CC BY-NC-SA (Creative Commons Attribution-NonCommercial-ShareAlike)
        URL: https://www.novaspivack.com/wp-content/uploads/2025/11/Serge-Quadrado-Life-Ambient.mp3
        
        This work is licensed under CC BY-NC-SA 4.0
    -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #111827; color: #e5e7eb; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        canvas { display: block; cursor: crosshair; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        .panel { pointer-events: auto; background: rgba(17, 24, 39, 0.95); backdrop-filter: blur(4px); border: 1px solid #374151; }
        .stat-row { display: flex; justify-content: space-between; margin-bottom: 2px; font-size: 0.75rem; align-items: center;}
        .bar-container { width: 50px; height: 5px; background: #374151; border-radius: 3px; overflow: hidden; margin-left: 6px;}
        .bar-fill { height: 100%; transition: width 0.2s; }
        .dot { width: 8px; height: 8px; border-radius: 50%; display: inline-block; margin-right: 6px; }
        
        /* Custom Scrollbar for settings */
        .custom-scroll::-webkit-scrollbar { width: 6px; }
        .custom-scroll::-webkit-scrollbar-track { background: #1f2937; }
        .custom-scroll::-webkit-scrollbar-thumb { background: #4b5563; border-radius: 3px; }
        .custom-scroll::-webkit-scrollbar-thumb:hover { background: #6b7280; }
        .ui-control { pointer-events: auto; }
        
        input[type=range] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            background: transparent;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; height: 12px; width: 12px; border-radius: 50%; background: #3b82f6; cursor: pointer; margin-top: -4px;
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%; height: 4px; cursor: pointer; background: #374151; border-radius: 2px;
        }
        
        .active-tool { border-color: #ef4444 !important; background-color: #7f1d1d !important; box-shadow: 0 0 10px #ef4444; }
        .active-tool-monster { border-color: #a855f7 !important; background-color: #581c87 !important; box-shadow: 0 0 10px #a855f7; }
    </style>
</head>
<body>

    <!-- Canvas Layer -->
    <canvas id="simCanvas"></canvas>

    <!-- UI Layer -->
    <div id="ui-layer" class="relative flex flex-col justify-between p-4">
        <div id="hud-collapsed-btn" class="hidden absolute top-4 right-4 z-30" style="pointer-events:auto;">
            <button onclick="toggleHUDPanel(true)" class="ui-control text-[10px] uppercase tracking-wider text-white bg-black/60 hover:bg-black/80 px-3 py-1 rounded-full shadow-lg border border-white/20">Show HUD</button>
        </div>
        
        <!-- Top Bar -->
        <div id="hud-panel" class="panel rounded-lg p-4 w-full max-w-7xl mx-auto flex flex-wrap gap-6 justify-between items-center shadow-lg z-10 relative">
            <div>
                <h1 class="text-xl font-bold text-blue-400 tracking-tight">SocioLife <span class="text-xs text-gray-400 font-normal">v31.3 (Stability)</span></h1>
                <div class="text-xs text-gray-400">Gen: <span id="gen-count" class="text-white">0</span> | Time: <span id="time-count">0</span></div>
                <div class="text-[10px] text-red-400 font-bold hidden" id="crisis-alert">‚ö†Ô∏è EXTINCTION RISK - REPRO RATE UP ‚ö†Ô∏è</div>
                <div class="text-[10px] text-green-400 font-bold hidden" id="tool-alert">‚ö†Ô∏è INFECTION TOOL ACTIVE - CLICK TO DROP ‚ö†Ô∏è</div>
                <div class="text-[10px] text-green-300 font-bold" id="status-alert">‚ú® Life Signs Healthy ‚ú®</div>
            </div>
            
            <div class="flex gap-4 text-sm">
                <div class="text-center">
                    <div class="text-gray-500 text-xs uppercase">Agents</div>
                    <div class="font-mono text-lg font-bold" id="pop-count">0</div>
                </div>
                <div class="text-center">
                    <div class="text-gray-500 text-xs uppercase text-green-500">Food</div>
                    <div class="font-mono text-lg" id="res-green">0</div>
                </div>
                <div class="text-center">
                    <div class="text-gray-500 text-xs uppercase text-yellow-500">Material</div>
                    <div class="font-mono text-lg" id="res-gold">0</div>
                </div>
                <div class="text-center">
                    <div class="text-gray-500 text-xs uppercase text-cyan-400">Treas</div>
                    <div class="font-mono text-lg" id="res-treasure">0</div>
                </div>
                <div class="text-center pl-4 border-l border-gray-700">
                    <div class="text-gray-500 text-xs uppercase text-red-500">Sick</div>
                    <div class="font-mono text-lg text-red-400" id="stat-infected">0</div>
                </div>
                <div class="text-center">
                    <div class="text-gray-500 text-xs uppercase text-blue-400">Immune</div>
                    <div class="font-mono text-lg text-blue-400" id="stat-immune">0</div>
                </div>
            </div>

            <div class="flex gap-2 items-center">
                <button onclick="sim.setTool('nest')" id="btn-nest" class="px-3 py-1 bg-orange-900/80 hover:bg-orange-700 rounded text-xs border border-orange-500 transition text-white font-bold">Place Nest</button>
                <button onclick="sim.setTool('boon')" id="btn-boon" class="px-3 py-1 bg-yellow-900/80 hover:bg-yellow-700 rounded text-xs border border-yellow-500 transition text-white font-bold">Place Boon</button>
                <button onclick="sim.setTool('infect')" id="btn-infect" class="px-3 py-1 bg-green-900/80 hover:bg-green-700 rounded text-xs border border-green-500 transition text-white font-bold">Place Germs</button>
                <button onclick="sim.setTool('monster')" id="btn-monster" class="px-3 py-1 bg-purple-900/80 hover:bg-purple-700 rounded text-xs border border-purple-500 transition text-white font-bold">Place Monster</button>
                <select id="agent-type-select" onchange="sim.setTool('agent-' + this.value)" class="px-2 py-1 bg-indigo-900/80 hover:bg-indigo-700 rounded text-xs border border-indigo-500 transition text-white font-bold">
                    <option value="">Place Agents...</option>
                    <option value="Soldier">Place Soldiers</option>
                    <option value="Farmer">Place Farmers</option>
                    <option value="Merchant">Place Merchants</option>
                    <option value="Diplomat">Place Diplomats</option>
                    <option value="Scientist">Place Scientists</option>
                    <option value="Artisan">Place Artisans</option>
                    <option value="Guardian">Place Guardians</option>
                    <option value="Raider">Place Raiders</option>
                    <option value="Gatherer">Place Gatherers</option>
                    <option value="Scout">Place Scouts</option>
                    <option value="Builder">Place Builders</option>
                    <option value="Miner">Place Miners</option>
                    <option value="Botanist">Place Botanists</option>
                    <option value="Teacher">Place Teachers</option>
                    <option value="Garbage Collector">Place Garbage Collectors</option>
                </select>
                <button onclick="sim.reset()" class="px-3 py-1 bg-red-900/50 hover:bg-red-700 rounded text-xs border border-red-700 transition">Reset</button>
                <button onclick="sim.togglePause()" class="px-3 py-1 bg-blue-900/50 hover:bg-blue-700 rounded text-xs border border-blue-700 transition" id="pause-btn">Pause</button>
                
                <!-- Sound Controls -->
                <div class="flex items-center gap-2 px-3 py-1 bg-gray-800/50 rounded text-xs border border-gray-600">
                    <label class="flex items-center gap-1 cursor-pointer">
                        <input type="checkbox" id="sound-toggle" onchange="sim.toggleSound(this.checked)" class="w-4 h-4">
                        <span class="text-white text-xs">üîä</span>
                    </label>
                    <input type="range" id="volume-slider" min="0" max="1" step="0.1" value="0.3" 
                           oninput="sim.updateVolume(this.value)" 
                           class="w-16 h-2" style="accent-color: #10b981;">
                    <span id="volume-display" class="text-white text-xs font-mono">30%</span>
                </div>
                
                <button onclick="sim.toggleSettings()" class="ml-2 p-1 text-gray-400 hover:text-white transition" title="Settings">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" />
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                    </svg>
                </button>
                <button onclick="sim.toggleAbout()" class="ml-2 px-3 py-1 bg-blue-900/70 border border-blue-500 rounded-lg shadow-lg text-white text-xs hover:bg-blue-800" title="About SocioLife">
                    About
                </button>
                <button onclick="toggleHUDPanel()" class="ui-control ml-2 px-3 py-1 text-[10px] uppercase tracking-wide text-gray-200 bg-white/10 border border-white/20 rounded-full shadow-sm hover:bg-white/20">Collapse HUD</button>
            </div>
        </div>

        <!-- About Modal -->
        <div id="about-modal" class="panel absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 p-6 rounded-xl hidden shadow-2xl w-96 md:w-[600px] z-50 border border-blue-900/50 max-h-[80vh] flex flex-col">
            <div class="flex justify-between items-center mb-4 border-b border-gray-700 pb-3">
                <div class="text-center flex-1">
                    <h2 class="text-2xl font-bold text-blue-400 mb-1">SocioLife</h2>
                    <p class="text-sm text-gray-400">by <a href="http://www.novaspivack.com" target="_blank" class="text-blue-300 hover:text-blue-200">Nova Spivack</a></p>
                    <p class="text-xs text-cyan-300 mt-1"><a href="http://www.novaspivack.com" target="_blank" class="hover:text-cyan-200">www.novaspivack.com</a></p>
                    <p class="text-[10px] text-gray-500 mt-2">
                        Licensed under <a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" class="text-cyan-400 hover:text-cyan-300">Creative Commons Attribution-NonCommercial 4.0 International (CC BY-NC 4.0)</a>
                    </p>
                    <p class="text-[10px] text-gray-600 mt-1">Non-Commercial Use with Attribution</p>
                </div>
                <button onclick="sim.toggleAbout()" class="text-gray-400 hover:text-white text-xl font-bold ml-4">&times;</button>
            </div>
            
            <div class="overflow-y-auto pr-2 custom-scroll flex-1">
                <div class="text-sm text-gray-300 space-y-3">
                    <p class="font-bold text-blue-300">About SocioLife</p>
                    <p>SocioLife is an advanced artificial life simulation exploring emergent social behaviors, tribal dynamics, economic systems, warfare, diplomacy, and technological evolution in a complex multi-agent ecosystem.</p>
                    
                    <p class="font-bold text-blue-300 mt-4">Game Mechanics</p>
                    
                    <p class="font-semibold text-cyan-300 mt-2 text-xs">Economic System</p>
                    <ul class="list-disc list-inside space-y-1 text-xs ml-2">
                        <li><strong>Commercial Bonds:</strong> Tribes form trade relationships (cyan/blue dashed lines) that provide mutual economic benefits. Both parties gain wealth from trade, with stronger bonds providing greater benefits. Commercial bonds increase resource production (food, materials, ore, treasure) and spawn more money-making roles (Merchants, Artisans, Miners, Builders, Farmers).</li>
                        <li><strong>Taxation:</strong> Tribes tax their populations on all forms of value (energy, wealth, and resources). Taxes are converted to what the tribe needs most - if a nest needs health, taxes convert to HP; otherwise they convert to wealth. This ensures tribes can sustain themselves through their populations' economic activity.</li>
                        <li><strong>Resource Value Scale:</strong> Resources have different values from least (Food) to most (Treasure). Higher-value resources provide more energy and wealth when collected. Agents prioritize gathering valuable resources.</li>
                        <li><strong>Population-Based Wealth:</strong> Nests generate wealth based on their population size and productive roles, creating a balanced economic system where larger, more productive tribes are naturally wealthier.</li>
                    </ul>
                    
                    <p class="font-semibold text-cyan-300 mt-2 text-xs">Diplomacy</p>
                    <ul class="list-disc list-inside space-y-1 text-xs ml-2">
                        <li><strong>Diplomatic Bonds:</strong> Tribes form alliances (yellow/gold lines) through Diplomats who visit other nests. Strong diplomatic bonds provide humanitarian aid - allies send wealth and HP to help struggling partners, but only if they can afford it without risking their own survival.</li>
                        <li><strong>Wartime Aggressive Diplomacy:</strong> When a tribe is at war, their Diplomats aggressively seek alliances with enemies of their opponent and neutral parties, forming strategic partnerships to strengthen their position.</li>
                        <li><strong>Reconstruction Aid:</strong> After a war, diplomatic partners of the winner receive a boon in resources and economy, rewarding alliance during conflict.</li>
                        <li><strong>Diplomatic Aid Conditions:</strong> Allies only provide aid if they are healthy, wealthy, not in too many wars, and the aid won't put their own nest at risk.</li>
                    </ul>
                    
                    <p class="font-semibold text-cyan-300 mt-2 text-xs">War System</p>
                    <ul class="list-disc list-inside space-y-1 text-xs ml-2">
                        <li><strong>War Bonds:</strong> Warring tribes are connected by angry red dashed bonds with animated particles moving both ways, clearly showing active conflicts.</li>
                        <li><strong>War Costs:</strong> Wars are expensive - both nests and agents consume significantly more energy during conflicts. Structural damage to nests increases with each active war, creating stacking penalties for multiple simultaneous conflicts.</li>
                        <li><strong>Spoils of War:</strong> When a nest is defeated, its wealth, resources, energy, and structural value (treasure) are divided among the winning tribes. If there are no war winners, all value is scattered widely around the nest location as random resources.</li>
                        <li><strong>Citizen Conversion:</strong> All citizens (agents) of a defeated tribe are converted to the winning tribe(s), distributed randomly among the victors.</li>
                        <li><strong>Post-War Reconstruction (Baby Boom):</strong> War winners experience a massive baby boom - their wealth doubles immediately, HP is restored, and they spawn agents at greatly increased rates for an extended period. During this time, they receive continuous wealth generation and resource spawning to support the larger population.</li>
                        <li><strong>War-Time Spawning:</strong> During war, nests spawn fighting roles (Soldiers, Raiders, Guardians) at greatly increased rates to support the conflict.</li>
                    </ul>
                    
                    <p class="font-semibold text-cyan-300 mt-2 text-xs">Agent Bonds</p>
                    <ul class="list-disc list-inside space-y-1 text-xs ml-2">
                        <li><strong>Elastic Bonds:</strong> Flexible white bonds between agents that allow movement and stretching. These represent friendships, alliances, and social connections.</li>
                        <li><strong>Rigid Bonds:</strong> Strong red-orange bonds (thicker lines) that are harder to break and provide stability bonuses. These represent deep commitments and family ties.</li>
                        <li><strong>Group Formation:</strong> Agents with multiple bonds can form stable groups that provide enhanced capabilities, combat bonuses, and shared resources.</li>
                    </ul>
                    
                    <p class="font-semibold text-cyan-300 mt-2 text-xs">Nest Survival</p>
                    <ul class="list-disc list-inside space-y-1 text-xs ml-2">
                        <li><strong>Dying Nest Recovery:</strong> When a nest is in distress (low HP or wealth), it activates emergency survival mechanisms: raises taxes from agents, spawns more resource-gathering workers, and directly produces resources to aid recovery.</li>
                        <li><strong>Structural Health:</strong> Nests have structural health that represents accumulated infrastructure. When a nest dies, this structural value becomes treasure distributed to winners or scattered as resources.</li>
                    </ul>
                    
                    <p class="font-bold text-blue-300 mt-4">Key Features</p>
                    <ul class="list-disc list-inside space-y-1 text-xs">
                        <li>Complex agent-based simulation with genetic inheritance and evolution</li>
                        <li>Multi-tribal societies with dynamic diplomatic and commercial relations</li>
                        <li>Technological progression through research trees and specialized roles</li>
                        <li>Specialized agent roles: soldiers, merchants, diplomats, artisans, scientists, farmers, miners, builders, and more</li>
                        <li>Food chain ecology with predators, prey, and grazers</li>
                        <li>Resource management with value-based economy (food to treasure scale)</li>
                        <li>Group agents: agents can form stable groups with enhanced capabilities</li>
                        <li>Nest system: tribes build and maintain nests that spawn agents and manage resources</li>
                    </ul>
                    
                    <p class="font-bold text-blue-300 mt-4">How to Use</p>
                    <ul class="list-disc list-inside space-y-1 text-xs">
                        <li>Click the canvas to spawn new agents at that location</li>
                        <li>Use the Infect Tool to introduce plagues (cataclysms) that spread disease</li>
                        <li>Spawn Monsters to disrupt civilizations and test defenses</li>
                        <li>Adjust settings in the Settings panel to explore different dynamics</li>
                        <li>Click agents to inspect their DNA, relationships, and status</li>
                        <li>Watch as tribes evolve, trade, form alliances, wage wars, and develop technology</li>
                        <li>Observe bonds: yellow for diplomacy, cyan for commerce, red for war between nests; white/red-orange for agent bonds</li>
                        <li>Monitor the HUD for population, generation count, and other statistics</li>
                    </ul>
                    
                    <p class="font-bold text-blue-300 mt-4">Tips</p>
                    <ul class="list-disc list-inside space-y-1 text-xs">
                        <li>Increase birth rate if populations are declining too quickly</li>
                        <li>Adjust bonding rate to see different social structures and group formations</li>
                        <li>Change energy burn rate to affect survival pressure and population dynamics</li>
                        <li>Experiment with tech progression speeds to see how technology affects gameplay</li>
                        <li>Enable sound for audio feedback on key events (births, deaths, trades, diplomacy, wars)</li>
                        <li>Watch for wartime diplomacy: tribes at war will seek allies among enemies of their opponents</li>
                        <li>Economic bonds provide mutual benefits: both parties gain wealth from trade</li>
                        <li>War winners receive spoils, convert defeated citizens, and experience extended baby booms</li>
                        <li>Agents automatically eat food when they touch it if not at full energy</li>
                        <li>All resource types convert to useful value (energy or wealth) for agents, tribes, and nests</li>
                    </ul>
                    
                    <p class="font-bold text-blue-300 mt-4">Links</p>
                    <p class="text-xs">
                        Website: <a href="https://www.novaspivack.com" target="_blank" class="text-cyan-400 hover:text-cyan-300 underline">www.novaspivack.com</a><br>
                        GitHub: <a href="https://github.com/novaspivack" target="_blank" class="text-cyan-400 hover:text-cyan-300 underline">github.com/novaspivack</a>
                    </p>
                    
                    <p class="font-bold text-blue-300 mt-4">License</p>
                    <p class="text-xs">This work is licensed under the Creative Commons Attribution-NonCommercial 4.0 International License. You are free to share and adapt this work for non-commercial purposes with proper attribution to Nova Spivack.</p>
                    
                    <p class="text-xs text-gray-500 mt-4">¬© 2024 Nova Spivack. All rights reserved.</p>
                </div>
            </div>
        </div>

        <!-- Settings Modal -->
        <div id="settings-modal" class="panel absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 p-5 rounded-xl hidden shadow-2xl w-80 md:w-96 z-50 border border-blue-900/50">
            <div class="flex justify-between items-center mb-4 border-b border-gray-700 pb-2">
                <h2 class="text-lg font-bold text-white flex items-center gap-2">
                    <span class="w-2 h-2 bg-blue-500 rounded-full inline-block"></span> Global Controls
                </h2>
                <button onclick="sim.toggleSettings()" class="text-gray-400 hover:text-white text-xl font-bold">&times;</button>
            </div>
            
            <div class="space-y-4 max-h-[60vh] overflow-y-auto pr-2 custom-scroll" id="settings-content">
                <!-- Resource Controls -->
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Res Spawn Rate</span>
                        <span id="val-resSpawnRate" class="text-blue-400 font-mono">0.8</span>
                    </div>
                    <input type="range" min="0" max="1" step="0.05" oninput="sim.updateConfig('resSpawnRate', this.value)" id="in-resSpawnRate">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Food Spawn Rate</span>
                        <span id="val-foodSpawnRate" class="text-green-400 font-mono">0.6</span>
                    </div>
                    <input type="range" min="0" max="1" step="0.05" oninput="sim.updateConfig('foodSpawnRate', this.value)" id="in-foodSpawnRate">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Food Spawn Near Nests</span>
                        <span id="val-foodSpawnNearNestsRate" class="text-green-400 font-mono">0.1</span>
                    </div>
                    <input type="range" min="0" max="1" step="0.05" oninput="sim.updateConfig('foodSpawnNearNestsRate', this.value)" id="in-foodSpawnNearNestsRate">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Food Nutritional Value</span>
                        <span id="val-foodNutritionalValue" class="text-green-400 font-mono">1.0</span>
                    </div>
                    <input type="range" min="0.1" max="2.0" step="0.1" oninput="sim.updateConfig('foodNutritionalValue', this.value)" id="in-foodNutritionalValue">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Treasure Rate</span>
                        <span id="val-treasureSpawnRate" class="text-cyan-400 font-mono">0.005</span>
                    </div>
                    <input type="range" min="0" max="0.05" step="0.001" oninput="sim.updateConfig('treasureSpawnRate', this.value)" id="in-treasureSpawnRate">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Build Rate (Success %)</span>
                        <span id="val-buildRate" class="text-yellow-500 font-mono">1.0</span>
                    </div>
                    <input type="range" min="0" max="1" step="0.1" oninput="sim.updateConfig('buildRate', this.value)" id="in-buildRate">
                </div>

                <div class="border-t border-gray-700 my-2"></div>

                <!-- Social Controls -->
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Love Threshold</span>
                        <span id="val-loveThreshold" class="text-pink-400 font-mono">60</span>
                    </div>
                    <input type="range" min="0" max="100" step="5" oninput="sim.updateConfig('loveThreshold', this.value)" id="in-loveThreshold">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Hate Threshold</span>
                        <span id="val-hateThreshold" class="text-red-500 font-mono">-30</span>
                    </div>
                    <input type="range" min="-100" max="0" step="5" oninput="sim.updateConfig('hateThreshold', this.value)" id="in-hateThreshold">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Bonding Rate (Mult)</span>
                        <span id="val-bondingRate" class="text-white font-mono">3.7</span>
                    </div>
                    <input type="range" min="0" max="10" step="0.1" oninput="sim.updateConfig('bondingRate', this.value)" id="in-bondingRate">
                </div>
                 <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Bond Break Chance</span>
                        <span id="val-bondBreakRate" class="text-red-300 font-mono">0.0006</span>
                    </div>
                    <input type="range" min="0" max="0.01" step="0.0001" oninput="sim.updateConfig('bondBreakRate', this.value)" id="in-bondBreakRate">
                </div>

                <div class="border-t border-gray-700 my-2"></div>

                <!-- Pop Controls -->
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Population Cap</span>
                        <span id="val-popCap" class="text-blue-400 font-mono">170</span>
                    </div>
                    <input type="range" min="20" max="300" step="10" oninput="sim.updateConfig('popCap', this.value)" id="in-popCap">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Mate Cost (Energy)</span>
                        <span id="val-mateCost" class="text-blue-400 font-mono">30</span>
                    </div>
                    <input type="range" min="10" max="200" step="5" oninput="sim.updateConfig('mateCost', this.value)" id="in-mateCost">
                </div>
                <!-- Birth/Death Controls -->
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Birth Rate (Speed)</span>
                        <span id="val-birthRate" class="text-green-400 font-mono">5.4</span>
                    </div>
                    <input type="range" min="0.1" max="15.0" step="0.1" oninput="sim.updateConfig('birthRate', this.value)" id="in-birthRate">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Death Rate (Life %)</span>
                        <span id="val-deathRate" class="text-gray-400 font-mono">0.5</span>
                    </div>
                    <input type="range" min="0.1" max="3.0" step="0.1" oninput="sim.updateConfig('deathRate', this.value)" id="in-deathRate">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Baby Growth Rate</span>
                        <span id="val-babyGrowthRate" class="text-pink-300 font-mono">0.2</span>
                    </div>
                    <input type="range" min="0.05" max="1.0" step="0.05" oninput="sim.updateConfig('babyGrowthRate', this.value)" id="in-babyGrowthRate">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Energy Burn Rate</span>
                        <span id="val-energyBurnRate" class="text-orange-400 font-mono">0.03</span>
                    </div>
                    <input type="range" min="0.01" max="0.5" step="0.01" oninput="sim.updateConfig('energyBurnRate', this.value)" id="in-energyBurnRate">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Damage Rate (Combat)</span>
                        <span id="val-damageRate" class="text-red-400 font-mono">0.05</span>
                    </div>
                    <input type="range" min="0.01" max="0.5" step="0.01" oninput="sim.updateConfig('damageRate', this.value)" id="in-damageRate">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Tribal Tax Rate</span>
                        <span id="val-tribalTaxRate" class="text-yellow-400 font-mono">0.1</span>
                    </div>
                    <input type="range" min="0" max="0.5" step="0.01" oninput="sim.updateConfig('tribalTaxRate', this.value)" id="in-tribalTaxRate">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Group Agent Tax Premium</span>
                        <span id="val-groupAgentTaxPremium" class="text-yellow-400 font-mono">0.05</span>
                    </div>
                    <input type="range" min="0" max="0.2" step="0.01" oninput="sim.updateConfig('groupAgentTaxPremium', this.value)" id="in-groupAgentTaxPremium">
                </div>

                <div class="border-t border-gray-700 my-2"></div>

                <!-- Evolution Controls -->
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Mutation Rate</span>
                        <span id="val-mutationRate" class="text-purple-400 font-mono">0.25</span>
                    </div>
                    <input type="range" min="0" max="0.5" step="0.01" oninput="sim.updateConfig('mutationRate', this.value)" id="in-mutationRate">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Monster Lifespan</span>
                        <span id="val-monsterLifespan" class="text-purple-500 font-mono">2500</span>
                    </div>
                    <input type="range" min="500" max="10000" step="100" oninput="sim.updateConfig('monsterLifespan', this.value)" id="in-monsterLifespan">
                </div>
                
                <div class="text-[11px] font-bold text-gray-500 uppercase mt-3 mb-2 border-t border-gray-700 pt-2">Group Benefits</div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Range Bonus/Member</span>
                        <span id="val-groupRangeBonus" class="text-cyan-300 font-mono">0.02</span>
                    </div>
                    <input type="range" min="0" max="0.1" step="0.01" oninput="sim.updateConfig('groupRangeBonus', this.value)" id="in-groupRangeBonus">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Damage Bonus/Member</span>
                        <span id="val-groupDamageBonus" class="text-red-300 font-mono">0.03</span>
                    </div>
                    <input type="range" min="0" max="0.1" step="0.01" oninput="sim.updateConfig('groupDamageBonus', this.value)" id="in-groupDamageBonus">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Defense Bonus/Member</span>
                        <span id="val-groupDefenseBonus" class="text-blue-300 font-mono">0.03</span>
                    </div>
                    <input type="range" min="0" max="0.1" step="0.01" oninput="sim.updateConfig('groupDefenseBonus', this.value)" id="in-groupDefenseBonus">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Healing Bonus/Member</span>
                        <span id="val-groupHealingBonus" class="text-green-300 font-mono">0.02</span>
                    </div>
                    <input type="range" min="0" max="0.1" step="0.01" oninput="sim.updateConfig('groupHealingBonus', this.value)" id="in-groupHealingBonus">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Energy Cost/Member</span>
                        <span id="val-groupEnergyCost" class="text-yellow-300 font-mono">0.08</span>
                    </div>
                    <input type="range" min="0" max="0.2" step="0.005" oninput="sim.updateConfig('groupEnergyCost', this.value)" id="in-groupEnergyCost">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Group Agent Elastic Bond Max Length</span>
                        <span id="val-groupAgentElasticBondMaxLength" class="text-purple-300 font-mono">180</span>
                    </div>
                    <input type="range" min="100" max="300" step="10" oninput="sim.updateConfig('groupAgentElasticBondMaxLength', this.value)" id="in-groupAgentElasticBondMaxLength">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Group Agent Min Members</span>
                        <span id="val-groupAgentMinMembers" class="text-purple-300 font-mono">5</span>
                    </div>
                    <input type="range" min="3" max="10" step="1" oninput="sim.updateConfig('groupAgentMinMembers', this.value)" id="in-groupAgentMinMembers">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Group Agent Max Members</span>
                        <span id="val-groupAgentMaxMembers" class="text-purple-300 font-mono">7</span>
                    </div>
                    <input type="range" min="4" max="12" step="1" oninput="sim.updateConfig('groupAgentMaxMembers', this.value)" id="in-groupAgentMaxMembers">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Group Agent Min Age (frames)</span>
                        <span id="val-groupAgentMinAge" class="text-purple-300 font-mono">500</span>
                    </div>
                    <input type="range" min="500" max="5000" step="100" oninput="sim.updateConfig('groupAgentMinAge', this.value)" id="in-groupAgentMinAge">
                </div>
                
                <div class="text-[11px] font-bold text-gray-500 uppercase mt-3 mb-2 border-t border-gray-700 pt-2">Rigid Bonds</div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Rigid Bond Chance</span>
                        <span id="val-rigidBondChance" class="text-orange-300 font-mono">0.85</span>
                    </div>
                    <input type="range" min="0" max="1" step="0.05" oninput="sim.updateConfig('rigidBondChance', this.value)" id="in-rigidBondChance">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Rigid Bond Length</span>
                        <span id="val-rigidBondLength" class="text-red-300 font-mono">40</span>
                    </div>
                    <input type="range" min="20" max="100" step="5" oninput="sim.updateConfig('rigidBondLength', this.value)" id="in-rigidBondLength">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Rigid Bond Stiffness</span>
                        <span id="val-rigidBondStiffness" class="text-red-300 font-mono">0.15</span>
                    </div>
                    <input type="range" min="0.05" max="0.5" step="0.01" oninput="sim.updateConfig('rigidBondStiffness', this.value)" id="in-rigidBondStiffness">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Formation Bonus</span>
                        <span id="val-rigidBondFormationBonus" class="text-green-300 font-mono">1.5</span>
                    </div>
                    <input type="range" min="0" max="5" step="0.1" oninput="sim.updateConfig('rigidBondFormationBonus', this.value)" id="in-rigidBondFormationBonus">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Break Resistance</span>
                        <span id="val-rigidBondBreakResistance" class="text-blue-300 font-mono">0.5</span>
                    </div>
                    <input type="range" min="0" max="1" step="0.05" oninput="sim.updateConfig('rigidBondBreakResistance', this.value)" id="in-rigidBondBreakResistance">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Nest Bond Penalty</span>
                        <span id="val-nestBondedPenalty" class="text-yellow-300 font-mono">0.3</span>
                    </div>
                    <input type="range" min="0" max="1" step="0.05" oninput="sim.updateConfig('nestBondedPenalty', this.value)" id="in-nestBondedPenalty">
                </div>
                
                <div class="text-[11px] font-bold text-gray-500 uppercase mt-3 mb-2 border-t border-gray-700 pt-2">Nest Splitting</div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Split Population</span>
                        <span id="val-nestSplitPopulation" class="text-cyan-300 font-mono">35</span>
                    </div>
                    <input type="range" min="15" max="100" step="5" oninput="sim.updateConfig('nestSplitPopulation', this.value)" id="in-nestSplitPopulation">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Parent Nest Keeps</span>
                        <span id="val-nestSplitParentRetain" class="text-cyan-300 font-mono">70%</span>
                    </div>
                    <input type="range" min="0.5" max="0.9" step="0.05" oninput="sim.updateConfig('nestSplitParentRetain', this.value)" id="in-nestSplitParentRetain">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Split Max Radius</span>
                        <span id="val-nestSplitMaxRadius" class="text-cyan-300 font-mono">105</span>
                    </div>
                    <input type="range" min="70" max="300" step="5" oninput="sim.updateConfig('nestSplitMaxRadius', this.value)" id="in-nestSplitMaxRadius">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Nest HP Decay Rate</span>
                        <span id="val-nestHpDecayRate" class="text-red-300 font-mono">0.02</span>
                    </div>
                    <input type="range" min="0" max="0.1" step="0.001" oninput="sim.updateConfig('nestHpDecayRate', this.value)" id="in-nestHpDecayRate">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Nest Agent Spawn Rate</span>
                        <span id="val-nestAgentSpawnRate" class="text-green-300 font-mono">0.02</span>
                    </div>
                    <input type="range" min="0" max="0.2" step="0.001" oninput="sim.updateConfig('nestAgentSpawnRate', this.value)" id="in-nestAgentSpawnRate">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Merge Distance</span>
                        <span id="val-nestMergeDistance" class="text-cyan-300 font-mono">80</span>
                    </div>
                    <input type="range" min="40" max="200" step="10" oninput="sim.updateConfig('nestMergeDistance', this.value)" id="in-nestMergeDistance">
                </div>
                
                <div class="text-[11px] font-bold text-gray-500 uppercase mt-3 mb-2 border-t border-gray-700 pt-2">Nest Drift</div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Base Drift Rate</span>
                        <span id="val-nestBaseDriftRate" class="text-purple-300 font-mono">1.2</span>
                    </div>
                    <input type="range" min="0" max="3" step="0.1" oninput="sim.updateConfig('nestBaseDriftRate', this.value)" id="in-nestBaseDriftRate">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Diplomatic Drift x</span>
                        <span id="val-nestDiplomaticDriftMultiplier" class="text-yellow-300 font-mono">2.0</span>
                    </div>
                    <input type="range" min="1" max="5" step="0.5" oninput="sim.updateConfig('nestDiplomaticDriftMultiplier', this.value)" id="in-nestDiplomaticDriftMultiplier">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Commercial Drift x</span>
                        <span id="val-nestCommercialDriftMultiplier" class="text-cyan-300 font-mono">2.5</span>
                    </div>
                    <input type="range" min="1" max="5" step="0.5" oninput="sim.updateConfig('nestCommercialDriftMultiplier', this.value)" id="in-nestCommercialDriftMultiplier">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Friendly Nest Attraction</span>
                        <span id="val-nestFriendlyAttractionStrength" class="text-green-300 font-mono">0.02</span>
                    </div>
                    <input type="range" min="0" max="0.1" step="0.01" oninput="sim.updateConfig('nestFriendlyAttractionStrength', this.value)" id="in-nestFriendlyAttractionStrength">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Enemy Nest Repulsion</span>
                        <span id="val-nestEnemyRepulsionStrength" class="text-red-300 font-mono">0.05</span>
                    </div>
                    <input type="range" min="0" max="0.15" step="0.01" oninput="sim.updateConfig('nestEnemyRepulsionStrength', this.value)" id="in-nestEnemyRepulsionStrength">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Unaffiliated Group Drift</span>
                        <span id="val-nestUnaffiliatedDriftRate" class="text-gray-300 font-mono">0.01</span>
                    </div>
                    <input type="range" min="0" max="0.05" step="0.005" oninput="sim.updateConfig('nestUnaffiliatedDriftRate', this.value)" id="in-nestUnaffiliatedDriftRate">
                </div>
                
                <div class="text-[11px] font-bold text-gray-500 uppercase mt-3 mb-2 border-t border-gray-700 pt-2">Social Attraction</div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Kin Attraction</span>
                        <span id="val-kinAttractionStrength" class="text-pink-300 font-mono">0.3</span>
                    </div>
                    <input type="range" min="0" max="1" step="0.05" oninput="sim.updateConfig('kinAttractionStrength', this.value)" id="in-kinAttractionStrength">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Tribe Attraction</span>
                        <span id="val-tribeAttractionStrength" class="text-blue-300 font-mono">0.15</span>
                    </div>
                    <input type="range" min="0" max="1" step="0.05" oninput="sim.updateConfig('tribeAttractionStrength', this.value)" id="in-tribeAttractionStrength">
                </div>
                
                <div class="text-[11px] font-bold text-gray-500 uppercase mt-3 mb-2 border-t border-gray-700 pt-2">Reproduction Dynamics</div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Min Density</span>
                        <span id="val-reproductionDensityMin" class="text-yellow-300 font-mono">0.2</span>
                    </div>
                    <input type="range" min="0.05" max="0.5" step="0.05" oninput="sim.updateConfig('reproductionDensityMin', this.value)" id="in-reproductionDensityMin">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Optimal Density</span>
                        <span id="val-reproductionDensityOptimal" class="text-green-300 font-mono">0.5</span>
                    </div>
                    <input type="range" min="0.3" max="0.8" step="0.05" oninput="sim.updateConfig('reproductionDensityOptimal', this.value)" id="in-reproductionDensityOptimal">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Max Density</span>
                        <span id="val-reproductionDensityMax" class="text-red-300 font-mono">0.9</span>
                    </div>
                    <input type="range" min="0.7" max="1.0" step="0.05" oninput="sim.updateConfig('reproductionDensityMax', this.value)" id="in-reproductionDensityMax">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Max Birth Multiplier</span>
                        <span id="val-reproductionMaxMultiplier" class="text-cyan-300 font-mono">2.0</span>
                    </div>
                    <input type="range" min="1.0" max="5.0" step="0.1" oninput="sim.updateConfig('reproductionMaxMultiplier', this.value)" id="in-reproductionMaxMultiplier">
                </div>
                
                <div class="text-[11px] font-bold text-gray-500 uppercase mt-3 mb-2 border-t border-gray-700 pt-2">Movement Patterns</div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Roaming Strength</span>
                        <span id="val-roamingGeneStrength" class="text-purple-300 font-mono">1.0</span>
                    </div>
                    <input type="range" min="0" max="2" step="0.1" oninput="sim.updateConfig('roamingGeneStrength', this.value)" id="in-roamingGeneStrength">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Nest Return Min</span>
                        <span id="val-nestReturnFrequencyMin" class="text-orange-300 font-mono">200</span>
                    </div>
                    <input type="range" min="50" max="500" step="50" oninput="sim.updateConfig('nestReturnFrequencyMin', this.value)" id="in-nestReturnFrequencyMin">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Nest Return Max</span>
                        <span id="val-nestReturnFrequencyMax" class="text-pink-300 font-mono">1000</span>
                    </div>
                    <input type="range" min="500" max="2000" step="100" oninput="sim.updateConfig('nestReturnFrequencyMax', this.value)" id="in-nestReturnFrequencyMax">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Leader Max Wander Radius</span>
                        <span id="val-leaderMaxWanderRadius" class="text-purple-300 font-mono">120</span>
                    </div>
                    <input type="range" min="50" max="300" step="10" oninput="sim.updateConfig('leaderMaxWanderRadius', this.value)" id="in-leaderMaxWanderRadius">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Oscillation Strength</span>
                        <span id="val-oscillatingMovementStrength" class="text-indigo-300 font-mono">0.8</span>
                    </div>
                    <input type="range" min="0" max="2" step="0.1" oninput="sim.updateConfig('oscillatingMovementStrength', this.value)" id="in-oscillatingMovementStrength">
                </div>
                
                <div class="text-[11px] font-bold text-gray-500 uppercase mt-3 mb-2 border-t border-gray-700 pt-2">Food Decay System</div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Food Decay Rate</span>
                        <span id="val-foodDecayRate" class="text-red-300 font-mono">0.0005</span>
                    </div>
                    <input type="range" min="0" max="0.005" step="0.0001" oninput="sim.updateConfig('foodDecayRate', this.value)" id="in-foodDecayRate">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Botanist Fertilize Rate</span>
                        <span id="val-botanistFertilizeRate" class="text-green-300 font-mono">0.05</span>
                    </div>
                    <input type="range" min="0" max="0.2" step="0.01" oninput="sim.updateConfig('botanistFertilizeRate', this.value)" id="in-botanistFertilizeRate">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Botanist Fertilize Radius</span>
                        <span id="val-botanistFertilizeRadius" class="text-lime-300 font-mono">30</span>
                    </div>
                    <input type="range" min="10" max="100" step="5" oninput="sim.updateConfig('botanistFertilizeRadius', this.value)" id="in-botanistFertilizeRadius">
                </div>
                
                <div class="text-[11px] font-bold text-gray-500 uppercase mt-3 mb-2 border-t border-gray-700 pt-2">Farmer & Food Chain</div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Farmer Spawn Grazer Rate</span>
                        <span id="val-farmerSpawnGrazerRate" class="text-lime-300 font-mono">0.01</span>
                    </div>
                    <input type="range" min="0" max="0.05" step="0.001" oninput="sim.updateConfig('farmerSpawnGrazerRate', this.value)" id="in-farmerSpawnGrazerRate">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Farmer Health Threshold</span>
                        <span id="val-farmerSpawnGrazerHealthThreshold" class="text-green-300 font-mono">0.7</span>
                    </div>
                    <input type="range" min="0.3" max="1.0" step="0.05" oninput="sim.updateConfig('farmerSpawnGrazerHealthThreshold', this.value)" id="in-farmerSpawnGrazerHealthThreshold">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Prey Asexual Repro Rate</span>
                        <span id="val-preyAsexualReproductionRate" class="text-yellow-300 font-mono">0.005</span>
                    </div>
                    <input type="range" min="0" max="0.02" step="0.001" oninput="sim.updateConfig('preyAsexualReproductionRate', this.value)" id="in-preyAsexualReproductionRate">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Prey Repro Radius</span>
                        <span id="val-preyAsexualReproductionRadius" class="text-orange-300 font-mono">80</span>
                    </div>
                    <input type="range" min="30" max="150" step="10" oninput="sim.updateConfig('preyAsexualReproductionRadius', this.value)" id="in-preyAsexualReproductionRadius">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Predator Spawn Rate</span>
                        <span id="val-predatorSpawnRate" class="text-red-300 font-mono">0.005</span>
                    </div>
                    <input type="range" min="0" max="0.02" step="0.001" oninput="sim.updateConfig('predatorSpawnRate', this.value)" id="in-predatorSpawnRate">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Prey Spawn Rate (groups)</span>
                        <span id="val-preySpawnRate" class="text-yellow-300 font-mono">0.01</span>
                    </div>
                    <input type="range" min="0" max="0.03" step="0.001" oninput="sim.updateConfig('preySpawnRate', this.value)" id="in-preySpawnRate">
                </div>
                
                <div class="text-[11px] font-bold text-gray-500 uppercase mt-3 mb-2 border-t border-gray-700 pt-2">Diplomacy & Trade</div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Diplomat Spawn Distance</span>
                        <span id="val-diplomatSpawnDistance" class="text-yellow-300 font-mono">220</span>
                    </div>
                    <input type="range" min="100" max="500" step="20" oninput="sim.updateConfig('diplomatSpawnDistance', this.value)" id="in-diplomatSpawnDistance">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Merchant Spawn Distance</span>
                        <span id="val-merchantSpawnDistance" class="text-cyan-300 font-mono">180</span>
                    </div>
                    <input type="range" min="100" max="400" step="20" oninput="sim.updateConfig('merchantSpawnDistance', this.value)" id="in-merchantSpawnDistance">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Merchant Trade Frequency</span>
                        <span id="val-merchantTradeFrequency" class="text-green-300 font-mono">0.02</span>
                    </div>
                    <input type="range" min="0.005" max="0.1" step="0.005" oninput="sim.updateConfig('merchantTradeFrequency', this.value)" id="in-merchantTradeFrequency">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Min Alliance for Trade</span>
                        <span id="val-minAllianceForTrade" class="text-pink-300 font-mono">20</span>
                    </div>
                    <input type="range" min="0" max="50" step="5" oninput="sim.updateConfig('minAllianceForTrade', this.value)" id="in-minAllianceForTrade">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Diplomat Negotiation Rate</span>
                        <span id="val-diplomatNegotiationFrequency" class="text-yellow-300 font-mono">0.15</span>
                    </div>
                    <input type="range" min="0.01" max="0.3" step="0.01" oninput="sim.updateConfig('diplomatNegotiationFrequency', this.value)" id="in-diplomatNegotiationFrequency">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Merchant Trade Rate</span>
                        <span id="val-merchantTradeFrequency" class="text-cyan-300 font-mono">0.08</span>
                    </div>
                    <input type="range" min="0.01" max="0.2" step="0.01" oninput="sim.updateConfig('merchantTradeFrequency', this.value)" id="in-merchantTradeFrequency">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Diplomatic Bond Growth</span>
                        <span id="val-diplomaticBondGrowth" class="text-yellow-300 font-mono">2.0</span>
                    </div>
                    <input type="range" min="0.1" max="5.0" step="0.1" oninput="sim.updateConfig('diplomaticBondGrowth', this.value)" id="in-diplomaticBondGrowth">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Commercial Bond Growth</span>
                        <span id="val-commercialBondGrowth" class="text-cyan-300 font-mono">3.0</span>
                    </div>
                    <input type="range" min="0.1" max="6.0" step="0.1" oninput="sim.updateConfig('commercialBondGrowth', this.value)" id="in-commercialBondGrowth">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Bond Decay Rate</span>
                        <span id="val-bondDecayRate" class="text-red-300 font-mono">0.002</span>
                    </div>
                    <input type="range" min="0.001" max="0.02" step="0.001" oninput="sim.updateConfig('bondDecayRate', this.value)" id="in-bondDecayRate">
                </div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>Bond Reinforcement Threshold</span>
                        <span id="val-bondReinforcementThreshold" class="text-green-300 font-mono">30</span>
                    </div>
                    <input type="range" min="10" max="60" step="5" oninput="sim.updateConfig('bondReinforcementThreshold', this.value)" id="in-bondReinforcementThreshold">
                </div>
                
                <div class="text-[11px] font-bold text-gray-500 uppercase mt-3 mb-2 border-t border-gray-700 pt-2">Audio</div>
                <div>
                    <div class="flex justify-between text-xs text-gray-400 mb-1">
                        <span>SFX Volume</span>
                        <span id="val-sfxVolume" class="text-green-300 font-mono">0.3</span>
                    </div>
                    <input type="range" min="0" max="1" step="0.1" oninput="sim.updateConfig('sfxVolume', this.value)" id="in-sfxVolume">
                </div>
            </div>

            <div class="mt-4 pt-2 border-t border-gray-700 flex justify-between items-center gap-2">
                <span class="text-[10px] text-gray-500 italic">Changes apply immediately</span>
                <div class="flex gap-2">
                    <button onclick="sim.copySettingsToClipboard()" class="text-xs text-blue-400 hover:text-blue-300 px-2 py-1 rounded border border-gray-700 hover:border-blue-500 transition">üìã Copy Settings</button>
                    <button onclick="sim.restoreDefaults()" class="text-xs text-red-400 hover:text-red-300 px-2 py-1 rounded border border-gray-700 hover:border-red-500 transition">Reset Defaults</button>
                </div>
            </div>
        </div>

        <!-- Bottom Layer -->
        <div class="flex justify-between items-end mt-auto w-full">
            
            <!-- Agent Inspector -->
            <div id="inspector" class="panel rounded-lg p-4 w-80 hidden shadow-xl border-l-4 border-l-blue-500">
                <div class="flex justify-between items-start border-b border-gray-700 pb-2 mb-2">
                    <div>
                        <h2 class="text-sm font-bold text-white">Agent DNA & Mind</h2>
                        <div class="text-xs text-gray-400 font-mono" id="ins-id">ID</div>
                        <div class="flex gap-2 mt-1">
                            <div class="text-xs font-bold px-1 rounded text-black" id="ins-role-tag">ROLE</div>
                            <div class="text-xs font-bold px-1 rounded border border-gray-500" id="ins-tribe-tag">TRIBE</div>
                        </div>
                        <div class="text-[10px] mt-1 text-yellow-300" id="ins-wealth">Wealth: 0</div>
                        <div class="text-[10px] font-bold text-orange-400" id="ins-hero" style="display:none;">‚òÖ HERO ‚òÖ</div>
                    </div>
                    <div class="text-right">
                        <div class="text-xs text-gray-400">State</div>
                        <div id="ins-state" class="text-xs font-bold text-yellow-400 uppercase tracking-wider">IDLE</div>
                        <div id="ins-health-status" class="text-[10px] font-bold mt-1"></div>
                        <div id="ins-bond-status" class="text-[10px] font-bold text-pink-400 mt-1"></div>
                    </div>
                </div>
                <div class="grid grid-cols-2 gap-x-4 gap-y-1 mb-3">
                    <div class="stat-row"><span>Energy</span> <div class="bar-container"><div id="ins-energy" class="bar-fill bg-green-500"></div></div></div>
                    <div class="stat-row"><span>Health</span> <div class="bar-container"><div id="ins-health" class="bar-fill bg-red-500"></div></div></div>
                    <div class="stat-row"><span>Lifespan</span> <div class="bar-container"><div id="ins-life" class="bar-fill bg-yellow-200"></div></div></div>
                    <div class="stat-row"><span>Lovers</span> <span id="ins-lovers" class="text-pink-400 font-mono text-xs">0</span></div>
                    <div class="stat-row"><span>Carrying</span> <span id="ins-inv" class="text-yellow-400 font-mono text-xs">Empty</span></div>
                    <div class="stat-row"><span>Charisma</span> <span id="ins-charisma" class="text-cyan-400 font-mono text-xs">0</span></div>
                    <div class="stat-row"><span>Age</span> <span id="ins-age" class="text-gray-400 font-mono text-xs">0</span></div>
                </div>
                <div class="text-[10px] font-bold text-gray-500 uppercase mt-2 mb-1">DNA Traits</div>
                <div class="grid grid-cols-2 gap-x-4 gap-y-1">
                    <div class="stat-row"><span>Twitch</span> <div class="bar-container"><div id="ins-dna-twitch" class="bar-fill bg-orange-400"></div></div></div>
                    <div class="stat-row"><span>Altruism</span> <div class="bar-container"><div id="ins-dna-altruism" class="bar-fill bg-rose-300"></div></div></div>
                    <div class="stat-row"><span>Curiosity</span> <div class="bar-container"><div id="ins-dna-curiosity" class="bar-fill bg-blue-400"></div></div></div>
                    <div class="stat-row"><span>Social</span> <div class="bar-container"><div id="ins-dna-social" class="bar-fill bg-pink-500"></div></div></div>
                    <div class="stat-row"><span>Aggro</span> <div class="bar-container"><div id="ins-dna-aggro" class="bar-fill bg-red-600"></div></div></div>
                    <div class="stat-row"><span>Botany</span> <div class="bar-container"><div id="ins-dna-botany" class="bar-fill bg-emerald-400"></div></div></div>
                    <div class="stat-row"><span>Build</span> <div class="bar-container"><div id="ins-dna-build" class="bar-fill bg-yellow-600"></div></div></div>
                    <div class="stat-row"><span>Maker</span> <div class="bar-container"><div id="ins-dna-manu" class="bar-fill bg-cyan-500"></div></div></div>
                </div>
            </div>

            <!-- Collapsible Tribe Panel -->
            <div class="relative ml-4 flex-shrink-0" style="pointer-events:auto;">
                <button id="tribe-toggle-btn" onclick="toggleTribePanel(true)" class="ui-control bg-white/15 text-white text-[10px] uppercase tracking-widest px-3 py-1 rounded-full border border-white/30 shadow-lg backdrop-blur-sm">Tribes & Nests</button>
                <div id="tribe-panel" class="panel rounded-lg p-3 mt-2 w-60 hidden shadow-xl border border-gray-700 bg-gray-900/80">
                    <div class="flex justify-between items-center border-b border-gray-700 pb-2 mb-2">
                        <div class="font-bold text-gray-300 uppercase text-[10px]">Tribes & Nests</div>
                        <button onclick="toggleTribePanel(false)" class="text-[10px] text-gray-400 hover:text-white">Close</button>
                    </div>
                <div id="tribe-list" class="space-y-2 text-[10px] overflow-y-auto custom-scroll" style="max-height: 320px;"></div>
                </div>
            </div>

            <!-- Collapsible Legend -->
            <div class="relative ml-auto flex-shrink-0" style="pointer-events:auto;">
                <button id="legend-toggle-btn" onclick="toggleLegendPanel(true)" class="ui-control bg-white/15 text-white text-[10px] uppercase tracking-widest px-3 py-1 rounded-full border border-white/30 shadow-lg backdrop-blur-sm">Legend</button>
                <div id="legend-panel" class="panel rounded-lg p-3 mt-2 w-56 h-96 overflow-y-auto custom-scroll text-xs text-gray-300 hidden shadow-xl border border-gray-700 bg-gray-900/80">
                    <div class="flex justify-between items-center border-b border-gray-700 pb-2 mb-2">
                        <div class="font-bold text-gray-500 uppercase text-[10px]">Legend</div>
                        <button onclick="toggleLegendPanel(false)" class="text-[10px] text-gray-400 hover:text-white">Close</button>
                    </div>
                <div class="grid grid-cols-1 gap-y-1">
                    <div><span class="dot border-4 border-double border-white"></span>Nest</div>
                    <div><span class="dot border border-white"></span>Tribe Halo</div>
                    <div class="border-t border-gray-700 my-1"></div>
                    <!-- Bonds Between Agents -->
                    <div class="text-[10px] text-gray-400 uppercase mb-1">Agent Bonds</div>
                    <div><hr class="w-4 inline-block mr-2 border-t-2 border-white align-middle">Elastic Bond (White)</div>
                    <div><hr class="w-4 inline-block mr-2 border-t-2 border-red-400 align-middle" style="border-width:3px;">Rigid Bond (Red-Orange)</div>
                    <div class="border-t border-gray-700 my-1"></div>
                    <!-- Bonds Between Nests/Tribes -->
                    <div class="text-[10px] text-gray-400 uppercase mb-1">Tribal Bonds</div>
                    <div><hr class="w-4 inline-block mr-2 border-t-2 border-yellow-400 align-middle" style="border-width:3px;">Diplomatic Bond (Yellow/Gold)</div>
                    <div><hr class="w-4 inline-block mr-2 border-t-2 border-cyan-400 align-middle" style="border-style:dashed; border-width:2px;">Commercial Bond (Cyan/Blue, Dashed)</div>
                    <div><hr class="w-4 inline-block mr-2 border-t-2 border-red-600 align-middle" style="border-style:dashed; border-width:4px;">War Bond (Red, Dashed, Animated)</div>
                    <div class="border-t border-gray-700 my-1"></div>
                    <!-- Special Items -->
                    <div><span class="w-2 h-2 bg-green-600 inline-block rounded-full mr-1 opacity-50"></span>Plague (Cataclysm)</div>
                    <div><span class="dot border-4 border-yellow-600 bg-transparent"></span>Defense Ring</div>
                    <div class="border-t border-gray-700 my-1"></div>
                    <!-- Roles -->
                    <div class="text-[10px] text-gray-400 uppercase mb-1">Agent Roles</div>
                    <div><span class="dot bg-white border border-black"></span>Scientist (Tier 3)</div>
                    <div><span class="dot bg-rose-500 border border-white"></span>Merchant (Tier 2)</div>
                    <div><span class="dot bg-purple-800 border border-red-500"></span>Monster</div>
                    <div><span class="dot bg-red-500"></span>Soldier (Tier 1)</div>
                    <div><span class="dot bg-indigo-500"></span>Raider (Tier 2)</div>
                    <div><span class="dot bg-emerald-400"></span>Botanist</div>
                    <div><span class="dot bg-cyan-200 border border-purple-400"></span>Artisan (Tier 1)</div>
                    <div><span class="dot bg-orange-600"></span>Miner</div>
                    <div><span class="dot bg-slate-500"></span>Guardian</div>
                    <div><span class="dot bg-yellow-500"></span>Builder</div>
                    <div><span class="dot" style="background-color: #78716c;"></span>Garbage Collector</div>
                    <div><span class="dot" style="background-color: #a3e635;"></span>Farmer</div>
                    <div><span class="dot bg-pink-200 border border-red-200"></span>Healer (Tier 2)</div>
                    <div><span class="dot bg-amber-200 border border-cyan-400"></span>Diplomat (Tier 3)</div>
                    <div><span class="dot bg-indigo-200 border border-purple-400"></span>Teacher (Tier 3)</div>
                    <div><span class="dot bg-yellow-400 border border-white"></span>Hero</div>
                    <div><span class="dot" style="background-color: #cbd5e1;"></span>Gatherer</div>
                    <div><span class="dot" style="background-color: #94a3b8;"></span>Scout</div>
                    <div class="border-t border-gray-700 my-1"></div>
                    <!-- Food Chain -->
                    <div class="text-[10px] text-gray-400 uppercase mb-1">Food Chain</div>
                    <div><span class="dot" style="background-color: #84cc16;"></span>Grazer (Prey)</div>
                    <div><span class="dot" style="background-color: #dc2626;"></span>Predator</div>
                    <div><span class="dot" style="background-color: #facc15;"></span>Prey</div>
                    <div class="border-t border-gray-700 my-1"></div>
                    <!-- Resources -->
                    <div class="text-[10px] text-gray-400 uppercase mb-1">Resources</div>
                    <div><span class="dot bg-green-500"></span>Food (Least Valuable)</div>
                    <div><span class="dot" style="background-color: #a3e635;"></span>Seed</div>
                    <div><span class="dot bg-yellow-500"></span>Material (MAT)</div>
                    <div><span class="dot" style="background-color: #f472b6;"></span>Stim</div>
                    <div><span class="dot bg-fuchsia-400"></span>Herb (Cure)</div>
                    <div><span class="dot bg-slate-300"></span>Ore (Wealth)</div>
                    <div><span class="dot bg-cyan-400 border border-white"></span>Relic (XP)</div>
                    <div><span class="dot" style="background-color: #a78bfa;"></span>Unique</div>
                    <div><span class="dot" style="background-color: #fbbf24; border: 2px solid #f59e0b;"></span>Treasure (Most Valuable)</div>
                </div>
                <div class="mt-2 text-[10px] text-gray-500 italic text-right">Click canvas to spawn</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        /* --- MATH UTILS --- */
        class Vector {
            constructor(x, y) { this.x = x; this.y = y; }
            add(v) { this.x += v.x; this.y += v.y; return this; }
            sub(v) { this.x -= v.x; this.y -= v.y; return this; }
            mult(n) { this.x *= n; this.y *= n; return this; }
            div(n) { this.x /= n; this.y /= n; return this; }
            mag() { return Math.sqrt(this.x * this.x + this.y * this.y); }
            normalize() { let m = this.mag(); if (m !== 0) this.div(m); return this; }
            limit(max) { if (this.mag() > max) { this.normalize(); this.mult(max); } return this; }
            heading() { return Math.atan2(this.y, this.x); }
            rotate(angle) {
                let cos = Math.cos(angle);
                let sin = Math.sin(angle);
                let x = this.x * cos - this.y * sin;
                let y = this.x * sin + this.y * cos;
                this.x = x;
                this.y = y;
                return this;
            }
            // Wrap position on torus (world wraps around)
            wrap(width, height) {
                while (this.x < 0) this.x += width;
                while (this.x >= width) this.x -= width;
                while (this.y < 0) this.y += height;
                while (this.y >= height) this.y -= height;
                return this;
            }
            // Get wrapped position (returns new vector, doesn't modify this)
            wrapped(width, height) {
                let w = this.copy();
                return w.wrap(width, height);
            }
            static dist(v1, v2) { return Math.sqrt((v1.x - v2.x)**2 + (v1.y - v2.y)**2); }
            // Toroidal distance (accounts for world wrapping)
            static distTorus(v1, v2, width, height) {
                if (!width || !height) return Vector.dist(v1, v2); // Fallback to normal distance
                let dx = Math.abs(v2.x - v1.x);
                let dy = Math.abs(v2.y - v1.y);
                // Account for wrapping
                if (dx > width / 2) dx = width - dx;
                if (dy > height / 2) dy = height - dy;
                return Math.sqrt(dx * dx + dy * dy);
            }
            // Get shortest direction vector on torus (accounts for wrapping)
            static subTorus(v1, v2, width, height) {
                if (!width || !height) return Vector.sub(v1, v2); // Fallback to normal subtraction
                let dx = v2.x - v1.x;
                let dy = v2.y - v1.y;
                // Wrap to shortest path
                if (dx > width / 2) dx -= width;
                else if (dx < -width / 2) dx += width;
                if (dy > height / 2) dy -= height;
                else if (dy < -height / 2) dy += height;
                return new Vector(dx, dy);
            }
            static sub(v1, v2) { return new Vector(v1.x - v2.x, v1.y - v2.y); }
            copy() { return new Vector(this.x, this.y); }
            static random2D() { 
                let angle = Math.random() * Math.PI * 2;
                return new Vector(Math.cos(angle), Math.sin(angle));
            }
        }

        /* --- CONFIGURATION --- */
        const DEFAULT_CONFIG = {
            popSize: 80,
            popCap: 170, 
            mutationRate: 0.35,
            learningRate: 0.1,
            resSpawnRate: 0.9,
            foodSpawnRate: 0.2,
            foodSpawnNearNestsRate: 0.1,
            foodNutritionalValue: 1.6,
            maxRes: 200,
            mateCost: 20,
            mateThreshold: 120, 
            baseRadius: 70,
            seedGrowthTime: 400,
            treasureSpawnRate: 0.48, // Increased by 1000% (10x, was 0.048)
            buildRate: 1,
            bondingRate: 3.4,
            bondBreakRate: 0.002,
            birthRate: 6.1,
            deathRate: 0.4,
            damageRate: 0.09,
            babyGrowthRate: 0.1,
            energyBurnRate: 0.09,
            tribalTaxRate: 0.2,
            groupAgentTaxPremium: 0.08,
            garbageRecycleChance: 0.2,
            garbageCollectorEnergyEfficiency: 0.5,
            matDecay: 2000,
            wallDecayRate: 0.005, 
            loveThreshold: 60,
            hateThreshold: -55,
            tribeCount: 4,
            researchSpeed: 0.5,
            unrestThreshold: 20,
            diseaseSpreadProb: 0.02,
            immunitySpreadProb: 0.05,
            lifespanBase: 3000,
            predationRange: 0.15,
            tribeWealthGain: 0.05,
            adultAge: 90,
            monsterLifespan: 1700,
            // Group benefit multipliers
            groupRangeBonus: 0.01,
            groupDamageBonus: 0.03,
            groupDefenseBonus: 0.05,
            groupHealingBonus: 0.01,
            groupEnergyCost: 0.03,
            groupCombatRange: 230,
            groupAgentMinMembers: 5,
            groupAgentMaxMembers: 9,
            groupAgentMinAge: 500,
            groupAgentStabilityThreshold: 420,
            groupAgentAscensionCooldown: 400,
            groupAgentEnergyCostMult: 0.3,
            groupAgentGatherBonus: 0.45,
            groupAgentLifespanMult: 1.5,
            groupAgentBaseRadius: 32,
            groupAgentAscensionChance: 0.4,
            // Elastic bond max length for group agents
            groupAgentElasticBondMaxLength: 110,
            stableGroupMinMembers: 2,
            stableGroupMaxMembers: 12,
            structureStabilityCap: 600,
            structureStabilityInsideGain: 3,
            structureStabilityOutsideGain: 1,
            structureStabilityInsideDecay: 1,
            structureStabilityOutsideDecay: 4,
            structureStabilityBandBonus: 1.25,
            // Rigid bond settings
            rigidBondLength: 35,
            rigidBondStiffness: 0.43,
            rigidBondFormationBonus: 2.1,
            rigidBondBreakResistance: 0.9,
            rigidBondChance: 0.85,
            nestBondedPenalty: 0.8,
            nestSplitPopulation: 20,
            nestSplitParentRetain: 0.75,
            nestSplitChildReceive: 0.3,
            nestMergeDistance: 50,
            nestSplitMaxRadius: 85,
            nestHpDecayRate: 0.005, // Further reduced from 0.00825 (40% reduction) - slower structural decay
            nestAgentSpawnRate: 0.02,
            // Agent spawn rates by role (probability per frame)
            agentSpawnRates: {
                'Scout': 0.02,
                'Gatherer': 0.03,
                'Builder': 0.015,
                'Soldier': 0.01,
                'Miner': 0.008,
                'Raider': 0.005,
                'Farmer': 0.025,
                'Botanist': 0.01,
                'Merchant': 0.005,
                'Diplomat': 0.003,
                'Guardian': 0.008,
                'Artisan': 0.006,
                'Teacher': 0.004,
                'Scientist': 0.003,
                'Garbage Collector': 0.002
            },
            // Nest drift rates
            nestBaseDriftRate: 1.8,
            nestDiplomaticDriftMultiplier: 2,
            nestCommercialDriftMultiplier: 1.5,
            nestFriendlyAttractionStrength: 0.03,
            nestEnemyRepulsionStrength: 0.02,
            nestUnaffiliatedDriftRate: 0.025,
            nestDriftSmoothing: 0.08,
            nestToolConfig: {
                maxPerNest: 5,
                spawnCooldown: 420,
                tetherRange: 220,
                resourceHarvestRange: 150,
                toolLifetime: 1200,
                toolTypes: {
                    propulsion: {
                        wealthCost: 240,
                        minHp: 500,
                        techTier: 1,
                        cooldown: 600
                    },
                    foodGrabber: {
                        wealthCost: 180,
                        minHp: 300,
                        techTier: 1,
                        cooldown: 220
                    },
                    resourceGrabber: {
                        wealthCost: 210,
                        minHp: 350,
                        techTier: 2,
                        cooldown: 220
                    },
                    venom: {
                        wealthCost: 260,
                        minHp: 450,
                        techTier: 2,
                        cooldown: 160
                    }
                }
            },
            // Social attraction
            kinAttractionStrength: 0.15,
            tribeAttractionStrength: 0.1,
            // Audio
            sfxVolume: 0.3,
            // Food Chain
            grazerSpawnRate: 0.02,
            predatorSpawnRate: 0.007,
            preySpawnRate: 0.021,
            grazerFertilization: 1.2,
            predatorPackBonus: 0.3,
            preyEvadeBonus: 1.15,
            grazerBondStrength: 0.5,
            predatorBondStrength: 0.85,
            preyBondStrength: 0.8,
            herderGeneStrength: 0.3,
            // Farmer & Prey/Predator mechanics
            farmerSpawnGrazerRate: 0.03,
            farmerSpawnGrazerHealthThreshold: 0.75,
            preyAsexualReproductionRate: 0.017,
            preyReproductionFoodBonusFactor: 0.002,
            preyAsexualReproductionRadius: 70,
            predatorPairSpawnRadius: 100,
            // Predator/Prey sexual reproduction (controlled)
            predatorMateRate: 0.002,
            predatorReproductionRate: 0.002,
            predatorMateCooldown: 800,
            predatorMateEnergyThreshold: 120,
            preyMateRate: 0.008,
            tribalReproductionRate: 0.0015,
            preyMateCooldown: 400,
            preyMateEnergyThreshold: 80,
            // Density-dependent reproduction
            reproductionDensityMin: 0.05,
            reproductionDensityOptimal: 0.35,
            reproductionDensityMax: 0.85,
            reproductionMinMultiplier: 0.3,
            reproductionMaxMultiplier: 2.2,
            // Roaming behavior
            roamingGeneStrength: 1.2,
            nestReturnFrequencyMin: 200,
            nestReturnFrequencyMax: 1400,
            leaderMaxWanderRadius: 120, // Maximum distance leaders can wander from nest
            oscillatingMovementStrength: 0.6,
            // Bonded movement weighting
            bondInfluenceByStrength: true,
            // Diplomat & Merchant systems
            diplomatSpawnDistance: 280,
            merchantSpawnDistance: 180,
            diplomatVisitDuration: 500,
            merchantTradeFrequency: 0.08,
            diplomatNegotiationFrequency: 0.19,
            tradeRequiresMerchant: true,
            diplomaticBondGrowth: 3.1,
            commercialBondGrowth: 4.2,
            minAllianceForTrade: 20,
            bondDecayRate: 0.007,
            bondReinforcementThreshold: 20,
            warDeclarationThreshold: -50,
            // Ranged Combat & Warfare
            rangedCombatRange: 150,
            rangedCombatCooldown: 120,
            rangedCombatDamage: 15,
            rangedCombatChance: 0.6,
            siegeWeaponRange: 400,
            siegeWeaponCooldown: 300,
            siegeWeaponDamage: 50,
            warExhaustionPerDeath: 5,
            warExhaustionDecay: 0.1,
            // Food decay system
            foodDecayRate: 0.0015,
            foodMinLife: 200,
            foodMaxLife: 600,
            foodNearNestLifeMultiplier: 0.5,
            botanistFertilizeRate: 0.09,
            botanistFertilizeRadius: 20,
            resourceDecayTimers: {
                FOOD: 1200,
                SEED: 900,
                MAT: 2000,
                ORE: 2200,
                TREASURE: 3600,
                STIM: 1400,
                HERB: 1500,
                RELIC: 3200,
                UNIQUE: 2500
            }
        };

        let CONFIG = { ...DEFAULT_CONFIG };

        function weightedResourceEnergy(type) {
            // RESOURCE VALUE SCALE: From least (food) to most (treasure)
            // Treasure is super valuable, with a clear progression
            switch(type) {
                case 'FOOD': return 25;        // Least valuable - basic sustenance
                case 'SEED': return 30;        // Slightly more valuable - can grow
                case 'MAT': return 40;         // Materials for building
                case 'STIM': return 50;        // Stimulants for energy
                case 'HERB': return 60;        // Herbs for healing/benefits
                case 'ORE': return 80;         // Ore for crafting/advanced materials
                case 'RELIC': return 120;      // Relics - very valuable artifacts
                case 'UNIQUE': return 150;     // Unique items - extremely valuable
                case 'TREASURE': return 200;   // Super valuable - highest tier
                default: return 30;            // Default to low value
            }
        }

        function giveNestWealth(tribeId, type, resource) {
            if (typeof sim === 'undefined' || !sim.tribes) return;
            let nest = sim.tribes.nests.find(n => n.tribeId === tribeId);
            if (!nest) return;
            // Wealth bonus scales with resource value - treasure gives much more wealth
            let resourceValue = weightedResourceEnergy(type) || 30;
            // Scale wealth gain: base 0.15 multiplier, but treasure gets bonus multiplier
            let multiplier = type === 'TREASURE' ? 0.25 : (type === 'RELIC' || type === 'UNIQUE' ? 0.20 : 0.15);
            let bonus = resourceValue * multiplier;
            nest.wealth += bonus;
        }

        function markLeaderUnderAttack(targetAgent, attacker) {
            if (!targetAgent || !attacker || typeof sim === 'undefined' || !sim.tribes) return;
            if (targetAgent.tribeId === -1) return;
            let tribe = sim.tribes.tribes[targetAgent.tribeId];
            if (!tribe) return;
            if (tribe.leaderId === targetAgent.id) {
                tribe.leaderUnderAttack = true;
                tribe.leaderUnderAttackTargetId = attacker.id;
                tribe.leaderUnderAttackTimer = sim.frame;
            }
        }

        /* --- SOUND EFFECTS SYSTEM --- */
        /*
            BACKGROUND MUSIC ATTRIBUTION:
            "Life Ambient" by Serge Quadrado
            Source: Free Music Archive
            License: CC BY-NC-SA (Creative Commons Attribution-NonCommercial-ShareAlike)
            URL: https://www.novaspivack.com/wp-content/uploads/2025/11/Serge-Quadrado-Life-Ambient.mp3
            
            This work is licensed under CC BY-NC-SA 4.0
        */
        class SFXEngine {
            constructor() {
                this.audioContext = null;
                this.enabled = false; // Disabled by default
                this.initialized = false;
                // Background ambient sound - using external audio file
                // "Life Ambient" by Serge Quadrado (CC BY-NC-SA, Free Music Archive)
                this.backgroundAudio = null; // HTML5 Audio element
                this.backgroundAudioSource = null; // Web Audio API MediaElementSourceNode
                this.backgroundGain = null; // Gain node for volume control
                this.backgroundRunning = false;
                this.nestHeartbeats = new Map(); // Map of nestId -> {osc, gain, pulseGain}
            }
            
            enable() {
                if (!this.initialized) {
                    try {
                        this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                        this.initialized = true;
                        this.enabled = true;
                        console.log('Audio enabled, state:', this.audioContext.state);
                        
                        // Resume if suspended (browser autoplay policy)
                        if (this.audioContext.state === 'suspended') {
                            this.audioContext.resume().then(() => {
                                console.log('Audio context resumed');
                                this.startBackgroundSound();
                            }).catch(e => {
                                console.log('Audio resume failed:', e);
                            });
                        } else {
                            this.startBackgroundSound();
                        }
                    } catch(e) {
                        console.log('Web Audio API not supported');
                        this.enabled = false;
                    }
                } else {
                    this.enabled = true;
                    // Resume if suspended
                    if (this.audioContext && this.audioContext.state === 'suspended') {
                        this.audioContext.resume().then(() => {
                            this.startBackgroundSound();
                        }).catch(e => console.log('Audio resume failed:', e));
                    } else {
                        this.startBackgroundSound();
                    }
                }
            }
            
            startBackgroundSound() {
                if (!this.enabled || !this.initialized || this.backgroundRunning) {
                    console.log('Background sound blocked:', {enabled: this.enabled, initialized: this.initialized, running: this.backgroundRunning});
                    return;
                }
                
                const ctx = this.audioContext;
                if (!ctx) {
                    console.log('No audio context!');
                    return;
                }
                
                // CRITICAL: Ensure audio context is running
                if (ctx.state === 'suspended') {
                    console.log('Audio context suspended, resuming...');
                    ctx.resume().then(() => {
                        console.log('Audio context resumed, starting background sound');
                        this.startBackgroundSound();
                    }).catch(e => {
                        console.error('Failed to resume audio context:', e);
                    });
                    return;
                }
                
                console.log('Loading background music: "Life Ambient" by Serge Quadrado (CC BY-NC-SA, Free Music Archive)');
                
                // Create HTML5 Audio element for the background music
                // "Life Ambient" by Serge Quadrado (CC BY-NC-SA, Free Music Archive)
                const audioUrl = 'https://www.novaspivack.com/wp-content/uploads/2025/11/Serge-Quadrado-Life-Ambient.mp3';
                this.backgroundAudio = new Audio(audioUrl);
                this.backgroundAudio.loop = true; // Loop the track automatically
                this.backgroundAudio.preload = 'auto'; // Preload the audio
                this.backgroundAudio.crossOrigin = 'anonymous'; // Allow CORS for Web Audio API
                
                // Create gain node for volume control
                this.backgroundGain = ctx.createGain();
                const mainVolume = Math.max(0.3, CONFIG.sfxVolume) * 0.8; // Increased volume level
                this.backgroundGain.gain.setValueAtTime(mainVolume, ctx.currentTime);
                
                // Connect HTML5 Audio to Web Audio API for volume control
                try {
                    this.backgroundAudioSource = ctx.createMediaElementSource(this.backgroundAudio);
                    this.backgroundAudioSource.connect(this.backgroundGain);
                    this.backgroundGain.connect(ctx.destination);
                    console.log('Audio connected to Web Audio API');
                } catch(e) {
                    console.error('Error connecting audio source to Web Audio API:', e);
                    // Fallback: use HTML5 Audio directly if Web Audio API connection fails
                    this.backgroundAudio.volume = mainVolume;
                    console.log('Using HTML5 Audio fallback with volume:', mainVolume);
                }
                
                // Function to attempt playback
                const attemptPlay = () => {
                    if (!this.backgroundAudio || !this.enabled) return;
                    
                    const playPromise = this.backgroundAudio.play();
                    if (playPromise !== undefined) {
                        playPromise.then(() => {
                            console.log('Background music started playing: "Life Ambient" by Serge Quadrado');
                            this.backgroundRunning = true;
                            
                            // Verify it's actually playing
                            setTimeout(() => {
                                if (this.backgroundAudio && !this.backgroundAudio.paused) {
                                    console.log('Background music confirmed playing');
                                } else {
                                    console.warn('Background music may not be playing - paused state:', this.backgroundAudio?.paused);
                                }
                            }, 500);
                        }).catch(e => {
                            console.error('Error playing background music:', e);
                            console.log('Note: Audio autoplay may be blocked by browser. User interaction may be required.');
                            // Try again after a short delay
                            setTimeout(() => {
                                if (this.enabled && !this.backgroundRunning) {
                                    console.log('Retrying background music playback...');
                                    attemptPlay();
                                }
                            }, 1000);
                        });
                    } else {
                        // Fallback for older browsers
                        this.backgroundAudio.play();
                        this.backgroundRunning = true;
                    }
                };
                
                // Handle audio loading and playback
                this.backgroundAudio.addEventListener('loadeddata', () => {
                    console.log('Background music loaded successfully');
                    attemptPlay();
                });
                
                this.backgroundAudio.addEventListener('canplay', () => {
                    console.log('Background music can play');
                    if (!this.backgroundRunning) {
                        attemptPlay();
                    }
                });
                
                this.backgroundAudio.addEventListener('canplaythrough', () => {
                    console.log('Background music can play through');
                    if (!this.backgroundRunning) {
                        attemptPlay();
                    }
                });
                
                // Ensure track restarts when it ends (backup to loop property)
                this.backgroundAudio.addEventListener('ended', () => {
                    console.log('Background music ended, restarting...');
                    if (this.enabled && this.backgroundRunning) {
                        this.backgroundAudio.currentTime = 0;
                        this.backgroundAudio.play().catch(e => {
                            console.error('Error restarting background music:', e);
                        });
                    }
                });
                
                this.backgroundAudio.addEventListener('error', (e) => {
                    console.error('Error loading background music:', e);
                    console.error('Audio error details:', {
                        error: this.backgroundAudio.error,
                        code: this.backgroundAudio.error?.code,
                        message: this.backgroundAudio.error?.message,
                        networkState: this.backgroundAudio.networkState,
                        readyState: this.backgroundAudio.readyState
                    });
                    this.backgroundRunning = false;
                });
                
                // Start loading the audio
                this.backgroundAudio.load();
                
                // Also try playing after a short delay (in case events don't fire)
                setTimeout(() => {
                    if (!this.backgroundRunning && this.enabled && this.backgroundAudio) {
                        console.log('Attempting delayed playback...');
                        attemptPlay();
                    }
                }, 2000);
            }
            
            // Method to ensure audio plays (call after user interaction)
            ensureAudioPlaying() {
                if (!this.enabled || !this.initialized) return;
                
                const ctx = this.audioContext;
                if (!ctx) return;
                
                // Resume audio context if suspended
                if (ctx.state === 'suspended') {
                    ctx.resume().then(() => {
                        console.log('Audio context resumed via ensureAudioPlaying');
                        if (this.backgroundAudio && this.backgroundAudio.paused) {
                            this.backgroundAudio.play().then(() => {
                                console.log('Background audio started via ensureAudioPlaying');
                                this.backgroundRunning = true;
                            }).catch(e => {
                                console.error('Error playing audio in ensureAudioPlaying:', e);
                            });
                        }
                    }).catch(e => {
                        console.error('Error resuming audio context:', e);
                    });
                } else if (this.backgroundAudio && this.backgroundAudio.paused) {
                    // Audio context is running, try to play directly
                    this.backgroundAudio.play().then(() => {
                        console.log('Background audio started via ensureAudioPlaying');
                        this.backgroundRunning = true;
                    }).catch(e => {
                        console.error('Error playing audio:', e);
                    });
                }
            }
            
            startNestHeartbeat(nestId, baseFreq, baseInterval) {
                return; // DISABLED - not working
                if (!this.enabled || !this.initialized || this.nestHeartbeats.has(nestId)) return;
                
                const ctx = this.audioContext;
                if (!ctx) return;
                
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                const pulseGain = ctx.createGain();
                
                // Each nest has its own very low-frequency heartbeat - extremely slow wave
                osc.type = 'sine';
                osc.frequency.setValueAtTime(baseFreq, ctx.currentTime);
                
                pulseGain.gain.setValueAtTime(0.03, ctx.currentTime); // Very quiet base
                
                osc.connect(pulseGain);
                pulseGain.connect(gain);
                gain.connect(ctx.destination);
                
                gain.gain.setValueAtTime(CONFIG.sfxVolume * 0.08, ctx.currentTime); // Quiet per-nest but audible
                
                const scheduleNestHeartbeat = (startTime, interval) => {
                    // EXTREMELY long, slow wave - 20+ second wave evolution
                    const waveTime = 20.0; // 20 second wave duration
                    const peakGain = 0.12; // Quiet peak
                    const baseGain = 0.03; // Very quiet base
                    
                    // Extremely slow, gentle wave up (10 seconds to peak)
                    pulseGain.gain.setValueAtTime(baseGain, startTime);
                    pulseGain.gain.linearRampToValueAtTime(peakGain, startTime + waveTime / 2); // 10 second ramp up
                    // Extremely slow, gentle wave down (10 seconds back to base)
                    pulseGain.gain.linearRampToValueAtTime(baseGain, startTime + waveTime); // 10 second ramp down
                    
                    // Check if nest is at war and adjust interval - calculate BEFORE setTimeout
                    let currentInterval = interval;
                    if (typeof sim !== 'undefined' && sim.nests) {
                        const nest = sim.nests.find(n => n.id === nestId);
                        if (nest && sim.tribes && sim.tribes.tribes[nest.tribeId]) {
                            const tribe = sim.tribes.tribes[nest.tribeId];
                            const isAtWar = Object.values(tribe.atWarWith || {}).some(w => w);
                            if (isAtWar) {
                                currentInterval = interval * 0.5; // 2X faster during war (but still slow)
                            }
                        }
                    }
                    
                    // Store interval in const for setTimeout closure
                    const delayMs = currentInterval * 1000;
                    
                    setTimeout(() => {
                        if (this.nestHeartbeats.has(nestId) && this.audioContext) {
                            scheduleNestHeartbeat(this.audioContext.currentTime, currentInterval);
                        }
                    }, delayMs);
                };
                
                osc.start(ctx.currentTime);
                this.nestHeartbeats.set(nestId, { osc, gain, pulseGain, baseInterval });
                scheduleNestHeartbeat(ctx.currentTime, baseInterval);
            }
            
            stopNestHeartbeat(nestId) {
                const heartbeat = this.nestHeartbeats.get(nestId);
                if (heartbeat) {
                    heartbeat.osc.stop();
                    heartbeat.gain.disconnect();
                    heartbeat.pulseGain.disconnect();
                    this.nestHeartbeats.delete(nestId);
                }
            }
            
            stopBackgroundSound() {
                this.backgroundRunning = false;
                
                // Stop and clean up background audio
                if (this.backgroundAudio) {
                    try {
                        this.backgroundAudio.pause();
                        this.backgroundAudio.currentTime = 0;
                        this.backgroundAudio.src = ''; // Clear source to free memory
                    } catch(e) {
                        console.error('Error stopping background audio:', e);
                    }
                    this.backgroundAudio = null;
                }
                
                // Disconnect Web Audio API nodes
                if (this.backgroundAudioSource) {
                    try {
                        this.backgroundAudioSource.disconnect();
                    } catch(e) {
                        console.error('Error disconnecting audio source:', e);
                    }
                    this.backgroundAudioSource = null;
                }
                
                if (this.backgroundGain) {
                    try {
                        this.backgroundGain.disconnect();
                    } catch(e) {
                        console.error('Error disconnecting gain node:', e);
                    }
                    this.backgroundGain = null;
                }
                
                // Stop all nest heartbeats
                for (let nestId of this.nestHeartbeats.keys()) {
                    this.stopNestHeartbeat(nestId);
                }
            }
            
            disable() {
                this.enabled = false;
                this.stopBackgroundSound();
            }
            
            play(type, frequency = 440, duration = 0.1, volume = 1.0) {
                if (!this.enabled || !this.initialized || CONFIG.sfxVolume === 0) return;
                
                const ctx = this.audioContext;
                // Resume audio context if suspended (browser autoplay policy)
                if (ctx.state === 'suspended') {
                    ctx.resume().then(() => {
                        // Retry playing after resume
                        this._playSound(type, frequency, duration, volume);
                    }).catch(e => {
                        console.log('Audio resume failed:', e);
                    });
                    return; // Exit early, will retry after resume
                }
                this._playSound(type, frequency, duration, volume);
            }
            
            _playSound(type, frequency = 440, duration = 0.1, volume = 1.0) {
                if (!this.enabled || !this.initialized || CONFIG.sfxVolume === 0) return;
                const ctx = this.audioContext;
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                
                osc.connect(gain);
                gain.connect(ctx.destination);
                
                const finalVolume = Math.min(1.0, CONFIG.sfxVolume * volume);
                
                switch(type) {
                    case 'trade':
                        // Soft electronic data transfer - audible low frequency sweep
                        osc.frequency.setValueAtTime(frequency * 0.6, ctx.currentTime);
                        osc.frequency.linearRampToValueAtTime(frequency * 0.9, ctx.currentTime + duration * 0.8);
                        osc.type = 'sine'; // Softer
                        gain.gain.setValueAtTime(0, ctx.currentTime); // Soft attack
                        gain.gain.linearRampToValueAtTime(finalVolume * 0.12, ctx.currentTime + duration * 0.1);
                        gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + duration);
                        break;
                    
                    case 'bond':
                        // Soft electronic connection - audible low frequency pulse
                        osc.frequency.setValueAtTime(frequency * 0.5, ctx.currentTime);
                        osc.type = 'sine'; // Softer
                        gain.gain.setValueAtTime(0, ctx.currentTime); // Soft attack
                        gain.gain.linearRampToValueAtTime(finalVolume * 0.1, ctx.currentTime + duration * 0.2);
                        gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + duration * 1.5);
                        duration *= 1.5;
                        break;
                    
                    case 'attack':
                        // Soft electronic impact - audible low frequency, gentle
                        osc.type = 'sine'; // Softer
                        osc.frequency.setValueAtTime(frequency * 0.7, ctx.currentTime);
                        osc.frequency.linearRampToValueAtTime(frequency * 0.5, ctx.currentTime + duration);
                        gain.gain.setValueAtTime(0, ctx.currentTime); // Soft attack
                        gain.gain.linearRampToValueAtTime(finalVolume * 0.05, ctx.currentTime + duration * 0.1);
                        gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + duration);
                        duration *= 0.8;
                        break;
                    
                    case 'birth':
                        // Soft electronic emergence - audible low frequency rise
                        osc.frequency.setValueAtTime(frequency * 0.4, ctx.currentTime);
                        osc.frequency.linearRampToValueAtTime(frequency * 0.8, ctx.currentTime + duration);
                        osc.type = 'sine'; // Softer
                        gain.gain.setValueAtTime(0, ctx.currentTime); // Soft attack
                        gain.gain.linearRampToValueAtTime(finalVolume * 0.12, ctx.currentTime + duration * 0.15);
                        gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + duration);
                        break;
                    
                    case 'death':
                        // Soft electronic decay - gentle descending tone
                        osc.frequency.setValueAtTime(frequency * 0.8, ctx.currentTime);
                        osc.frequency.linearRampToValueAtTime(frequency * 0.4, ctx.currentTime + duration * 1.5);
                        osc.type = 'sine'; // Softer
                        gain.gain.setValueAtTime(0, ctx.currentTime); // Soft attack
                        gain.gain.linearRampToValueAtTime(finalVolume * 0.1, ctx.currentTime + duration * 0.1);
                        gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + duration * 1.5);
                        duration *= 1.5;
                        break;
                    
                    case 'eat':
                        // Soft electronic consumption - gentle audible blip
                        osc.frequency.setValueAtTime(frequency * 0.7, ctx.currentTime);
                        osc.type = 'sine'; // Softer
                        gain.gain.setValueAtTime(0, ctx.currentTime); // Soft attack
                        gain.gain.linearRampToValueAtTime(finalVolume * 0.06, ctx.currentTime + duration * 0.1);
                        gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + duration * 0.5);
                        duration *= 0.5;
                        break;
                    
                    case 'heal':
                        // Soft electronic restoration - gentle frequency modulation
                        osc.frequency.setValueAtTime(frequency * 0.6, ctx.currentTime);
                        osc.frequency.linearRampToValueAtTime(frequency * 0.8, ctx.currentTime + duration/3);
                        osc.frequency.linearRampToValueAtTime(frequency * 0.65, ctx.currentTime + duration*2/3);
                        osc.type = 'sine'; // Softer
                        gain.gain.setValueAtTime(0, ctx.currentTime); // Soft attack
                        gain.gain.linearRampToValueAtTime(finalVolume * 0.08, ctx.currentTime + duration * 0.1);
                        gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + duration);
                        break;
                    
                    case 'diplomacy':
                        // Soft electronic communication - gentle audible tone
                        osc.frequency.setValueAtTime(frequency * 0.6, ctx.currentTime);
                        osc.type = 'sine'; // Softer
                        gain.gain.setValueAtTime(0, ctx.currentTime); // Soft attack
                        gain.gain.linearRampToValueAtTime(finalVolume * 0.1, ctx.currentTime + duration * 0.15);
                        gain.gain.linearRampToValueAtTime(0.01, ctx.currentTime + duration * 1.2);
                        duration *= 1.2;
                        break;
                    
                    case 'jealousy':
                        // Soft electronic tension - gentle frequency shift
                        osc.frequency.setValueAtTime(frequency * 0.7, ctx.currentTime);
                        osc.frequency.linearRampToValueAtTime(frequency * 0.9, ctx.currentTime + duration/2);
                        osc.type = 'sine'; // Softer
                        gain.gain.setValueAtTime(0, ctx.currentTime); // Soft attack
                        gain.gain.linearRampToValueAtTime(finalVolume * 0.04, ctx.currentTime + duration * 0.1);
                        gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + duration);
                        duration *= 0.8;
                        break;
                    
                    case 'merge':
                        // Soft electronic fusion - gentle frequency sweep
                        osc.frequency.setValueAtTime(frequency * 0.5, ctx.currentTime);
                        osc.frequency.linearRampToValueAtTime(frequency * 0.9, ctx.currentTime + duration * 1.5);
                        osc.type = 'sine'; // Softer
                        gain.gain.setValueAtTime(0, ctx.currentTime); // Soft attack
                        gain.gain.linearRampToValueAtTime(finalVolume * 0.15, ctx.currentTime + duration * 0.2);
                        gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + duration * 1.5);
                        duration *= 1.5;
                        break;
                    
                    case 'split':
                        // Soft electronic division - gentle frequency drop
                        osc.frequency.setValueAtTime(frequency * 0.9, ctx.currentTime);
                        osc.frequency.linearRampToValueAtTime(frequency * 0.6, ctx.currentTime + duration/2);
                        osc.frequency.linearRampToValueAtTime(frequency * 0.75, ctx.currentTime + duration);
                        osc.type = 'sine'; // Softer
                        gain.gain.setValueAtTime(0, ctx.currentTime); // Soft attack
                        gain.gain.linearRampToValueAtTime(finalVolume * 0.12, ctx.currentTime + duration * 0.15);
                        gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + duration);
                        break;
                    
                    case 'transaction':
                        // Soft electronic data pulse - gentle audible blip
                        osc.frequency.setValueAtTime(frequency * 0.8, ctx.currentTime);
                        osc.type = 'sine'; // Softer
                        gain.gain.setValueAtTime(0, ctx.currentTime); // Soft attack
                        gain.gain.linearRampToValueAtTime(finalVolume * 0.08, ctx.currentTime + duration * 0.1);
                        gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + duration * 0.6);
                        duration *= 0.6;
                        break;
                    
                    case 'link_formed':
                        // Soft electronic connection - gentle audible frequency rise
                        osc.frequency.setValueAtTime(frequency * 0.6, ctx.currentTime);
                        osc.frequency.linearRampToValueAtTime(frequency * 0.9, ctx.currentTime + duration * 0.7);
                        osc.type = 'sine'; // Softer
                        gain.gain.setValueAtTime(0, ctx.currentTime); // Soft attack
                        gain.gain.linearRampToValueAtTime(finalVolume * 0.08, ctx.currentTime + duration * 0.1);
                        gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + duration * 0.7);
                        duration *= 0.7;
                        break;
                    
                    case 'link_broken':
                        // Soft electronic disconnection - gentle frequency drop
                        osc.frequency.setValueAtTime(frequency * 0.8, ctx.currentTime);
                        osc.frequency.linearRampToValueAtTime(frequency * 0.5, ctx.currentTime + duration * 0.6);
                        osc.type = 'sine'; // Softer
                        gain.gain.setValueAtTime(0, ctx.currentTime); // Soft attack
                        gain.gain.linearRampToValueAtTime(finalVolume * 0.08, ctx.currentTime + duration * 0.1);
                        gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + duration * 0.6);
                        duration *= 0.6;
                        break;
                    
                    case 'spawn':
                        // Soft electronic generation - gentle audible blip
                        osc.frequency.setValueAtTime(frequency * 0.7, ctx.currentTime);
                        osc.type = 'sine'; // Softer
                        gain.gain.setValueAtTime(0, ctx.currentTime); // Soft attack
                        gain.gain.linearRampToValueAtTime(finalVolume * 0.08, ctx.currentTime + duration * 0.1);
                        gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + duration * 0.6);
                        duration *= 0.6;
                        break;
                    
                    case 'aquatic':
                        // Soft electronic data flow - gentle frequency sweep
                        osc.frequency.setValueAtTime(frequency * 0.8, ctx.currentTime);
                        osc.frequency.linearRampToValueAtTime(frequency * 0.6, ctx.currentTime + duration * 0.7);
                        osc.type = 'sine'; // Softer
                        gain.gain.setValueAtTime(0, ctx.currentTime); // Soft attack
                        gain.gain.linearRampToValueAtTime(finalVolume * 0.06, ctx.currentTime + duration * 0.1);
                        gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + duration * 0.7);
                        duration *= 0.7;
                        break;
                    
                    case 'bloop':
                        // Soft electronic pulse - gentle audible frequency
                        osc.frequency.setValueAtTime(frequency * 0.7, ctx.currentTime);
                        osc.frequency.linearRampToValueAtTime(frequency * 0.55, ctx.currentTime + duration * 0.5);
                        osc.type = 'sine'; // Softer
                        gain.gain.setValueAtTime(0, ctx.currentTime); // Soft attack
                        gain.gain.linearRampToValueAtTime(finalVolume * 0.08, ctx.currentTime + duration * 0.1);
                        gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + duration * 0.5);
                        duration *= 0.5;
                        break;
                    
                    case 'bleep':
                        // Soft electronic notification - gentle audible blip
                        osc.frequency.setValueAtTime(frequency * 0.7, ctx.currentTime);
                        osc.type = 'sine'; // Softer
                        gain.gain.setValueAtTime(0, ctx.currentTime); // Soft attack
                        gain.gain.linearRampToValueAtTime(finalVolume * 0.06, ctx.currentTime + duration * 0.1);
                        gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + duration * 0.5);
                        duration *= 0.5;
                        break;
                    
                    case 'water_drop':
                        // Soft electronic data drop - gentle frequency fall
                        osc.frequency.setValueAtTime(frequency * 0.8, ctx.currentTime);
                        osc.frequency.linearRampToValueAtTime(frequency * 0.55, ctx.currentTime + duration * 0.4);
                        osc.type = 'sine'; // Softer
                        gain.gain.setValueAtTime(0, ctx.currentTime); // Soft attack
                        gain.gain.linearRampToValueAtTime(finalVolume * 0.05, ctx.currentTime + duration * 0.1);
                        gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + duration * 0.4);
                        duration *= 0.4;
                        break;
                    
                    case 'bubble':
                        // Soft electronic pulse - very soft for love/mating
                        osc.frequency.setValueAtTime(frequency * 0.6, ctx.currentTime);
                        osc.frequency.linearRampToValueAtTime(frequency * 0.75, ctx.currentTime + duration * 0.5);
                        osc.type = 'sine'; // Softer
                        gain.gain.setValueAtTime(0, ctx.currentTime); // Soft attack
                        gain.gain.linearRampToValueAtTime(finalVolume * 0.03, ctx.currentTime + duration * 0.15);
                        gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + duration * 0.5);
                        duration *= 0.5;
                        break;
                    
                    case 'artisan_tone':
                        // Soft electronic crafting - gentle audible frequency pulse
                        osc.frequency.setValueAtTime(frequency * 0.65, ctx.currentTime);
                        osc.frequency.linearRampToValueAtTime(frequency * 0.8, ctx.currentTime + duration * 0.3);
                        osc.type = 'sine'; // Softer
                        gain.gain.setValueAtTime(0, ctx.currentTime); // Soft attack
                        gain.gain.linearRampToValueAtTime(finalVolume * 0.1, ctx.currentTime + duration * 0.15);
                        gain.gain.linearRampToValueAtTime(finalVolume * 0.12, ctx.currentTime + duration * 0.3);
                        gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + duration);
                        break;
                    
                    case 'collect':
                        // Soft electronic data collection - gentle frequency sweep
                        osc.frequency.setValueAtTime(frequency * 0.7, ctx.currentTime);
                        osc.frequency.linearRampToValueAtTime(frequency * 0.9, ctx.currentTime + duration * 0.3);
                        osc.type = 'sine'; // Softer
                        gain.gain.setValueAtTime(0, ctx.currentTime); // Soft attack
                        gain.gain.linearRampToValueAtTime(finalVolume * 0.08, ctx.currentTime + duration * 0.1);
                        gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + duration * 0.6);
                        duration *= 0.6;
                        break;
                    
                    case 'ranged_attack':
                        // NO SOUND - projectiles are silent
                        return; // Don't play any sound
                        break;
                    
                    case 'static':
                        // Low static buzz for battle/combat - low frequency electrical crackling with delay and reverb
                        osc.type = 'sine'; // Softer than square
                        const staticDuration = duration * 0.5; // Longer for buzz
                        const numChanges = 10; // More changes for buzz effect
                        const baseFreq = frequency * 0.6; // Audible low base frequency for buzz
                        
                        // Low frequency modulation for static buzz
                        for (let i = 0; i < numChanges; i++) {
                            const t = (i / numChanges) * staticDuration;
                            // Low frequency range for buzz
                            const randomFreq = baseFreq * (0.8 + Math.random() * 0.4); // Audible low frequency variation
                            osc.frequency.setValueAtTime(randomFreq, ctx.currentTime + t);
                        }
                        
                        // Create delay and reverb chain for static
                        const staticDelay = ctx.createDelay(2.0);
                        staticDelay.delayTime.setValueAtTime(0.6, ctx.currentTime); // 600ms delay
                        const staticDelayGain = ctx.createGain();
                        staticDelayGain.gain.setValueAtTime(0.35, ctx.currentTime); // Feedback
                        const staticReverbGain = ctx.createGain();
                        staticReverbGain.gain.setValueAtTime(0.5, ctx.currentTime); // Reverb mix
                        
                        // Connect: osc -> gain -> delay -> feedback -> reverb -> destination
                        osc.connect(gain);
                        gain.connect(staticDelay);
                        staticDelay.connect(staticDelayGain);
                        staticDelayGain.connect(staticDelay); // Feedback
                        staticDelayGain.connect(staticReverbGain);
                        gain.connect(staticReverbGain); // Direct + reverb
                        staticReverbGain.connect(ctx.destination);
                        
                        // Soft volume modulation for buzz - louder so audible
                        gain.gain.setValueAtTime(0, ctx.currentTime); // Soft attack
                        gain.gain.linearRampToValueAtTime(finalVolume * 0.15, ctx.currentTime + staticDuration * 0.1);
                        // Gentle volume variation for buzz
                        for (let i = 1; i < 4; i++) {
                            const t = (i / 4) * staticDuration;
                            const volVariation = 0.12 + Math.random() * 0.05; // More audible variation
                            gain.gain.setValueAtTime(finalVolume * volVariation, ctx.currentTime + t);
                        }
                        gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + staticDuration);
                        duration = staticDuration;
                        break;
                    
                    case 'love':
                        // Higher but soft tone for love - with lots of delay and reverb
                        osc.frequency.setValueAtTime(frequency * 1.2, ctx.currentTime); // Higher tone
                        osc.type = 'sine'; // Soft
                        
                        // Create reverb chain: delay with feedback - more reverb
                        const loveDelay = ctx.createDelay(3.0);
                        loveDelay.delayTime.setValueAtTime(1.0, ctx.currentTime); // 1.0s delay - longer
                        const loveDelayGain = ctx.createGain();
                        loveDelayGain.gain.setValueAtTime(0.5, ctx.currentTime); // More feedback
                        const loveReverbGain = ctx.createGain();
                        loveReverbGain.gain.setValueAtTime(0.8, ctx.currentTime); // More reverb mix
                        
                        // Connect: osc -> gain -> delay -> feedback -> reverb -> destination
                        osc.connect(gain);
                        gain.connect(loveDelay);
                        loveDelay.connect(loveDelayGain);
                        loveDelayGain.connect(loveDelay); // Feedback
                        loveDelayGain.connect(loveReverbGain);
                        gain.connect(loveReverbGain); // Direct + reverb
                        loveReverbGain.connect(ctx.destination);
                        
                        // Louder so audible, with soft attack
                        gain.gain.setValueAtTime(0, ctx.currentTime);
                        gain.gain.linearRampToValueAtTime(finalVolume * 0.12, ctx.currentTime + duration * 0.2);
                        gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + duration * 1.2);
                        duration *= 1.2;
                        break;
                    
                    case 'mating':
                        // Slow quiet bell tone for mating - with lots of delay and reverb
                        osc.frequency.setValueAtTime(frequency * 0.9, ctx.currentTime); // Bell-like frequency
                        osc.type = 'sine'; // Soft bell
                        
                        // Create reverb chain: delay with feedback - even more reverb
                        const matingDelay = ctx.createDelay(4.0);
                        matingDelay.delayTime.setValueAtTime(1.5, ctx.currentTime); // 1.5s delay - longer reverb
                        const matingDelayGain = ctx.createGain();
                        matingDelayGain.gain.setValueAtTime(0.6, ctx.currentTime); // More feedback
                        const matingReverbGain = ctx.createGain();
                        matingReverbGain.gain.setValueAtTime(0.9, ctx.currentTime); // Very strong reverb mix
                        
                        // Connect: osc -> gain -> delay -> feedback -> reverb -> destination
                        osc.connect(gain);
                        gain.connect(matingDelay);
                        matingDelay.connect(matingDelayGain);
                        matingDelayGain.connect(matingDelay); // Feedback
                        matingDelayGain.connect(matingReverbGain);
                        gain.connect(matingReverbGain); // Direct + reverb
                        matingReverbGain.connect(ctx.destination);
                        
                        // Louder so audible, slow bell with soft attack
                        gain.gain.setValueAtTime(0, ctx.currentTime);
                        gain.gain.linearRampToValueAtTime(finalVolume * 0.1, ctx.currentTime + duration * 0.3);
                        gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + duration * 2.0);
                        duration *= 2.0; // Slow bell
                        break;
                    
                    default:
                        // Generic soft electronic beep
                        osc.frequency.setValueAtTime(frequency * 0.7, ctx.currentTime);
                        osc.type = 'sine'; // Softer
                        gain.gain.setValueAtTime(0, ctx.currentTime); // Soft attack
                        gain.gain.linearRampToValueAtTime(finalVolume * 0.12, ctx.currentTime + duration * 0.1);
                        gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + duration);
                }
                
                osc.start(ctx.currentTime);
                osc.stop(ctx.currentTime + duration);
            }
        }
        
        const sfx = new SFXEngine();
        
        // Harmonic frequency constants (A=440Hz standard tuning)
        // Major scale harmonics - all in A major key for tonal coherence
        const HARMONICS = {
            A3: 220,      // Low A (root)
            C4: 261.63,   // C (major third below E4)
            E4: 330,      // E (perfect fifth above A3)
            A4: 440,      // Standard A (root)
            C5: 523.25,   // C (major third above A4)
            C5_SHARP: 554.37,  // C# (major third in A major)
            D5: 587.33,   // D (fourth in A major)
            E5: 659.25,   // E (perfect fifth above A4)
            G5: 783.99,   // G (major seventh in A major)
            A5: 880,      // High A (octave above A4)
            C6: 1046.50   // C (octave above C5)
        };
        
        // Battle sounds: A major chord tones (A, C#, E) - strong, stable
        const BATTLE_TONES = [
            HARMONICS.A3,      // 220 Hz - Low A
            HARMONICS.E4,      // 330 Hz - E (perfect fifth)
            HARMONICS.A4,      // 440 Hz - A (root)
            HARMONICS.C5_SHARP, // 554.37 Hz - C# (major third)
            HARMONICS.E5       // 659.25 Hz - E (perfect fifth)
        ];
        
        // Love/Mating sounds: C major chord tones (C, E, G) - separated by major third from A
        // C is a major third above A, creating harmonic separation
        const LOVE_TONES = [
            HARMONICS.C4,      // 261.63 Hz - C (major third above A3)
            HARMONICS.C5,      // 523.25 Hz - C (major third above A4)
            HARMONICS.E5,      // 659.25 Hz - E (shared with battle but higher)
            HARMONICS.G5,      // 783.99 Hz - G (major third above E5)
            HARMONICS.C6       // 1046.50 Hz - C (octave)
        ];
        
        // Helper function to get random harmonic frequency from a set
        function getHarmonicFreq(tones, variance = 0) {
            let freq = tones[Math.floor(Math.random() * tones.length)];
            if (variance > 0) {
                freq += (Math.random() - 0.5) * variance;
            }
            return freq;
        }
        
        // Global sound throttling for high-intensity sounds (love, mating, battle) to prevent buzzing
        // Only ONE sound of each type can play per frame globally
        const soundThrottle = {
            lastLoveSoundFrame: -9999, // Initialize to allow first sound
            lastBattleSoundFrame: -9999, // Initialize to allow first sound
            loveSoundCooldown: 150, // Increased: Minimum frames between love sounds
            battleSoundCooldown: 150, // Increased: Minimum frames between battle sounds
            loveSoundPlayedThisFrame: false, // Only one love sound per frame
            battleSoundPlayedThisFrame: false // Only one battle sound per frame
        };

        const RES_TYPES = {
            FOOD: { color: '#4ade80', val: 40, type: 'food', radius: 4 },
            MAT: { color: '#facc15', val: 1, type: 'mat', radius: 6 }, 
            STIM: { color: '#a855f7', val: 300, type: 'stim', radius: 4 },
            SEED: { color: '#f472b6', val: 0, type: 'seed', radius: 3 },
            TREASURE: { color: '#22d3ee', val: 10, type: 'treasure', radius: 5 },
            HERB: { color: '#e879f9', val: 0, type: 'herb', radius: 4 }, 
            ORE: { color: '#94a3b8', val: 10, type: 'ore', radius: 5 }, 
            RELIC: { color: '#67e8f9', val: 50, type: 'relic', radius: 6 } 
        };

        class Resource {
            constructor(x, y, typeStr, isNestSpawned = false, creatorTribeId = -1) {
                this.pos = new Vector(x, y);
                this.config = RES_TYPES[typeStr];
                // Safety: if type not found, use a default config
                if (!this.config) {
                    console.warn('Unknown resource type:', typeStr, '- using default config');
                    this.config = { color: '#ffffff', val: 1, type: 'unknown', radius: 5 };
                }
                this.type = typeStr;
                this.active = true;
                this.carrier = null;
                this.age = 0; 
                let baseDecay = (CONFIG.resourceDecayTimers && CONFIG.resourceDecayTimers[typeStr]) || CONFIG.matDecay;
                this.decayTimer = baseDecay;
                this.creatorTribe = creatorTribeId;
                if (creatorTribeId !== -1) this.nestId = creatorTribeId;
                
                // Food life system - food dies if not eaten/fertilized
                if (typeStr === 'FOOD' || typeStr === 'SEED') {
                    this.life = CONFIG.foodMinLife + Math.random() * (CONFIG.foodMaxLife - CONFIG.foodMinLife);
                    // Nest-spawned food has shorter lifespan
                    if (isNestSpawned) {
                        this.life *= CONFIG.foodNearNestLifeMultiplier; // 50% lifespan
                    }
                    this.maxLife = this.life;
                } else {
                    this.life = Infinity; // Non-food resources don't decay naturally
                }
            }
            draw(ctx) {
                if (this.carrier) return; 
                // Safety check: ensure config exists
                if (!this.config || !this.config.color) {
                    console.warn('Resource missing config:', this.type, this);
                    return; // Skip drawing if config is missing
                }
                ctx.fillStyle = this.config.color;
                ctx.beginPath();
                if (this.type === 'MAT') {
                    ctx.globalAlpha = Math.max(0.2, this.decayTimer / CONFIG.matDecay);
                    let s = this.config.radius * 2;
                    ctx.fillRect(this.pos.x - s/2, this.pos.y - s/2, s, s);
                    ctx.strokeStyle = '#b45309';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(this.pos.x - s/2, this.pos.y - s/2, s, s);
                    ctx.globalAlpha = 1.0;
                } else if (this.type === 'TREASURE') {
                    ctx.moveTo(this.pos.x, this.pos.y - 6);
                    ctx.lineTo(this.pos.x + 6, this.pos.y);
                    ctx.lineTo(this.pos.x, this.pos.y + 6);
                    ctx.lineTo(this.pos.x - 6, this.pos.y);
                    ctx.fill();
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                } else if (this.type === 'ORE') {
                    ctx.fillStyle = '#94a3b8';
                    ctx.beginPath();
                    ctx.moveTo(this.pos.x - 4, this.pos.y + 4);
                    ctx.lineTo(this.pos.x + 4, this.pos.y - 4);
                    ctx.lineTo(this.pos.x + 6, this.pos.y);
                    ctx.lineTo(this.pos.x - 2, this.pos.y + 6);
                    ctx.fill();
                    ctx.strokeStyle = '#cbd5e1';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                } else if (this.type === 'RELIC') {
                    ctx.fillStyle = '#67e8f9';
                    ctx.fillRect(this.pos.x - 4, this.pos.y - 4, 8, 8);
                    ctx.strokeStyle = '#fff';
                    ctx.strokeRect(this.pos.x - 4, this.pos.y - 4, 8, 8);
                } else if (this.type === 'SEED') {
                    ctx.arc(this.pos.x, this.pos.y, this.config.radius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = 'rgba(255,255,255,0.5)';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    let progress = this.age / CONFIG.seedGrowthTime;
                    ctx.arc(this.pos.x, this.pos.y, this.config.radius + 2, 0, Math.PI * 2 * progress);
                    ctx.stroke();
                } else {
                    ctx.arc(this.pos.x, this.pos.y, this.config.radius, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        class Plague {
            constructor(x, y) {
                this.pos = new Vector(x, y);
                this.radius = 30; // Reduced from 60 (50% reduction) - smaller range
                this.life = 1800; // 30 seconds at 60 fps (30 * 60 = 1800 frames)
            }
            update() {
                this.life--;
                this.pos.x += (Math.random()-0.5) * 4.0; 
                this.pos.y += (Math.random()-0.5) * 4.0;
            }
            draw(ctx) {
                ctx.fillStyle = '#22c55e';
                ctx.globalAlpha = Math.max(0, (this.life/5000) * 0.4);
                ctx.beginPath();
                ctx.arc(this.pos.x, this.pos.y, this.radius, 0, Math.PI*2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
            }
        }

        class Nest {
            constructor(x, y, tribeId) {
                this.pos = new Vector(x, y);
                this.tribeId = tribeId;
                this.wealth = 500; // Start with substantial wealth (was 0!)
                this.hp = 1000;
                this.defenseLevel = 0; 
                this.radius = 20;
                this.creationFrame = typeof sim !== 'undefined' ? sim.frame : 0;
                
                // Unique resource: each nest amplifies a specific random gene
                const geneOptions = ['aggression', 'defense', 'botany', 'manufacturing', 'intelligence', 
                                     'commerce', 'curiosity', 'social', 'altruism', 'speed'];
                this.uniqueGene = geneOptions[Math.floor(Math.random() * geneOptions.length)];
                this.resourceColor = `hsl(${Math.random() * 360}, 80%, 60%)`;
                
                // Siege weapons for warfare
                this.siegeCooldown = 0;
                this.maxHealth = 1000;
                this.health = 1000;
                this.driftMomentum = new Vector(0, 0);
                this.tools = [];
                this.lastToolSpawnFrame = 0;
                this.toolIdCounter = 0;
                this.babyBoom = 0; // Post-war baby boom counter (0 = inactive, >0 = active)
            }
            update() {
                // Check if nest is in baby boom (post-war reconstruction period)
                let isInBabyBoom = this.babyBoom > 0;
                
                // Check if nest is at war - war increases resource consumption by 10%
                // COUNT ACTIVE WARS - Costs are additive for each war
                let warCount = 0;
                if (typeof sim !== 'undefined' && sim.tribes) {
                    let tribe = sim.tribes.tribes[this.tribeId];
                    if (tribe && tribe.atWarWith) {
                        // Count how many wars the tribe is actively engaged in
                        for (let otherId in tribe.atWarWith) {
                            if (tribe.atWarWith[otherId] === true) {
                                warCount++;
                            }
                        }
                    }
                }
                // War costs are additive: 80% per war (1 war = 1.8x, 2 wars = 2.6x, 3 wars = 3.4x, etc.)
                // REDUCED during baby boom - winners have lower costs during reconstruction
                let warConsumptionMultiplier = (1.0 + (warCount * 0.8)) * (isInBabyBoom ? 0.5 : 1.0); // 50% reduction during baby boom
                
                // DIRECT WAR HP DAMAGE - War causes direct structural damage (wear and tear)
                // PAUSED during baby boom - war winners need to recover without ongoing damage
                // REDUCED damage to prevent both parties from dying - war should be costly but survivable
                if (warCount > 0 && !isInBabyBoom) {
                    // Only apply war damage if NOT in baby boom (winners need recovery time)
                    let warHpDamage = Math.pow(warCount, 1.2) * 0.3; // Reduced from 1.0 to 0.3, and lower exponent (1.2 vs 1.5)
                    // Lower frequency: 30% chance per frame instead of 50%
                    if (Math.random() < 0.3) { // 30% chance per frame (was 50%)
                        this.hp = Math.max(200, this.hp - warHpDamage);
                    }
                }
                
                // HP MAINTENANCE COSTS - High HP requires resources to maintain!
                // REDUCED during baby boom - war winners have reduced maintenance costs during reconstruction
                let maintenanceCostMultiplier = isInBabyBoom ? 0.3 : 1.0; // 70% reduction during baby boom
                
                let maintenanceCost = Math.max(0, (this.hp - 500) / 100); // Cost increases above 500 HP
                
                if (this.wealth > maintenanceCost * 2) {
                    // Can afford maintenance - pay the cost (scaled by war, reduced during baby boom)
                    this.wealth -= maintenanceCost * 0.1 * warConsumptionMultiplier * maintenanceCostMultiplier; // Reduced cost during baby boom
                } else {
                    // Can't afford maintenance - HP slowly decays (INCREASED during war, but REDUCED during baby boom)
                    if (Math.random() < 0.3) { // 30% chance per frame
                        this.hp -= Math.ceil((maintenanceCost / 8) * warConsumptionMultiplier * maintenanceCostMultiplier); // Reduced decay during baby boom
                    }
                }
                
                // ACCELERATED STRUCTURAL DECAY DURING WAR - Much faster decay when at war
                // PAUSED during baby boom - war winners need time to recover without decay pressure
                if (!isInBabyBoom) {
                    // Only apply decay if NOT in baby boom (winners need recovery time)
                    let baseDecayRate = CONFIG.nestHpDecayRate || 0.005; // Further reduced from 0.00825 (40% reduction)
                    // Much slower war acceleration: warCount^1.2 * 0.02 (reduced from 0.04 and lower exponent)
                    // 1 war = +0.02, 2 wars = +0.05, 3 wars = +0.09, 4 wars = +0.14 (much more sustainable)
                    let warDecayAcceleration = Math.pow(warCount, 1.2) * 0.02; // Further reduced from 0.04 (50% reduction)
                    let decayRate = baseDecayRate + warDecayAcceleration; // Exponential acceleration
                    if (Math.random() < decayRate) {
                        // War causes decay bursts, but much smaller and more sustainable
                        let decayAmount = warCount > 0 ? Math.ceil(0.5 + (Math.pow(warCount, 1.1) * 0.3)) : 0.5; // Reduced from 0.5 and lower exponent
                        this.hp = Math.max(200, this.hp - decayAmount);
                    }
                }
                
                // DELICATE NEST GROWTH/DECAY MECHANISM - Nests grow when thriving, decay when struggling
                // PAUSED during baby boom - war winners need to recover without decay pressure
                // This creates dynamic nest health based on conditions without killing nests too fast
                if (typeof sim !== 'undefined' && sim.frame % 60 === 0 && !isInBabyBoom) { // Check every 60 frames, PAUSED during baby boom
                    let tribe = sim.tribes && sim.tribes.tribes[this.tribeId];
                    if (tribe) {
                        // Count active wars for thriving score calculation
                        let warCountForThriving = 0;
                        if (tribe.atWarWith) {
                            for (let otherId in tribe.atWarWith) {
                                if (tribe.atWarWith[otherId] === true) {
                                    warCountForThriving++;
                                }
                            }
                        }
                        
                        // Calculate nest "thriving" score (0.0 to 1.0+)
                        // Positive values = thriving (should grow), Negative values = struggling (should decay)
                        let thrivingScore = 0;
                        
                        // 1. Wealth factor (0 to +0.4)
                        // Wealthy nests (above 500) should grow, poor nests (below 200) should decay
                        if (this.wealth > 500) {
                            thrivingScore += 0.4 * Math.min(1.0, (this.wealth - 500) / 1000); // Up to +0.4 for very wealthy
                        } else if (this.wealth < 200) {
                            thrivingScore -= 0.3 * (1.0 - this.wealth / 200); // Up to -0.3 for very poor
                        }
                        
                        // 2. HP health factor (0 to +0.3)
                        // Healthy nests (above 70% HP) should grow, damaged nests (below 40%) should decay
                        let hpRatio = this.hp / this.maxHealth;
                        if (hpRatio > 0.7) {
                            thrivingScore += 0.3 * ((hpRatio - 0.7) / 0.3); // Up to +0.3 for very healthy
                        } else if (hpRatio < 0.4) {
                            thrivingScore -= 0.2 * ((0.4 - hpRatio) / 0.4); // Up to -0.2 for very damaged
                        }
                        
                        // 3. Agent count factor (0 to +0.2)
                        // Nests with many agents should grow, nests with few agents should decay
                        let agentCount = sim.agents ? sim.agents.filter(a => a.tribeId === this.tribeId && !a.dead).length : 0;
                        let optimalAgentCount = 15; // Optimal number of agents per nest
                        if (agentCount > optimalAgentCount) {
                            thrivingScore += 0.2 * Math.min(1.0, (agentCount - optimalAgentCount) / 10); // Up to +0.2 for many agents
                        } else if (agentCount < optimalAgentCount * 0.4) {
                            thrivingScore -= 0.15 * (1.0 - agentCount / (optimalAgentCount * 0.4)); // Up to -0.15 for very few agents
                        }
                        
                        // 4. War penalty (-0.4 per war, additive) - Doubled for 2x war cost
                        // Nests at war should decay - more wars = more decay
                        if (warCountForThriving > 0) {
                            thrivingScore -= 0.4 * warCountForThriving; // Each war adds -0.4 penalty (doubled)
                        }
                        
                        // 5. Economic bonds structural increase (+0.08 per bond, stacking)
                        // Nests with commercial bonds experience moderate structural growth
                        let commercialBondCountForGrowth = 0;
                        if (tribe.commercialBonds) {
                            for (let otherId in tribe.commercialBonds) {
                                if (tribe.commercialBonds[otherId] > 10) { // Meaningful bond threshold
                                    commercialBondCountForGrowth++;
                                }
                            }
                        }
                        if (commercialBondCountForGrowth > 0) {
                            // Moderate structural increase: +0.08 per bond, stacking
                            // This growth can partially offset war decay if bonds are strong
                            thrivingScore += 0.08 * commercialBondCountForGrowth; // Stacking bonus per bond
                        }
                        
                        // 6. Under attack penalty (-0.15)
                        // Nests under attack should decay slightly
                        if (tribe.underAttack) {
                            thrivingScore -= 0.15;
                        }
                        
                        // Apply growth/decay based on thriving score
                        // IMPORTANT: During war, decay and repair are both applied
                        // Economic bond growth can help offset war decay, but war decay is applied first
                        // Very delicate: 0.5 to 1.5 HP per check, based on thriving score
                        // Positive score ‚Üí grow, Negative score ‚Üí decay
                        if (thrivingScore > 0.05) {
                            // Growing: Very slow HP growth (delicate)
                            let growthAmount = Math.min(1.5, thrivingScore * 2.0); // Max 1.5 HP per check
                            this.hp = Math.min(this.maxHealth, this.hp + growthAmount);
                            // Also regenerate wealth slightly when thriving
                            if (this.wealth < 1000 && Math.random() < 0.1) {
                                this.wealth += 1;
                    }
                        } else if (thrivingScore < -0.05) {
                            // Decaying: Very slow HP decay (delicate)
                            let decayAmount = Math.min(1.5, Math.abs(thrivingScore) * 2.0); // Max 1.5 HP per check
                            this.hp = Math.max(200, this.hp - decayAmount); // Never go below 200 HP from this
                        }
                        // If thrivingScore is between -0.05 and +0.05, no change (stable)
                    }
                }
                
                // NEST AGENT SPAWNING - Randomly spawn agents up to tech level
                // New nests are more fertile - 10% higher spawn rate for first 1000 frames
                // Tech-based spawn bonus: 50% more spawning based on tech level
                if (typeof sim !== 'undefined' && sim.agents && sim.frame % 50 === 0) {
                    let nestAge = sim.frame - this.creationFrame;
                    let isNewNest = nestAge < 1000;
                    let spawnRate = CONFIG.nestAgentSpawnRate || 0.003;
                    if (isNewNest) {
                        spawnRate *= 1.1; // 10% boost for new nests
                    }
                    
                    // TECH-BASED SPAWN BONUS: 50% more spawning per tech tier (ongoing)
                    let tribe = sim.tribes && sim.tribes.tribes[this.tribeId];
                    if (tribe && tribe.techTier !== undefined) {
                        let techSpawnBonus = 1.0 + (tribe.techTier * 0.5); // +50% per tech tier (1.0x, 1.5x, 2.0x, etc.)
                        spawnRate *= techSpawnBonus;
                    }
                    
                    // Check for POST-WAR BABY BOOM - 20x spawning of all agent types
                    let isInBabyBoom = this.babyBoom > 0;
                    
                    if (isInBabyBoom) {
                        // BABY BOOM - Massive spawning of ALL agent types (STRENGTHENED)
                        // Wealth factor is more generous - full rate at lower wealth threshold
                        let wealthFactor = Math.min(1.0, this.wealth / 200); // INCREASED: Full rate at 200+ wealth (was 300)
                        let festivalSpawnRate = (CONFIG.nestAgentSpawnRate || 0.003) * (15.0 + (15.0 * wealthFactor)); // INCREASED: 15-30x normal rate (was 10-20x), scales with wealth
                        
                        // Only spawn if nest has enough wealth to support new agents
                        // Lower threshold - winners can spawn even with less wealth (baby boom is strong!)
                        let minWealthForSpawn = 30; // REDUCED: 30 wealth minimum (was 50)
                        if (this.wealth >= minWealthForSpawn && Math.random() < festivalSpawnRate) {
                            let tribe = sim.tribes && sim.tribes.tribes[this.tribeId];
                            if (tribe && tribe.techTier !== undefined) {
                                // Build list of ALL available roles for baby boom
                                let allAvailableRoles = [];
                                if (typeof CONFIG.agentSpawnRates === 'object') {
                                    for (let role in CONFIG.agentSpawnRates) {
                                        // Check tech tier requirements
                                        let requiredTier = 0;
                                        if (role === 'Merchant' || role === 'Diplomat' || role === 'Scientist') requiredTier = 1;
                                        if (role === 'Artisan' || role === 'Guardian') requiredTier = 1;
                                        if (role === 'Raider') requiredTier = 2;
                                        if (tribe.techTier >= requiredTier || role === 'Soldier' || role === 'Gatherer' || role === 'Scout' || role === 'Builder' || role === 'Farmer') {
                                            allAvailableRoles.push(role);
                                        }
                                    }
                                }
                                // Always include basic roles
                                if (allAvailableRoles.length === 0) {
                                    allAvailableRoles = ['Gatherer', 'Scout', 'Builder', 'Farmer', 'Soldier'];
                                }
                                
                                // Spawn multiple agents during baby boom (celebration!)
                                // More generous wealth limits - baby boom should be strong!
                                let maxAffordableAgents = Math.floor(this.wealth / 30); // REDUCED: 30 wealth per agent (was 50)
                                let numToSpawn = Math.min(3 + Math.floor(Math.random() * 5), maxAffordableAgents, 5); // INCREASED: 3-5 agents (was 2-3), limited by wealth
                                let spawnedCount = 0;
                                
                                // Lower wealth threshold - allow spawning with less wealth during baby boom
                                for (let i = 0; i < numToSpawn && spawnedCount < 5 && this.wealth >= 20; i++) { // INCREASED: 5 max (was 3), 20 wealth minimum (was 30)
                                    let role = allAvailableRoles[Math.floor(Math.random() * allAvailableRoles.length)];
                                    let agent = sim.spawnAgent(role, this);
                                    if (agent) {
                                        agent.role = role;
                                        agent.determineRole();
                                        let angle = (spawnedCount / numToSpawn) * Math.PI * 2;
                                        let offset = 20 + Math.random() * 15;
                                        agent.pos.x += Math.cos(angle) * offset;
                                        agent.pos.y += Math.sin(angle) * offset;
                                        // Celebration VFX - golden stars for baby boom
                                        sim.particles.push(new Particle(agent.pos.x, agent.pos.y, '#fbbf24', 'star'));
                                        // Celebration SFX for baby boom
                                        if (spawnedCount === 0) { // Play once per spawn event
                                            sfx.play('birth', getHarmonicFreq([HARMONICS.C5, HARMONICS.E5, HARMONICS.G5, HARMONICS.A5], 10), 0.08); // Harmonic birth tone
                                        }
                                        spawnedCount++;
                                    }
                                }
                            }
                        }
                    }
                    
                    // Check if tribe is at war - massively increase fighting role spawn rate
                    let isAtWar = false;
                    let warCount = 0;
                    if (typeof sim.tribes !== 'undefined' && sim.tribes.tribes) {
                        let tribe = sim.tribes.tribes[this.tribeId];
                        if (tribe && tribe.atWarWith) {
                            for (let otherId in tribe.atWarWith) {
                                if (tribe.atWarWith[otherId] === true) {
                                    isAtWar = true;
                                    warCount++;
                                }
                            }
                    }
                    
                    // Check for COMMERCIAL BONDS - Economic benefits for trading nests
                    let hasCommercialBonds = false;
                    let commercialBondCount = 0;
                    if (typeof sim.tribes !== 'undefined' && sim.tribes.tribes) {
                        let tribe = sim.tribes.tribes[this.tribeId];
                        if (tribe && tribe.commercialBonds) {
                            for (let otherId in tribe.commercialBonds) {
                                if (tribe.commercialBonds[otherId] > 10) { // Meaningful bond threshold
                                    hasCommercialBonds = true;
                                    commercialBondCount++;
                                }
                            }
                        }
                    }
                    
                    // ECONOMIC BOND BENEFITS - Increased spawning of money-making roles
                    if (hasCommercialBonds && !isInBabyBoom) {
                        let moneyMakingRoles = ['Merchant', 'Artisan', 'Miner', 'Builder', 'Farmer'];
                        let economicSpawnBonus = 1.0 + (commercialBondCount * 0.15); // 15% per bond, modest increase
                        let economicSpawnRate = (CONFIG.nestAgentSpawnRate || 0.003) * economicSpawnBonus;
                        
                        if (Math.random() < economicSpawnRate) {
                            let tribe = sim.tribes && sim.tribes.tribes[this.tribeId];
                            if (tribe && tribe.techTier !== undefined) {
                                let availableMoneyRoles = moneyMakingRoles.filter(role => {
                                    let requiredTier = 0;
                                    if (role === 'Merchant' || role === 'Artisan') requiredTier = 1;
                                    return tribe.techTier >= requiredTier || role === 'Miner' || role === 'Builder' || role === 'Farmer';
                                });
                                
                                if (availableMoneyRoles.length > 0) {
                                    let role = availableMoneyRoles[Math.floor(Math.random() * availableMoneyRoles.length)];
                                    let agent = sim.spawnAgent(role, this);
                                    if (agent) {
                                        agent.role = role;
                                        agent.determineRole();
                                        let angle = Math.random() * Math.PI * 2;
                                        let offset = 20 + Math.random() * 10;
                                        agent.pos.x += Math.cos(angle) * offset;
                                        agent.pos.y += Math.sin(angle) * offset;
                                        sim.particles.push(new Particle(agent.pos.x, agent.pos.y, '#10b981', 'coin')); // Green for economic spawn
                                        // SFX for economic bond spawning
                                        sfx.play('spawn', getHarmonicFreq([HARMONICS.C5, HARMONICS.D5, HARMONICS.E5], 5), 0.08);
                                    }
                                }
                            }
                        }
                    }
                    
                    // WAR-TIME FIGHTING ROLE SPAWNING - 10x spawn rate for fighting roles during war (skip during baby boom)
                    if (isAtWar && !isInBabyBoom) {
                        let fightingRoleSpawnRate = (CONFIG.nestAgentSpawnRate || 0.003) * 10.0; // 10x normal rate
                        let fightingRoles = ['Soldier', 'Raider', 'Guardian'];
                        
                        // Check tech tier for fighting roles
                        let tribeForWar = sim.tribes && sim.tribes.tribes[this.tribeId];
                        let availableFightingRoles = [];
                        if (tribeForWar && tribeForWar.techTier !== undefined) {
                            for (let role of fightingRoles) {
                                let requiredTier = (role === 'Raider') ? 2 : 1; // Raider needs tier 2, others need tier 1
                                if (tribeForWar.techTier >= requiredTier || role === 'Soldier') { // Soldier always available
                                    availableFightingRoles.push(role);
                                }
                            }
                        } else {
                            // Fallback: at least spawn Soldiers
                            availableFightingRoles = ['Soldier'];
                        }
                        
                        // Spawn fighting roles at 10x rate during war
                        if (availableFightingRoles.length > 0 && Math.random() < fightingRoleSpawnRate) {
                            let role = availableFightingRoles[Math.floor(Math.random() * availableFightingRoles.length)];
                            let agent = sim.spawnAgent(role, this);
                            if (agent) {
                                agent.role = role;
                                agent.determineRole();
                                // Offset spawn position
                                let angle = Math.random() * Math.PI * 2;
                                let offset = 15 + Math.random() * 10;
                                agent.pos.x += Math.cos(angle) * offset;
                                agent.pos.y += Math.sin(angle) * offset;
                                sim.particles.push(new Particle(agent.pos.x, agent.pos.y, '#dc2626', 'spark')); // Red for war spawns
                                // SFX for war-time spawning
                                sfx.play('spawn', getHarmonicFreq([HARMONICS.A4, HARMONICS.C5, HARMONICS.D5, HARMONICS.E5], 8), 0.1);
                            }
                        }
                    }
                    
                    // Normal agent spawning (reduced priority during war, but still happens)
                    if (Math.random() < spawnRate) {
                        let tribe = sim.tribes && sim.tribes.tribes[this.tribeId];
                        if (tribe && tribe.techTier !== undefined) {
                            // Build list of all spawnable roles based on tech tier
                            let allAvailableRoles = [];
                            if (typeof CONFIG.agentSpawnRates === 'object') {
                                for (let role in CONFIG.agentSpawnRates) {
                                    // Check tech tier requirements
                                    let requiredTier = 0;
                                    if (role === 'Merchant' || role === 'Diplomat' || role === 'Scientist') requiredTier = 1;
                                    if (role === 'Artisan' || role === 'Guardian') requiredTier = 1;
                                    if (tribe.techTier >= requiredTier) {
                                        allAvailableRoles.push(role);
                                    }
                                }
                            }
                            // Always include basic roles
                            if (allAvailableRoles.length === 0) {
                                allAvailableRoles = ['Gatherer', 'Scout', 'Builder', 'Farmer'];
                            }
                            
                            // During war, prioritize fighting roles in normal spawns too
                            if (isAtWar) {
                                let fightingRoles = ['Soldier', 'Raider', 'Guardian'].filter(r => allAvailableRoles.includes(r));
                                // Add fighting roles multiple times to increase their spawn probability
                                for (let i = 0; i < 3; i++) {
                                    allAvailableRoles.push(...fightingRoles);
                                }
                            }
                            
                            // During economic bonds, prioritize money-making roles (modest increase)
                            if (hasCommercialBonds) {
                                let moneyRoles = ['Merchant', 'Artisan', 'Miner', 'Builder', 'Farmer'].filter(r => allAvailableRoles.includes(r));
                                // Add money-making roles to increase their spawn probability (less than war, modest)
                                for (let i = 0; i < 2; i++) {
                                    allAvailableRoles.push(...moneyRoles);
                                }
                            }
                            
                            // Spawn random number (1-6) of random agent types at once
                            let numToSpawn = 1 + Math.floor(Math.random() * 6); // 1-6 agents
                            let spawnedCount = 0;
                            let attemptedRoles = new Set(); // Track roles we've tried to avoid duplicates if desired
                            
                            for (let i = 0; i < numToSpawn && spawnedCount < 6; i++) {
                                // Pick a random role from available roles
                                let role = allAvailableRoles[Math.floor(Math.random() * allAvailableRoles.length)];
                                
                                // Spawn the agent
                                let agent = sim.spawnAgent(role, this);
                                if (agent) {
                                    agent.role = role;
                                    agent.determineRole();
                                    // Slightly offset spawn positions so they don't overlap
                                    let angle = (spawnedCount / numToSpawn) * Math.PI * 2;
                                    let offset = 15 + Math.random() * 10;
                                    agent.pos.x += Math.cos(angle) * offset;
                                    agent.pos.y += Math.sin(angle) * offset;
                                    sim.particles.push(new Particle(agent.pos.x, agent.pos.y, '#60a5fa', 'spark'));
                                    // SFX for normal spawning
                                    if (spawnedCount === 0) { // Play once per spawn event, not per agent
                                        sfx.play('spawn', getHarmonicFreq([HARMONICS.C5, HARMONICS.D5, HARMONICS.E5], 5), 0.06);
                                    }
                                    spawnedCount++;
                                }
                            }
                        }
                    }
                }
                
                this.health = this.hp; // Sync health with hp
                this.defenseLevel = Math.floor(this.hp / 500); 
                
                // Decrement baby boom counter and maintain prosperity bonus
                if (this.babyBoom > 0) {
                    this.babyBoom--;
                    
                    // CONTINUOUS HP REGENERATION during baby boom - Winners recover from war damage
                    // War winners heal continuously during baby boom to survive the reconstruction period
                    if (typeof sim !== 'undefined' && sim.frame % 20 === 0) { // Every 20 frames
                        // Regenerate HP (post-war reconstruction and healing)
                        let hpRegen = Math.min(5, (this.maxHealth - this.hp) * 0.02); // Up to 5 HP per check, 2% of missing HP
                        this.hp = Math.min(this.maxHealth, this.hp + hpRegen);
                        this.health = Math.min(this.maxHealth, this.hp); // Sync health property
                    }
                    
                    // CONTINUOUS WEALTH GENERATION during baby boom to support workforce (INCREASED)
                    // Baby boom nests generate wealth continuously to afford the larger population
                    if (typeof sim !== 'undefined' && sim.frame % 10 === 0) { // Every 10 frames
                        // Base wealth generation increases with agent count (agents work to support the nest)
                        let agentCount = sim.agents ? sim.agents.filter(a => a.tribeId === this.tribeId && !a.dead).length : 0;
                        let baseGeneration = 4 + (agentCount * 0.5); // INCREASED: 4 base (was 2) + 0.5 per agent (was 0.3)
                        this.wealth += baseGeneration;
                        
                        // Spawn resources frequently during baby boom (victory spoils continue to flow in)
                        if (Math.random() < 0.35) { // INCREASED: 35% chance per check (was 25%)
                            let resourceTypes = ['FOOD', 'MAT', 'ORE', 'TREASURE'];
                            let resourceType = resourceTypes[Math.floor(Math.random() * resourceTypes.length)];
                            sim.spawnResource(null, 
                                this.pos.x + (Math.random() * 50 - 25),
                                this.pos.y + (Math.random() * 50 - 25),
                                resourceType, false, this.tribeId
                            );
                        }
                    }
                    
                    // MAINTAIN WEALTH AND PROSPERITY BONUS during baby boom (INCREASED TARGET)
                    // Replenish coffers to 80% of max health periodically (every 50 frames, increased from 70%)
                    if (this.babyBoom % 50 === 0) {
                        let prosperityWealthTarget = this.maxHealth * 0.8; // INCREASED: 80% of max health (was 70%)
                        if (this.wealth < prosperityWealthTarget) {
                            // Replenish to prosperity target
                            let replenishAmount = prosperityWealthTarget - this.wealth;
                            this.wealth += replenishAmount;
                            
                            // Occasional prosperity VFX
                            if (Math.random() < 0.3) {
                                sim.particles.push(new Particle(this.pos.x, this.pos.y, '#fbbf24', 'coin'));
                            }
                        }
                    }
                    
                    // MAINTAIN HP DURING BABY BOOM - Ensure winners don't die from accumulated war damage
                    // Restore HP if it drops below safe threshold during baby boom
                    if (typeof sim !== 'undefined' && sim.frame % 100 === 0) { // Every 100 frames
                        let safeHpThreshold = this.maxHealth * 0.6; // 60% of max health
                        if (this.hp < safeHpThreshold) {
                            // Restore HP to safe threshold (post-war reconstruction ensures structural integrity)
                            let hpRestore = safeHpThreshold - this.hp;
                            this.hp += hpRestore;
                            this.health = Math.min(this.maxHealth, this.hp);
                            
                            // VFX for HP restoration
                            if (Math.random() < 0.4) {
                                sim.particles.push(new Particle(this.pos.x, this.pos.y, '#3b82f6', 'spark'));
                            }
                        }
                    }
                }
                
                // SURVIVAL MECHANISM - Dying nests raise taxes and increase workforce
                // When a nest is in distress, it takes emergency measures to survive
                if (typeof sim !== 'undefined' && sim.frame % 30 === 0) { // Check every 30 frames
                    let isInDistress = this.hp < this.maxHealth * 0.5 || this.wealth < 200;
                    
                    if (isInDistress) {
                        let distressLevel = Math.max(
                            (1.0 - (this.hp / this.maxHealth * 2)), // HP distress (0-1)
                            (1.0 - (this.wealth / 200)) // Wealth distress (0-1)
                        );
                        distressLevel = Math.min(1.0, distressLevel); // Cap at 1.0
                        
                        // 1. RAISE TAXES - Extract more wealth from agents (emergency taxation)
                        // TRIBES TAX POPULATIONS ON ALL FORMS OF VALUE AND CONVERT TO WHAT TRIBE NEEDS
                        let tribeMembers = sim.agents.filter(a => a.tribeId === this.tribeId && !a.dead);
                        if (tribeMembers.length > 0) {
                            // Tax rate increases with distress level (10-30% of agent energy/wealth)
                            let taxRate = 0.1 + (distressLevel * 0.2); // 10-30% tax
                            
                            // Determine what tribe needs most (wealth, HP, or resources)
                            let needsWealth = this.wealth < this.maxHealth * 0.3; // Need wealth if below 30% of max health
                            let needsHp = this.hp < this.maxHealth * 0.5; // Need HP if below 50%
                            let needsResources = this.wealth < 100; // Need resources if very poor
                            
                            let totalTaxed = 0;
                            tribeMembers.forEach(agent => {
                                // TAX ENERGY - Convert to what tribe needs
                                if (agent.energy > 20) {
                                    let taxAmount = Math.min(agent.energy * taxRate, agent.energy * 0.3); // Max 30% of energy
                                    agent.energy -= taxAmount;
                                    
                                    if (needsHp && this.hp < this.maxHealth) {
                                        // Convert energy to HP (tribe needs health)
                                        let hpGain = taxAmount * 0.1; // 10% efficiency
                                        this.hp = Math.min(this.maxHealth, this.hp + hpGain);
                                        this.health = Math.min(this.maxHealth, this.hp);
                                    } else {
                                        // Convert energy to wealth (tribe needs money)
                                        let wealthGain = taxAmount * 0.5; // 50% efficiency
                                        this.wealth += wealthGain;
                                        totalTaxed += wealthGain;
                                    }
                                    
                                    // VFX for tax collection (occasional)
                                    if (Math.random() < 0.15) {
                                        sim.particles.push(new Particle(agent.pos.x, agent.pos.y, '#f59e0b', 'coin'));
                                    }
                                }
                                
                                // TAX WEALTH - Direct wealth transfer
                                if (agent.wealth > 10) {
                                    let wealthTax = Math.min(agent.wealth * taxRate, agent.wealth * 0.25); // Max 25% of wealth
                                    agent.wealth -= wealthTax;
                                    this.wealth += wealthTax;
                                    totalTaxed += wealthTax;
                                }
                                
                                // TAX RESOURCES - Extract from agents carrying resources and convert to what tribe needs
                                if (agent.carrying) {
                                    let resourceType = agent.carrying.type;
                                    let resourceValue = weightedResourceEnergy(resourceType) || 30;
                                    
                                    // Convert resource to what tribe needs
                                    if (needsHp && (resourceType === 'HERB' || resourceType === 'STIM')) {
                                        // Herbs/Stims can heal nest
                                        let hpGain = resourceValue * 0.2;
                                        this.hp = Math.min(this.maxHealth, this.hp + hpGain);
                                        this.health = Math.min(this.maxHealth, this.hp);
                                        // Remove resource after taxing
                                        agent.carrying.active = false;
                                        agent.carrying = null;
                                    } else {
                                        // Convert resource value to wealth
                                        let resourceTax = resourceValue * taxRate * 0.3; // 30% of resource value
                                        this.wealth += resourceTax;
                                        totalTaxed += resourceTax;
                                    }
                                }
                            });
                            
                            // SFX for emergency taxation (if significant amount collected)
                            if (totalTaxed > 5 && Math.random() < 0.3) {
                                sfx.play('transaction', getHarmonicFreq([HARMONICS.C5, HARMONICS.D5, HARMONICS.E5], 5), 0.08);
                                // VFX at nest for tax collection
                                sim.particles.push(new Particle(this.pos.x, this.pos.y, '#f59e0b', 'coin'));
                            }
                        }
                        
                        // 2. INCREASE WORKFORCE - Spawn more resource-gathering agents
                        // Distressed nests spawn workers at 3-5x normal rate
                        let emergencySpawnRate = (CONFIG.nestAgentSpawnRate || 0.02) * (3 + distressLevel * 2); // 3-5x
                        if (Math.random() < emergencySpawnRate) {
                            let workerRoles = ['Gatherer', 'Miner', 'Farmer', 'Builder'];
                            let role = workerRoles[Math.floor(Math.random() * workerRoles.length)];
                            let newAgent = sim.spawnAgent(role, this);
                            if (newAgent) {
                                newAgent.role = role;
                                newAgent.determineRole();
                                // VFX for emergency worker spawn
                                sim.particles.push(new Particle(newAgent.pos.x, newAgent.pos.y, '#f59e0b', 'spark'));
                                // SFX for emergency spawning
                                sfx.play('spawn', getHarmonicFreq([HARMONICS.A4, HARMONICS.C5, HARMONICS.D5, HARMONICS.E5], 8), 0.1);
                            }
                        }
                        
                        // 3. INCREASE RESOURCE PRODUCTION - Spawn resources directly
                        // Distressed nests produce resources at 2-4x normal rate
                        if (Math.random() < (0.15 * (1 + distressLevel * 2))) { // 15-45% chance
                            let resourceTypes = ['FOOD', 'MAT', 'ORE'];
                            let resourceType = resourceTypes[Math.floor(Math.random() * resourceTypes.length)];
                            sim.spawnResource(null, 
                                this.pos.x + (Math.random() * 60 - 30),
                                this.pos.y + (Math.random() * 60 - 30),
                                resourceType, false, this.tribeId
                            );
                            // VFX for emergency resource production
                            if (Math.random() < 0.3) {
                                sim.particles.push(new Particle(this.pos.x, this.pos.y, '#ef4444', 'spark'));
                                // SFX for emergency resource production
                                sfx.play('collect', getHarmonicFreq([HARMONICS.C5, HARMONICS.D5, HARMONICS.E5], 5), 0.08);
                            }
                        }
                    }
                }
                
                // CHECK FOR NEST DEATH - If HP reaches minimum, nest dies and spoils are distributed
                if (this.hp <= 200 && typeof sim !== 'undefined') {
                    // Calculate total nest value: wealth + structural health (HP) + energy from agents + resources
                    let totalWealth = this.wealth;
                    let structuralHealth = this.maxHealth; // Structural health represented as treasure
                    let totalEnergy = 0;
                    let totalResources = [];
                    
                    // Collect energy and resources from all tribe members
                    let tribeMembers = sim.agents.filter(a => a.tribeId === this.tribeId && !a.dead);
                    tribeMembers.forEach(agent => {
                        // Collect energy (convert to wealth/resources)
                        if (agent.energy > 50) {
                            totalEnergy += agent.energy * 0.3; // 30% of agent energy
                        }
                        // Collect resources they're carrying
                        if (agent.carrying && agent.carrying.active) {
                            totalResources.push(agent.carrying.type);
                            agent.carrying.active = false;
                            agent.carrying = null;
                        }
                    });
                    
                    // Convert energy to wealth
                    totalWealth += totalEnergy * 0.5; // 50% efficiency
                    
                    // Nest's structural health becomes treasure (represents accumulated infrastructure)
                    let treasureFromStructure = Math.floor(structuralHealth / 10); // 1 treasure per 10 HP
                    
                    // Find all nests at war with this nest
                    let warringNests = [];
                    if (typeof sim.tribes !== 'undefined' && sim.tribes.tribes) {
                        let deadTribe = sim.tribes.tribes[this.tribeId];
                        if (deadTribe && deadTribe.atWarWith) {
                            for (let otherId in deadTribe.atWarWith) {
                                if (deadTribe.atWarWith[otherId] === true) {
                                    let enemyNests = sim.tribes.nests.filter(n => n.tribeId == otherId && n !== this && n.hp > 0);
                                    warringNests.push(...enemyNests);
                                }
                            }
                        }
                        
                        // Also check reverse - nests that are at war with this nest
                        for (let tid in sim.tribes.tribes) {
                            let otherTribe = sim.tribes.tribes[tid];
                            if (otherTribe && otherTribe.atWarWith && otherTribe.atWarWith[this.tribeId] === true) {
                                let enemyNests = sim.tribes.nests.filter(n => n.tribeId == tid && n !== this && n.hp > 0);
                                warringNests.push(...enemyNests);
                            }
                        }
                    }
                    
                    // DISTRIBUTE ALL VALUE TO WAR WINNERS OR SCATTER IF NO WINNERS
                    if (warringNests.length > 0) {
                        // DISTRIBUTE TO WAR WINNERS
                        let wealthPerNest = totalWealth > 0 ? Math.floor(totalWealth / warringNests.length) : 0;
                        let treasurePerNest = Math.floor(treasureFromStructure / warringNests.length);
                        let resourcesPerNest = Math.floor(totalResources.length / warringNests.length);
                        
                        // CONVERT ALL LOSING TRIBE MEMBERS TO WINNERS - Divide citizens among winning nests
                        let losingTribeMembers = sim.agents.filter(a => a.tribeId === this.tribeId && !a.dead);
                        let membersPerNest = Math.floor(losingTribeMembers.length / warringNests.length);
                        let memberIndex = 0;
                        
                        warringNests.forEach((winnerNest, nestIndex) => {
                            // POST-WAR RECONSTRUCTION: Double the winner's wealth immediately
                            winnerNest.wealth = winnerNest.wealth * 2;
                            
                            // Add spoils from defeated nest (wealth, energy converted to wealth, structural treasure)
                            if (wealthPerNest > 0) {
                                winnerNest.wealth += wealthPerNest;
                            }
                            
                            // Distribute structural treasure (represents infrastructure value)
                            for (let i = 0; i < treasurePerNest; i++) {
                                let angle = Math.random() * Math.PI * 2;
                                let dist = 20 + Math.random() * 30;
                                sim.spawnResource(null,
                                    winnerNest.pos.x + Math.cos(angle) * dist,
                                    winnerNest.pos.y + Math.sin(angle) * dist,
                                    'TREASURE', false, winnerNest.tribeId
                                );
                            }
                            
                            // Distribute resources from defeated nest
                            let resourceStart = nestIndex * resourcesPerNest;
                            let resourceEnd = (nestIndex === warringNests.length - 1) ? totalResources.length : resourceStart + resourcesPerNest;
                            for (let i = resourceStart; i < resourceEnd; i++) {
                                if (totalResources[i]) {
                                    let angle = Math.random() * Math.PI * 2;
                                    let dist = 20 + Math.random() * 30;
                                    sim.spawnResource(null,
                                        winnerNest.pos.x + Math.cos(angle) * dist,
                                        winnerNest.pos.y + Math.sin(angle) * dist,
                                        totalResources[i], false, winnerNest.tribeId
                                    );
                                }
                            }
                            
                            // CONVERT LOSING TRIBE MEMBERS TO WINNER'S TRIBE
                            // Assign citizens to this winning nest (divide equally)
                            let membersToConvert = (nestIndex === warringNests.length - 1) 
                                ? losingTribeMembers.slice(memberIndex) // Last nest gets remaining members
                                : losingTribeMembers.slice(memberIndex, memberIndex + membersPerNest);
                            
                            membersToConvert.forEach(member => {
                                let oldTribeId = member.tribeId;
                                member.tribeId = winnerNest.tribeId;
                                member.nest = winnerNest;
                                
                                // Update loyalty to new tribe
                                member.loyalty[winnerNest.tribeId] = 50; // Initial loyalty
                                member.loyalty[oldTribeId] = (member.loyalty[oldTribeId] || 0) * 0.5; // Reduce old loyalty
                                
                                // VFX for conversion
                                sim.particles.push(new Particle(member.pos.x, member.pos.y, '#10b981', 'spark'));
                            });
                            
                            memberIndex += membersPerNest;
                            
                            // START BABY BOOM - 20x spawning for 750 frames (reduced from 1500 for graphics stability)
                            winnerNest.babyBoom = 750;
                            
                            // IMMEDIATE HP RESTORATION - War winners need full health to survive post-war
                            // Restore HP to 85% of max (gives buffer but not instant full recovery)
                            let hpRestoreTarget = winnerNest.maxHealth * 0.85; // 85% of max health
                            if (winnerNest.hp < hpRestoreTarget) {
                                winnerNest.hp = hpRestoreTarget;
                            }
                            // Also restore health property for consistency
                            winnerNest.health = Math.min(winnerNest.maxHealth, winnerNest.hp);
                            
                            // WEALTH AND PROSPERITY BONUS - Replenish coffers to 80% of full health during baby boom (INCREASED from 70%)
                            // This represents the prosperity and economic boost from victory
                            let prosperityWealthTarget = winnerNest.maxHealth * 0.8; // 80% of max health (increased from 70%)
                            if (winnerNest.wealth < prosperityWealthTarget) {
                                // Boost wealth to prosperity target if below it
                                winnerNest.wealth = Math.max(winnerNest.wealth, prosperityWealthTarget);
                            } else {
                                // If already above, add a prosperity bonus (15% of max health as extra prosperity, increased from 10%)
                                winnerNest.wealth += winnerNest.maxHealth * 0.15;
                            }
                            
                            // Massive celebration VFX
                            for (let i = 0; i < 10; i++) {
                                let angle = (i / 10) * Math.PI * 2;
                                let dist = 30 + Math.random() * 20;
                                sim.particles.push(new Particle(
                                    winnerNest.pos.x + Math.cos(angle) * dist,
                                    winnerNest.pos.y + Math.sin(angle) * dist,
                                    '#fbbf24', 'star'
                                ));
                            }
                            sim.particles.push(new Particle(winnerNest.pos.x, winnerNest.pos.y, '#10b981', 'explosion')); // Green for victory
                        });
                        
                        // DIPLOMATIC BOON - All diplomatic partners of winners get resources and economy boost
                        warringNests.forEach((winnerNest) => {
                            if (typeof sim !== 'undefined' && sim.tribes && sim.tribes.tribes[winnerNest.tribeId]) {
                                let winnerTribe = sim.tribes.tribes[winnerNest.tribeId];
                                
                                // Find all diplomatic partners of the winner
                                if (winnerTribe.diplomaticBonds) {
                                    for (let partnerId in winnerTribe.diplomaticBonds) {
                                        let bondStrength = winnerTribe.diplomaticBonds[partnerId];
                                        if (bondStrength > 10) { // Meaningful bond threshold
                                            // Find the partner nest
                                            let partnerNest = sim.tribes.nests.find(n => n.tribeId === parseInt(partnerId) && n.hp > 0);
                                            if (partnerNest) {
                                                // Diplomatic boon: Wealth and resources boost
                                                // Bond strength determines boon size (scaled by bond strength / 100)
                                                let boonMultiplier = bondStrength / 100; // 0.1 to 1.0
                                                let wealthBoon = winnerNest.maxHealth * 0.15 * boonMultiplier; // 15% of winner's max health, scaled by bond
                                                let hpBoon = partnerNest.maxHealth * 0.1 * boonMultiplier; // 10% HP boost, scaled by bond
                                                
                                                // Apply boon
                                                partnerNest.wealth += wealthBoon;
                                                partnerNest.hp = Math.min(partnerNest.maxHealth, partnerNest.hp + hpBoon);
                                                partnerNest.health = Math.min(partnerNest.maxHealth, partnerNest.hp);
                                                
                                                // Strengthen diplomatic bond (reward for alliance)
                                                winnerTribe.diplomaticBonds[partnerId] = Math.min(100, bondStrength + 5);
                                                if (sim.tribes.tribes[partnerId]) {
                                                    sim.tribes.tribes[partnerId].diplomaticBonds[winnerNest.tribeId] = Math.min(100, (sim.tribes.tribes[partnerId].diplomaticBonds[winnerNest.tribeId] || 0) + 5);
                                                }
                                                
                                                // Spawn resources near partner nest (victory spoils shared with allies)
                                                for (let i = 0; i < Math.floor(3 * boonMultiplier); i++) {
                                                    let angle = (i / 3) * Math.PI * 2;
                                                    let dist = 20 + Math.random() * 30;
                                                    let resourceTypes = ['FOOD', 'MAT', 'ORE', 'TREASURE'];
                                                    let resourceType = resourceTypes[Math.floor(Math.random() * resourceTypes.length)];
                                                    sim.spawnResource(null,
                                                        partnerNest.pos.x + Math.cos(angle) * dist,
                                                        partnerNest.pos.y + Math.sin(angle) * dist,
                                                        resourceType, false, partnerNest.tribeId
                                                    );
                                                }
                                                
                                                // VFX for diplomatic boon
                                                sim.particles.push(new Particle(partnerNest.pos.x, partnerNest.pos.y, '#3b82f6', 'star')); // Blue for diplomatic
                                                sim.particles.push(new Particle(partnerNest.pos.x, partnerNest.pos.y, '#fbbf24', 'coin')); // Gold for wealth
                                                
                                                // SFX for boon
                                                sfx.play('bond', getHarmonicFreq([HARMONICS.A4, HARMONICS.C5, HARMONICS.E5, HARMONICS.G5], 10), 0.15);
                                                
                                                console.log(`Diplomatic boon: Tribe ${partnerId} received ${wealthBoon.toFixed(1)} wealth and ${hpBoon.toFixed(1)} HP from ally ${winnerNest.tribeId}'s victory!`);
                                            }
                                        }
                                    }
                                }
                            }
                        });
                        
                        console.log(`Nest of tribe ${this.tribeId} destroyed! ${losingTribeMembers.length} citizens converted to ${warringNests.length} winning tribes. Post-war reconstruction: doubled wealth + spoils + 750-frame baby boom!`);
                    } else {
                        // NO WAR WINNERS - SCATTER ALL VALUE WIDELY AROUND NEST IN RANDOM FORMS
                        // Scatter wealth, energy, resources, and structural treasure as random resources
                        let totalValue = totalWealth + (totalEnergy * 0.5) + (structuralHealth / 2);
                        let scatterCount = Math.min(50, Math.floor(totalValue / 20)); // Scatter up to 50 resources
                        
                        let resourceTypes = ['FOOD', 'MAT', 'ORE', 'TREASURE', 'HERB', 'STIM', 'RELIC', 'UNIQUE'];
                        
                        for (let i = 0; i < scatterCount; i++) {
                            let angle = Math.random() * Math.PI * 2;
                            let dist = 50 + Math.random() * 150; // Wide scatter (50-200 pixels from nest)
                            let resourceType = resourceTypes[Math.floor(Math.random() * resourceTypes.length)];
                            
                            // Weighted random - more valuable resources are rarer
                            let rand = Math.random();
                            if (rand < 0.4) resourceType = 'FOOD'; // 40% food
                            else if (rand < 0.6) resourceType = 'MAT'; // 20% materials
                            else if (rand < 0.75) resourceType = 'ORE'; // 15% ore
                            else if (rand < 0.85) resourceType = 'HERB'; // 10% herbs
                            else if (rand < 0.92) resourceType = 'STIM'; // 7% stims
                            else if (rand < 0.97) resourceType = 'TREASURE'; // 5% treasure
                            else if (rand < 0.99) resourceType = 'RELIC'; // 2% relics
                            else resourceType = 'UNIQUE'; // 1% unique
                            
                            sim.spawnResource(null,
                                this.pos.x + Math.cos(angle) * dist,
                                this.pos.y + Math.sin(angle) * dist,
                                resourceType, false, -1 // Unaffiliated resources
                            );
                        }
                        
                        // Also scatter remaining resources from agents
                        totalResources.forEach(resourceType => {
                            let angle = Math.random() * Math.PI * 2;
                            let dist = 50 + Math.random() * 150;
                            sim.spawnResource(null,
                                this.pos.x + Math.cos(angle) * dist,
                                this.pos.y + Math.sin(angle) * dist,
                                resourceType, false, -1
                            );
                        });
                        
                        console.log(`Nest of tribe ${this.tribeId} destroyed! No war winners - ${scatterCount} resources scattered widely around nest location.`);
                    }
                    
                    // Mark nest for removal
                    this.hp = 0;
                    this.wealth = 0;
                    
                    // Trigger aggressive cleanup after nest death
                    if (typeof sim !== 'undefined' && sim._cleanupAfterLargeDieOff) {
                        sim._cleanupAfterLargeDieOff();
                    }
                    
                    // VFX & SFX - NEST DEATH SOUND
                    sim.particles.push(new Particle(this.pos.x, this.pos.y, '#dc2626', 'explosion'));
                    sim.particles.push(new Particle(this.pos.x, this.pos.y, '#9ca3af', 'smoke'));
                    sfx.play('death', HARMONICS.A3, 0.25); // Lower, more dramatic nest death sound (harmonic A3)
                } 
                
                // Siege cooldown
                if (this.siegeCooldown > 0) this.siegeCooldown--;
                
                // SIEGE WEAPONS - Attack enemy nests during war
                if (this.siegeCooldown <= 0 && typeof sim !== 'undefined' && sim.tribes) {
                    let tribe = sim.tribes.tribes[this.tribeId];
                    if (!tribe) return;
                    
                    // Find enemy nests (at war)
                    let enemyNests = sim.tribes.nests.filter(n => {
                        if (n.tribeId === this.tribeId) return false;
                        return tribe.atWarWith[n.tribeId] === true;
                    });
                    
                    if (enemyNests.length > 0 && Math.random() < 0.3) { // 30% chance to fire
                        // Find closest enemy nest in range (using toroidal distance)
                        let targets = enemyNests.filter(n => 
                            Vector.distTorus(this.pos, n.pos, sim.width, sim.height) < CONFIG.siegeWeaponRange
                        );
                        
                        if (targets.length > 0) {
                            let target = targets.sort((a, b) => 
                                Vector.distTorus(this.pos, a.pos, sim.width, sim.height) - Vector.distTorus(this.pos, b.pos, sim.width, sim.height)
                            )[0];
                            
                            // Fire siege projectile
                            let projectile = new Projectile(
                                this.pos.x, this.pos.y,
                                target.pos.x, target.pos.y,
                                { id: 'nest_' + this.tribeId, tribeId: this.tribeId },
                                CONFIG.siegeWeaponDamage,
                                'siege'
                            );
                            sim.projectiles.push(projectile);
                            
                            this.siegeCooldown = CONFIG.siegeWeaponCooldown;
                            
                            // VFX & SFX
                            sim.particles.push(new Particle(this.pos.x, this.pos.y, '#f59e0b', 'lightning'));
                            sfx.play('attack', 200, 0.15);
                        }
                    }
                } 
                
                // Nest drift based on tribal relations, diplomatic and commercial bonds
                if (typeof sim !== 'undefined' && sim.tribes) {
                    let targetDrift = this.computeDriftForce();
                    let smoothing = Math.max(0.01, CONFIG.nestDriftSmoothing || 0.05);
                    let driftDelta = Vector.sub(targetDrift, this.driftMomentum).mult(smoothing);
                    this.driftMomentum.add(driftDelta);

                    let driftForce = this.driftMomentum.copy();

                    if (driftForce.mag() < 0.5) {
                        let randomDrift = new Vector(
                            (Math.random() - 0.5) * CONFIG.nestBaseDriftRate * 0.5,
                            (Math.random() - 0.5) * CONFIG.nestBaseDriftRate * 0.5
                        );
                        this.driftMomentum.add(randomDrift);
                        driftForce.add(randomDrift);
                    }

                    if (driftForce.mag() > 0.001) {
                        // Massively slow down nest motion (multiply by 0.005 = 99.5% reduction)
                        driftForce.mult(0.005);
                        // Apply drift and wrap position directly using Vector method
                        this.pos.add(driftForce);
                        this.pos.wrap(sim.width, sim.height);
                        
                        let newX = this.pos.x;
                        let newY = this.pos.y;
                        
                        // NEST COLLISION DETECTION AND BOUNCING
                        let minDist = this.radius + 20; // Minimum separation distance
                        let collisionForce = new Vector(0, 0);
                        let collisionCount = 0;
                        
                        for (let otherNest of sim.tribes.nests) {
                            if (otherNest === this) continue;
                            
                            // Use toroidal distance for collision detection
                            let dx = otherNest.pos.x - newX;
                            let dy = otherNest.pos.y - newY;
                            
                            // Wrap to shortest path
                            if (dx > sim.width / 2) dx -= sim.width;
                            else if (dx < -sim.width / 2) dx += sim.width;
                            if (dy > sim.height / 2) dy -= sim.height;
                            else if (dy < -sim.height / 2) dy += sim.height;
                            
                            let d = Math.sqrt(dx * dx + dy * dy);
                            let minSeparation = this.radius + otherNest.radius + minDist;
                            
                            if (d < minSeparation && d > 0.001) {
                                // Collision detected - apply bounce force
                                let overlap = minSeparation - d;
                                let bounceDir = new Vector(-dx, -dy);
                                bounceDir.normalize();
                                
                                // Bounce strength proportional to overlap and relative velocity
                                let bounceStrength = overlap * 0.15; // Bounce coefficient
                                collisionForce.add(bounceDir.mult(bounceStrength));
                                collisionCount++;
                                
                                // Also apply opposite force to other nest
                                let otherBounceDir = new Vector(dx, dy);
                                otherBounceDir.normalize();
                                otherNest.driftMomentum.add(otherBounceDir.mult(bounceStrength * 0.5));
                            }
                        }
                        
                        // Apply collision forces
                        if (collisionCount > 0) {
                            collisionForce.div(collisionCount);
                            this.driftMomentum.add(collisionForce);
                            // Dampen momentum after collision
                            this.driftMomentum.mult(0.85);
                            
                            // Recalculate position with bounce and wrap
                            this.pos.add(this.driftMomentum);
                            this.pos.wrap(sim.width, sim.height);
                            
                            newX = this.pos.x;
                            newY = this.pos.y;
                        }
                    }
                    }
                }
                this.updateTools(sim);
                this.attemptSpawnTool(sim);
            }
            computeDriftForce() {
                    let driftForce = new Vector(0, 0);
                if (typeof sim === 'undefined' || !sim.tribes) return driftForce;
                    let tribe = sim.tribes.tribes[this.tribeId];
                if (!tribe) return driftForce;
                let contributionCount = 0;
                    
                    let totalBonds = 0;
                    for (let otherId in tribe.diplomaticBonds) totalBonds += tribe.diplomaticBonds[otherId];
                    for (let otherId in tribe.commercialBonds) totalBonds += tribe.commercialBonds[otherId];
                    
                let isAffiliated = totalBonds > 10;
                    
                    if (!isAffiliated && CONFIG.nestUnaffiliatedDriftRate > 0) {
                    let nestGroups = {};
                        for (let nest of sim.tribes.nests) {
                            if (!nestGroups[nest.tribeId]) nestGroups[nest.tribeId] = [];
                            nestGroups[nest.tribeId].push(nest);
                        }
                        
                        let largestGroupId = null;
                        let largestSize = 0;
                        for (let tribeId in nestGroups) {
                            if (nestGroups[tribeId].length > largestSize && Number(tribeId) !== this.tribeId) {
                                largestGroupId = Number(tribeId);
                                largestSize = nestGroups[tribeId].length;
                            }
                        }
                        
                        if (largestGroupId !== null) {
                            let centerX = 0, centerY = 0;
                            for (let nest of nestGroups[largestGroupId]) {
                                centerX += nest.pos.x;
                                centerY += nest.pos.y;
                            }
                            centerX /= largestSize;
                            centerY /= largestSize;
                            
                            let toCenter = new Vector(centerX - this.pos.x, centerY - this.pos.y);
                            toCenter.normalize();
                            toCenter.mult(CONFIG.nestUnaffiliatedDriftRate);
                            driftForce.add(toCenter);
                        contributionCount++;
                        }
                    }
                    
                    for (let otherNest of sim.tribes.nests) {
                        if (otherNest === this || otherNest.tribeId === this.tribeId) continue;
                        
                    // Calculate direction FROM this nest TO other nest (for attraction)
                    let direction = Vector.subTorus(otherNest.pos, this.pos, sim.width, sim.height);
                        let distance = direction.mag();
                        
                    if (distance < 1) continue;
                        
                    // Normalize direction - points TOWARDS other nest
                        direction.normalize();
                        
                    let dipBond = sim.tribes.tribes[this.tribeId].diplomaticBonds[otherNest.tribeId] || 0;
                    let comBond = sim.tribes.tribes[this.tribeId].commercialBonds[otherNest.tribeId] || 0;
                    // Lower threshold to detect bonds earlier (was 20)
                    let hasBond = dipBond > 10 || comBond > 10;
                    let isEnemy = tribe.atWarWith && tribe.atWarWith[otherNest.tribeId];
                    let relation = sim.tribes.getOpinion(this.tribeId, otherNest.tribeId);

                    let strength = 0;
                    
                    // BONDED NESTS: Only attraction, never repulsion
                    if (hasBond) {
                        // PULL TOWARDS EACH OTHER - Bond attraction overrides enemy repulsion
                        let bondStrength = 0;
                        if (dipBond > 10) {
                            // Use bond value directly (0-100) scaled by multiplier - moderate attraction
                            bondStrength += (dipBond / 100) * CONFIG.nestDiplomaticDriftMultiplier * 2.0;
                        }
                        if (comBond > 10) {
                            // Use bond value directly (0-100) scaled by multiplier - moderate attraction
                            bondStrength += (comBond / 100) * CONFIG.nestCommercialDriftMultiplier * 2.0;
                        }
                        
                        // Base attraction strength - moderate to avoid fast motion
                        strength = bondStrength * CONFIG.nestBaseDriftRate * 1.5;
                        
                        // If also enemies, reduce attraction slightly but keep it positive (bonds win)
                        if (isEnemy) {
                            strength *= 0.7; // Reduce attraction by 30% if enemies, but still attract
                        }
                        
                        // Ensure minimum attraction even for weak bonds (but not too strong)
                        if (strength < CONFIG.nestBaseDriftRate * 1.0) {
                            strength = CONFIG.nestBaseDriftRate * 1.0;
                        }
                        
                        // Distance factor - stronger pull when closer (but still pull when far)
                        let distanceFactor = 1.0;
                            if (distance < 300) {
                            distanceFactor = 2.0; // Strong pull when close
                            } else if (distance < 600) {
                            distanceFactor = 1.5;
                            } else if (distance < 900) {
                            distanceFactor = 1.2;
                            } else {
                            distanceFactor = 1.0; // Still pull when far
                            }
                        strength *= distanceFactor;
                        
                        // Ensure strength is always positive (attraction only) when bonds exist
                        // NO REPULSION - bonded nests only attract, never repel
                        strength = Math.max(0, strength); // Force positive (attraction only)
                        
                        // Direction already points TOWARDS the other nest (from subTorus calculation)
                        // Positive strength with this direction = attraction (moving towards each other)
                    } else {
                        // UNBONDED NESTS: Gentle attraction and repulsion based on distance
                        // Close range: gentle repulsion (avoid crowding)
                        // Medium range: gentle attraction (form loose groups)
                        // Far range: very gentle attraction (tendency to cluster)
                        
                        let attractionStrength = 0;
                        let repulsionStrength = 0;
                        
                        // Gentle attraction - stronger at medium distances
                        if (distance > 200 && distance < 800) {
                            // Medium distance: gentle attraction
                            attractionStrength = CONFIG.nestBaseDriftRate * 0.4;
                        } else if (distance >= 800) {
                            // Far distance: very gentle attraction
                            attractionStrength = CONFIG.nestBaseDriftRate * 0.2;
                        }
                        
                        // Gentle repulsion - stronger when close
                        if (distance < 300) {
                            // Close distance: gentle repulsion to avoid crowding
                            repulsionStrength = CONFIG.nestBaseDriftRate * 0.6;
                        } else if (distance < 500) {
                            // Medium-close: very gentle repulsion
                            repulsionStrength = CONFIG.nestBaseDriftRate * 0.2;
                    }
                    
                        // Adjust based on relations
                        if (isEnemy) {
                            // Enemies: stronger repulsion, weaker attraction
                            repulsionStrength *= 1.5;
                            attractionStrength *= 0.5;
                        } else if (relation < 0) {
                            // Unfriendly: moderate repulsion, reduced attraction
                            repulsionStrength *= 1.2;
                            attractionStrength *= 0.7;
                        } else if (relation > 0) {
                            // Friendly: stronger attraction, weaker repulsion
                            attractionStrength *= 1.3;
                            repulsionStrength *= 0.8;
                        }
                        
                        // Combine attraction and repulsion
                        // Net force = attraction (towards) - repulsion (away)
                        let netStrength = attractionStrength - repulsionStrength;
                        
                        if (netStrength > 0) {
                            // Net attraction: move TOWARDS other nest
                            // Direction already points towards (from subTorus calculation)
                            strength = netStrength; // Positive = attraction
                            // direction stays as-is (points towards)
                        } else if (netStrength < 0) {
                            // Net repulsion: move AWAY from other nest
                            direction.mult(-1); // Reverse to point away
                            strength = Math.abs(netStrength); // Positive magnitude
                        } else {
                            // Balanced: no movement
                            strength = 0;
                        }
                    }

                    // Apply the force (direction already set correctly above)
                    if (strength > 0) {
                        direction.mult(strength);
                        driftForce.add(direction);
                        contributionCount++;
                    }
                }

                // Average all forces for smooth motion (necessary for smooth movement)
                // Bond forces are made stronger before averaging so they remain effective after averaging
                if (contributionCount > 0) {
                    driftForce.div(contributionCount); // Normal averaging for smooth motion
                }

                return driftForce;
            }
            updateTools(sim) {
                this.tools = this.tools.filter(tool => tool.update(sim));
            }
            attemptSpawnTool(sim) {
                if (typeof sim === 'undefined' || !CONFIG.nestToolConfig) return;
                let config = CONFIG.nestToolConfig;
                if (this.tools.length >= config.maxPerNest) return;
                let currentFrame = sim.frame || 0;
                if (currentFrame - this.lastToolSpawnFrame < config.spawnCooldown) return;
                let tribe = sim.tribes && sim.tribes.tribes[this.tribeId];
                let candidates = Object.entries(config.toolTypes).filter(([type, def]) => this.canSpawnTool(def, tribe));
                if (candidates.length === 0) return;
                if (Math.random() < 0.08) {
                    let [type, def] = candidates[Math.floor(Math.random() * candidates.length)];
                    this.wealth = Math.max(0, this.wealth - def.wealthCost);
                    let tool = new NestTool(type, this, def);
                    this.tools.push(tool);
                    this.lastToolSpawnFrame = currentFrame;
                    if (this.tools.length > config.maxPerNest) {
                        this.tools.shift();
                    }
                            }
                        }
            canSpawnTool(def, tribe) {
                if (this.hp < def.minHp) return false;
                if (this.wealth < def.wealthCost) return false;
                let tier = tribe ? tribe.techTier || 0 : 0;
                if (tier < (def.techTier || 0)) return false;
                return true;
            }
            draw(ctx) {
                let tColor = sim.tribes.tribes[this.tribeId].color;
                
                // Nest radius directly reflects nest health and stats (no random variations)
                // Base size from wealth
                let wealthSize = 20 + (this.wealth / 40);
                // HP-based size (healthier nests are larger)
                let hpRatio = this.hp / this.maxHealth; // 0.0 to 1.0
                let hpSize = 15 + (hpRatio * 25); // Range from 15 to 40 pixels based on HP
                // Defense level adds to size
                let defenseSize = this.defenseLevel * 2;
                
                // Combined size based on health, wealth, and defense (direct reflection, no randomness)
                let size = Math.max(wealthSize, hpSize) + defenseSize;
                this.radius = Math.min(Math.max(15, size), 80); // Clamp between 15 and 80
                
                // Additional wealth rings (concentric circles showing prosperity)
                let wealthRings = Math.min(5, Math.floor(this.wealth / 150));
                for(let i = 0; i < wealthRings; i++) {
                    ctx.strokeStyle = `rgba(251, 191, 36, ${0.3 - i * 0.05})`; // Gold, fading outward
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(this.pos.x, this.pos.y, this.radius + 15 + (i * 12), 0, Math.PI*2);
                    ctx.stroke();
                }

                // Draw Wealth Hoard (more piles, bigger radius)
                let piles = Math.min(15, Math.floor(this.wealth / 40)); // More piles, easier to earn
                for(let i=0; i<piles; i++) {
                    let angle = (i / piles) * Math.PI * 2;
                    let rx = this.pos.x + Math.cos(angle) * (this.radius + 12);
                    let ry = this.pos.y + Math.sin(angle) * (this.radius + 12);
                    ctx.fillStyle = '#fbbf24';
                    ctx.beginPath();
                    ctx.arc(rx, ry, 4, 0, Math.PI*2); // Bigger piles (3->4)
                    ctx.fill();
                    ctx.strokeStyle = '#f59e0b';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }

                // Draw Defense Rings (Thick Gold Rings) - MORE VISIBLE
                for(let i=0; i<this.defenseLevel; i++) {
                    ctx.strokeStyle = '#a16207'; 
                    ctx.lineWidth = 8; // Increased from 6 to 8
                    ctx.beginPath();
                    ctx.arc(this.pos.x, this.pos.y, this.radius + 15 + (i*10), 0, Math.PI*2); // More spacing
                    ctx.stroke();
                }

                ctx.fillStyle = tColor;
                ctx.globalAlpha = 0.3;
                ctx.beginPath();
                ctx.arc(this.pos.x, this.pos.y, this.radius + 5, 0, Math.PI*2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
                
                ctx.fillStyle = '#1f2937';
                ctx.strokeStyle = tColor;
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.arc(this.pos.x, this.pos.y, this.radius, 0, Math.PI*2);
                ctx.fill();
                ctx.stroke();

                ctx.fillStyle = '#fff';
                ctx.font = "10px monospace";
                ctx.textAlign = "center";
                ctx.fillText(`HP: ${Math.floor(this.hp)}`, this.pos.x, this.pos.y + this.radius + 15);
                ctx.fillText(`DEF: ${this.defenseLevel}`, this.pos.x, this.pos.y + this.radius + 25);
                this.tools.forEach(tool => tool.draw(ctx));
            }
        }

        class NestTool {
            constructor(type, nest, def) {
                this.type = type;
                this.nest = nest;
                this.definition = def;
                this.angle = Math.random() * Math.PI * 2;
                this.orbitRadius = nest.radius + 25 + Math.random() * 30;
                this.angularSpeed = 0.01 + Math.random() * 0.02;
                this.health = CONFIG.nestToolConfig && CONFIG.nestToolConfig.toolLifetime ? CONFIG.nestToolConfig.toolLifetime : 1200;
                this.effectTimer = 0;
                this.active = true;
                this.isNestTool = true;
            }
            getPosition() {
                let tether = new Vector(Math.cos(this.angle) * this.orbitRadius, Math.sin(this.angle) * this.orbitRadius);
                return new Vector(this.nest.pos.x + tether.x, this.nest.pos.y + tether.y);
            }
            getResourceNeedDirection(sim) {
                if (!sim) return Vector.random2D();
                let nest = this.nest;
                let tribe = sim.tribes && sim.tribes.tribes[nest.tribeId];
                let needs = (tribe && tribe.resourceNeeds) ? tribe.resourceNeeds : {};
                const priority = { FOOD: 3.5, SEED: 2.7, HERB: 2.6, MAT: 2.4, ORE: 2.2, TREASURE: 1.8, UNIQUE: 1.6, STIM: 1.2 };
                let best = null;
                let bestScore = -Infinity;
                for (let r of sim.resources) {
                    if (!r.active) continue;
                    let dist = Vector.dist(nest.pos, r.pos);
                    if (dist < 1) dist = 1;
                    let weight = priority[r.type] || 1.0;
                    let needBonus = needs[r.type] || 0;
                    let score = weight + needBonus - dist * 0.003;
                    if (score > bestScore) {
                        bestScore = score;
                        best = r;
                    }
                }
                if (!best) return Vector.random2D();
                return Vector.sub(best.pos, nest.pos).normalize();
            }
            update(sim) {
                this.angle += this.angularSpeed;
                this.effectTimer++;
                this.health -= 1;
                if (this.health <= 0) return false;
                switch (this.type) {
                    case 'propulsion':
                        this.applyPropulsion(sim);
                        break;
                    case 'foodGrabber':
                        this.applyFoodGrabber(sim);
                        break;
                    case 'resourceGrabber':
                        this.applyResourceGrabber(sim);
                        break;
                    case 'venom':
                        this.applyVenom(sim);
                        break;
                    case 'nestGrabber':
                        this.applyNestGrabber(sim);
                        break;
                    case 'nestRepeller':
                        this.applyNestRepeller(sim);
                        break;
                    case 'spawner':
                        this.applySpawner(sim);
                        break;
                    default:
                        break;
                }
                return true;
            }
            applyPropulsion(sim) {
                if (!sim || sim.frame % 35 !== 0) return;
                let dir = this.getResourceNeedDirection(sim);
                if (dir.mag() === 0) dir = Vector.random2D();
                let strength = 0.35 + (this.definition.pullStrength || 0) * 0.1;
                let push = dir.copy().mult(strength);
                this.nest.driftMomentum.add(push);
            }
            applyFoodGrabber(sim) {
                if (!sim || sim.frame % 30 !== 0) return;
                let range = CONFIG.nestToolConfig.resourceHarvestRange || 140;
                let candidate = sim.resources.find(r => {
                    if (!r.active || r.carrier) return false;
                    if (r.creatorTribe === this.nest.tribeId) return true;
                    return ['FOOD', 'HERB', 'SEED'].includes(r.type);
                });
                if (candidate && Vector.dist(candidate.pos, this.getPosition()) < range) {
                    candidate.active = false;
                    this.nest.wealth += candidate.type === 'HERB' ? 6 : 4;
                    sim.particles.push(new Particle(candidate.pos.x, candidate.pos.y, '#84cc16', 'spark'));
                }
            }
            applyResourceGrabber(sim) {
                if (!sim || sim.frame % 45 !== 0) return;
                let range = CONFIG.nestToolConfig.resourceHarvestRange || 150;
                let candidate = sim.resources.find(r => {
                    if (!r.active || r.carrier) return false;
                    return ['MAT', 'ORE', 'TREASURE'].includes(r.type);
                });
                if (candidate && Vector.dist(candidate.pos, this.getPosition()) < range) {
                    candidate.active = false;
                    this.nest.wealth += candidate.type === 'TREASURE' ? 10 : 5;
                    sim.particles.push(new Particle(candidate.pos.x, candidate.pos.y, '#f97316', 'spark'));
                }
            }
            applyVenom(sim) {
                if (!sim || sim.frame % 20 !== 0) return;
                let range = CONFIG.nestToolConfig.tetherRange || 200;
                for (let agent of sim.agents) {
                    if (!agent || agent.dead || agent.tribeId === this.nest.tribeId) continue;
                    if (Vector.dist(agent.pos, this.nest.pos) > range) continue;
                    agent.health -= this.definition.damageOutput || 3;
                    agent.health = Math.max(0, agent.health);
                    if (agent.health <= 0) {
                        agent.dead = true;
                        sim.particles.push(new Particle(agent.pos.x, agent.pos.y, '#dc2626', 'blood'));
                    }
                }
            }
            applyNestGrabber(sim) {
                if (!sim || sim.frame % 25 !== 0) return;
                let range = CONFIG.nestToolConfig ? CONFIG.nestToolConfig.tetherRange : 220;
                let defenders = sim.tribes.nests.filter(n => n !== this.nest && Vector.dist(n.pos, this.nest.pos) < range && n.tribeId !== this.nest.tribeId);
                if (defenders.length === 0) return;
                let target = defenders.sort((a, b) => Vector.dist(a.pos, this.nest.pos) - Vector.dist(b.pos, this.nest.pos))[0];
                let pullDir = Vector.sub(this.nest.pos, target.pos).normalize().mult((this.definition.pullStrength || 0.6) + 0.2);
                let resourceDir = this.getResourceNeedDirection(sim).mult(0.25);
                target.driftMomentum.add(pullDir.add(resourceDir));
            }
            applyNestRepeller(sim) {
                if (!sim || sim.frame % 25 !== 0) return;
                let range = CONFIG.nestToolConfig ? CONFIG.nestToolConfig.tetherRange : 220;
                let threats = sim.tribes.nests.filter(n => n !== this.nest && Vector.dist(n.pos, this.nest.pos) < range && n.tribeId !== this.nest.tribeId);
                if (threats.length === 0) return;
                for (let target of threats) {
                    let pushDir = Vector.sub(target.pos, this.nest.pos).normalize().mult(this.definition.pushStrength || 0.8);
                    target.driftMomentum.add(pushDir);
                }
            }
            applySpawner(sim) {
                if (!sim || sim.frame % (this.definition.cooldown || 40) !== 0) return;
                let spawnType = this.definition.spawnOptions[Math.floor(Math.random() * this.definition.spawnOptions.length)];
                let agent = sim.spawnAgent(spawnType, this.nest);
                if (agent) {
                    sim.particles.push(new Particle(agent.pos.x, agent.pos.y, '#f87171', 'spark'));
                }
            }
            draw(ctx) {
                let pos = this.getPosition();
                ctx.save();
                ctx.translate(pos.x, pos.y);
                let color = '#38bdf8';
                switch (this.type) {
                    case 'propulsion':
                        color = '#22d3ee';
                        break;
                    case 'foodGrabber':
                        color = '#bef264';
                        break;
                    case 'resourceGrabber':
                        color = '#facc15';
                        break;
                    case 'venom':
                        color = '#ef4444';
                        break;
                }
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(0, 0, 6, 0, Math.PI * 2);
                ctx.stroke();
                ctx.fillStyle = color;
                ctx.globalAlpha = 0.5;
                ctx.fill();
                ctx.globalAlpha = 1.0;
                ctx.restore();
            }
        }

        /* --- GLOBAL TRIBE MANAGER --- */
        class TribeManager {
            constructor() {
                this.tribes = {};
                this.nextId = 0;
                this.nests = [];
                this.createDefaultTribes(CONFIG.tribeCount);
            }

            // Find a valid position for a nest that's not too close to other nests
            findValidNestPosition(preferredX, preferredY, minDistance = 200) {
                let maxAttempts = 50;
                let bestX = preferredX;
                let bestY = preferredY;
                let bestMinDist = 0;
                
                for (let attempt = 0; attempt < maxAttempts; attempt++) {
                    let x = preferredX + (Math.random() - 0.5) * 200;
                    let y = preferredY + (Math.random() - 0.5) * 200;
                    
                    // Keep within bounds
                    x = Math.max(100, Math.min(window.innerWidth - 100, x));
                    y = Math.max(100, Math.min(window.innerHeight - 100, y));
                    
                    // Check distance to all existing nests
                    let minDistToNest = Infinity;
                    for (let nest of this.nests) {
                        let d = Math.sqrt((x - nest.pos.x)**2 + (y - nest.pos.y)**2);
                        if (d < minDistToNest) minDistToNest = d;
                    }
                    
                    // If far enough, use this position
                    if (minDistToNest >= minDistance) {
                        return { x, y };
                    }
                    
                    // Track best attempt
                    if (minDistToNest > bestMinDist) {
                        bestMinDist = minDistToNest;
                        bestX = x;
                        bestY = y;
                    }
                }
                
                // Return best attempt even if not ideal
                return { x: bestX, y: bestY };
            }

            createDefaultTribes(count) {
                const colors = ['#ef4444', '#3b82f6', '#10b981', '#eab308', '#d946ef'];
                const bases = ['Red', 'Blue', 'Green', 'Gold', 'Void'];
                const suffixes = ['Claw', 'Fin', 'Leaf', 'Spear', 'Walkers'];
                
                for(let i=0; i<count; i++) {
                    let tid = this.createTribe(bases[i%bases.length] + ' ' + suffixes[i%suffixes.length], colors[i%colors.length]);
                    let preferredX = 100 + Math.random() * (window.innerWidth - 200);
                    let preferredY = 100 + Math.random() * (window.innerHeight - 200);
                    let pos = this.findValidNestPosition(preferredX, preferredY);
                    let newNest = new Nest(pos.x, pos.y, tid);
                    this.nests.push(newNest);
                    
                    // NEST BIRTH SOUND - Play birth-like tone when nest is created (SOFTER)
                    if (typeof sfx !== 'undefined' && sfx.enabled) {
                        sfx.play('birth', getHarmonicFreq([HARMONICS.C5, HARMONICS.E5, HARMONICS.G5, HARMONICS.A5], 10), 0.1); // Harmonic birth tone
                        
                        // Start nest heartbeat - each nest has unique frequency based on its ID
                        // DISABLED - not working
                        // const baseFreq = 18 + ((tid % 10) * 1.0); // 18-28 Hz range (very low)
                        // const baseInterval = 35.0 + (Math.random() * 20.0); // 35-55 seconds (extremely slow)
                        // sfx.startNestHeartbeat(newNest.id || `nest_${tid}_${this.nests.length}`, baseFreq, baseInterval);
                    }
                }
            }

            createTribe(name, color) {
                let id = this.nextId++;
                this.tribes[id] = {
                    id: id,
                    name: name || `Clan ${id}`,
                    color: color || `hsl(${Math.random()*360}, 70%, 50%)`,
                    relations: {},
                    diplomaticBonds: {}, // Strength of diplomatic bonds with other tribes (0-100)
                    commercialBonds: {}, // Strength of commercial bonds with other tribes (0-100)
                    wealth: 0,
                    leaderId: null,
                    leaderUnderAttack: false,
                    leaderUnderAttackTargetId: null,
                    leaderUnderAttackTimer: 0,
                    underAttack: false,
                    roles: {},
                    techTier: 0,
                    // TECH TREE SYSTEM
                    techPoints: 0, // Accumulated tech points for advancement
                    techTree: {
                        // Tier 0: Basic survival (always available)
                        survival: { level: 1, maxLevel: 5 }, // Gathering, basic resource use
                        // Tier 1: Early civilization
                        agriculture: { level: 0, maxLevel: 5 }, // Farming, food cultivation
                        construction: { level: 0, maxLevel: 5 }, // Building, nest improvements
                        combat: { level: 0, maxLevel: 5 }, // Basic warfare
                        energy_production: { level: 0, maxLevel: 5 }, // Energy efficiency, reduces energy burn
                        // Tier 2: Advanced civilization
                        manufacturing: { level: 0, maxLevel: 5 }, // Resource transformation
                        medicine: { level: 0, maxLevel: 5 }, // Healing, infant mortality
                        commerce: { level: 0, maxLevel: 5 }, // Trade networks
                        defense: { level: 0, maxLevel: 5 }, // Shields, damage reduction, attack boost
                        resource_manufacturing: { level: 0, maxLevel: 5 }, // Spawn raw materials near nest
                        // Tier 3: High civilization
                        diplomacy: { level: 0, maxLevel: 5 }, // International relations
                        science: { level: 0, maxLevel: 5 }, // Research, innovation
                        education: { level: 0, maxLevel: 5 }, // Knowledge transfer
                        // Tier 4: Advanced
                        warfare: { level: 0, maxLevel: 5 }, // Advanced combat
                        cultivation: { level: 0, maxLevel: 5 } // Prey farming, resource cultivation
                    },
                    // TRIBAL SELF-REGULATION
                    roleNeeds: {}, // Tracks what roles tribe needs more/less of
                    resourceNeeds: {}, // Tracks what resources tribe needs more/less of
                    techDecay: 0.001, // Tech slowly decays if not maintained
                    // WAR SYSTEM
                    atWarWith: {}, // Set of tribe IDs at war with this tribe
                    warExhaustion: {}, // How tired each war makes the tribe (0-100)
                    surrenderThreshold: 80, // War exhaustion level to consider surrender
                    // PROFIT-BASED BOND TRACKING
                    tradeProfit: {}, // Profit from trade with each tribe (rolling window)
                    tradeProfitHistory: {}, // Array of recent profits per tribe
                    diplomaticBenefits: {}, // Benefits from diplomatic bonds (resources shared, defense, etc.)
                    lastTradeTime: {}, // Last time trade happened with each tribe
                    lastDiplomacyTime: {} // Last time diplomacy happened with each tribe
                };
                for(let otherId in this.tribes) {
                    this.tribes[id].relations[otherId] = 0;
                    this.tribes[otherId].relations[id] = 0;
                    this.tribes[id].diplomaticBonds[otherId] = 0;
                    this.tribes[otherId].diplomaticBonds[id] = 0;
                    this.tribes[id].commercialBonds[otherId] = 0;
                    this.tribes[otherId].commercialBonds[id] = 0;
                    this.tribes[id].atWarWith[otherId] = false;
                    this.tribes[otherId].atWarWith[id] = false;
                    this.tribes[id].warExhaustion[otherId] = 0;
                    this.tribes[otherId].warExhaustion[id] = 0;
                    // Initialize profit tracking
                    this.tribes[id].tradeProfit[otherId] = 0;
                    this.tribes[otherId].tradeProfit[id] = 0;
                    this.tribes[id].tradeProfitHistory[otherId] = [];
                    this.tribes[otherId].tradeProfitHistory[id] = [];
                    this.tribes[id].diplomaticBenefits[otherId] = 0;
                    this.tribes[otherId].diplomaticBenefits[id] = 0;
                    this.tribes[id].lastTradeTime[otherId] = 0;
                    this.tribes[otherId].lastTradeTime[id] = 0;
                    this.tribes[id].lastDiplomacyTime[otherId] = 0;
                    this.tribes[otherId].lastDiplomacyTime[id] = 0;
                }
                this.tribes[id].relations[id] = 100;
                return id;
            }

            fractureTribe(oldId, agentsInTribe) {
                this.nests = this.nests.filter(n => n.tribeId !== oldId);
                if (agentsInTribe.length < 2) return; 
                let newId = this.createTribe(`Refugees ${oldId}`, null); 
                let center = agentsInTribe[0].pos;
                let pos = this.findValidNestPosition(center.x, center.y);
                let newNest2 = new Nest(pos.x, pos.y, newId);
                this.nests.push(newNest2);
                
                // Start nest heartbeat for new nest
                // DISABLED - not working
                // if (typeof sfx !== 'undefined' && sfx.enabled) {
                //     const baseFreq = 30 + ((newId % 20) * 1.0); // 30-50 Hz range
                //     const baseInterval = 6.0 + (Math.random() * 2.0); // 6-8 seconds
                //     sfx.startNestHeartbeat(newNest2.id || `nest_${newId}_${this.nests.length}`, baseFreq, baseInterval);
                // }
                
                // NEST BIRTH SOUND - Play birth-like tone when nest is created (tribe split) (SOFTER)
                if (typeof sfx !== 'undefined' && sfx.enabled) {
                    sfx.play('birth', getHarmonicFreq([HARMONICS.C5, HARMONICS.E5, HARMONICS.G5, HARMONICS.A5], 10), 0.1); // Harmonic birth tone
                }
                agentsInTribe.forEach(a => a.tribeId = newId);
            }

            updateRoles(agents) {
                for(let tid in this.tribes) {
                    this.tribes[tid].roles = {};
                }
                agents.forEach(a => {
                    if(a.tribeId !== -1) {
                        if(!this.tribes[a.tribeId].roles[a.role]) this.tribes[a.tribeId].roles[a.role] = 0;
                        this.tribes[a.tribeId].roles[a.role]++;
                    }
                });

                // Clean up dead tribes (0 agents)
                for(let tid in this.tribes) {
                    let count = agents.filter(a => a.tribeId == tid).length;
                    if (count === 0) {
                        this.nests = this.nests.filter(n => n.tribeId != tid);
                    }
                }

                // Calculate Tech Levels
                for(let tid in this.tribes) {
                    let t = this.tribes[tid];
                    t.techTier = 0;
                    if ((t.roles['Builder']||0) > 4 && (t.roles['Guardian']||0) > 4) t.techTier = 1;
                    if (t.techTier >= 1 && (t.roles['Soldier']||0) > 4 && (t.roles['Artisan']||0) > 2) t.techTier = 2;
                    if (t.techTier >= 2 && t.wealth > 5000 && (t.roles['Healer']||0) > 1) t.techTier = 3;
                }
            }

            getDesiredRole(tribeId) {
                let t = this.tribes[tribeId];
                if (!t) return null;
                
                // BASE ROLES (always available - EXPANDED!)
                let allowedRoles = ['Builder', 'Botanist', 'Miner', 'Guardian', 'Garbage Collector'];
                
                // TECH-GATED ROLES based on tech tree levels (LOWERED REQUIREMENTS!)
                if (t.techTree.agriculture.level >= 1) allowedRoles.push('Farmer');
                if (t.techTree.combat.level >= 1) allowedRoles.push('Soldier');
                if (t.techTree.manufacturing.level >= 1) allowedRoles.push('Artisan');
                if (t.techTree.commerce.level >= 1) allowedRoles.push('Merchant');
                if (t.techTree.medicine.level >= 1) allowedRoles.push('Healer');
                if (t.techTree.warfare.level >= 1) allowedRoles.push('Raider');
                if (t.techTree.science.level >= 1) allowedRoles.push('Scientist');
                if (t.techTree.diplomacy.level >= 1) allowedRoles.push('Diplomat');
                if (t.techTree.education.level >= 1) allowedRoles.push('Teacher');
                
                // SCOUT is always available too
                allowedRoles.push('Scout');
                
                // Prioritize roles with lower counts (fill gaps)
                let counts = allowedRoles.map(r => ({ r: r, c: t.roles[r] || 0 }));
                counts.sort((a, b) => a.c - b.c);
                let pick = counts[Math.floor(Math.random() * Math.min(3, counts.length))];
                return pick ? pick.r : null;
            }

            getOpinion(fromTribe, toTribe) {
                if (!this.tribes[fromTribe] || !this.tribes[toTribe]) return 0;
                return this.tribes[fromTribe].relations[toTribe];
            }
            
            // Tech tree progression - accumulate points and level up techs
            progressTech(tribeId, activity, points = 1) {
                let tribe = this.tribes[tribeId];
                if (!tribe) return;
                
                // Apply researchSpeed multiplier to tech point generation
                let effectivePoints = points * (CONFIG.researchSpeed || 1.0);
                // Boost tech point generation significantly - tribes need to progress faster
                effectivePoints *= 2.5; // 2.5x multiplier to help tribes advance tech faster
                tribe.techPoints += effectivePoints;
                
                // Level up specific tech based on activity
                if (tribe.techTree[activity]) {
                    let tech = tribe.techTree[activity];
                    if (tech.level < tech.maxLevel) {
                        // Reduced upgrade cost - tech advances faster
                        let costToUpgrade = (tech.level + 1) * 60; // Reduced from 100 to 60
                        if (tribe.techPoints >= costToUpgrade) {
                            tribe.techPoints -= costToUpgrade;
                            tech.level++;
                        }
                    }
                }
            }
            
            // Get tech bonuses for a tribe
            getTechBonus(tribeId, techType) {
                let tribe = this.tribes[tribeId];
                if (!tribe || !tribe.techTree[techType]) return 1.0;
                
                // Each level provides 10% bonus (multiplicative)
                return 1.0 + (tribe.techTree[techType].level * 0.1);
            }
            
            // Get energy efficiency multiplier (LOWER is better - reduces energy burn)
            getEnergyEfficiency(tribeId) {
                let tribe = this.tribes[tribeId];
                if (!tribe) return 1.0;
                
                // Each level reduces energy burn by 10%
                let level = tribe.techTree.energy_production.level;
                return Math.max(0.5, 1.0 - (level * 0.1)); // Max 50% reduction at level 5
            }
            
            // Get defense bonus (damage reduction)
            getDefenseBonus(tribeId) {
                let tribe = this.tribes[tribeId];
                if (!tribe) return 0;
                
                // Each level provides 5% damage reduction (max 25% at level 5)
                return tribe.techTree.defense.level * 0.05;
            }
            
            // Get attack damage multiplier
            getAttackBonus(tribeId) {
                let tribe = this.tribes[tribeId];
                if (!tribe) return 1.0;
                
                // Each level increases damage by 15%
                return 1.0 + (tribe.techTree.defense.level * 0.15);
            }
            
            // Tech decay ONLY happens in crisis conditions (not random!)
            decayTech(tribeId) {
                let tribe = this.tribes[tribeId];
                if (!tribe) return;
                
                // Get tribe members to assess health
                let nest = this.nests.find(n => n.tribeId == tribeId);
                if (!nest) return;
                
                // CRISIS CONDITIONS for tech decay:
                // 1. Very low wealth (< 100) = tribe can't support specialists
                // 2. Very low nest health (< 200) = infrastructure failing
                // 3. Very few members (< 3) = knowledge loss
                
                let members = typeof sim !== 'undefined' ? sim.agents.filter(a => a.tribeId == tribeId && !a.dead) : [];
                let isInCrisis = (nest.wealth < 100) || (nest.hp < 200) || (members.length < 3);
                
                if (!isInCrisis) return; // NO DECAY if tribe is healthy!
                
                // Only decay in crisis, and only slowly
                for (let techType in tribe.techTree) {
                    let tech = tribe.techTree[techType];
                    if (tech.level > 0 && Math.random() < 0.01) { // 1% chance (was 0.1%)
                        tech.level = Math.max(0, tech.level - 0.05); // Lose 0.05 level (was 0.1)
                    }
                }
            }
            
            // WAR SYSTEM
            declareWar(tribe1Id, tribe2Id) {
                let t1 = this.tribes[tribe1Id];
                let t2 = this.tribes[tribe2Id];
                if (!t1 || !t2) return;
                
                t1.atWarWith[tribe2Id] = true;
                t2.atWarWith[tribe1Id] = true;
                
                // Update HUD status message
                if (typeof sim !== 'undefined') {
                    sim.setStatusMessage(`‚öîÔ∏è WAR DECLARED: Tribe ${tribe1Id} vs Tribe ${tribe2Id}`, 300); // Show for 300 frames (~5 seconds)
                }
                
                // WAR START SOUND - Play ominous low tone when war begins
                if (typeof sfx !== 'undefined' && sfx.enabled) {
                    sfx.play('death', HARMONICS.E4, 0.2); // Low, ominous war declaration sound (harmonic E4)
                }
                
                // Break diplomatic and commercial bonds between the two warring parties
                t1.diplomaticBonds[tribe2Id] = 0;
                t2.diplomaticBonds[tribe1Id] = 0;
                t1.commercialBonds[tribe2Id] = 0;
                t2.commercialBonds[tribe1Id] = 0;
                
                // WAR BOND BREAKING: Break bonds with each other's bonded parties
                // Also handle shared bonded parties with random assignment
                
                // Get all tribes that have bonds with either warring party
                let t1BondedParties = new Set();
                let t2BondedParties = new Set();
                
                // Collect t1's bonded parties (diplomatic or commercial bonds > 10)
                for (let otherId in this.tribes) {
                    if (otherId == tribe1Id || otherId == tribe2Id) continue;
                    let dipBond = t1.diplomaticBonds[otherId] || 0;
                    let comBond = t1.commercialBonds[otherId] || 0;
                    if (dipBond > 10 || comBond > 10) {
                        t1BondedParties.add(otherId);
                    }
                }
                
                // Collect t2's bonded parties (diplomatic or commercial bonds > 10)
                for (let otherId in this.tribes) {
                    if (otherId == tribe1Id || otherId == tribe2Id) continue;
                    let dipBond = t2.diplomaticBonds[otherId] || 0;
                    let comBond = t2.commercialBonds[otherId] || 0;
                    if (dipBond > 10 || comBond > 10) {
                        t2BondedParties.add(otherId);
                    }
                }
                
                // Find shared bonded parties (both have bonds with the same third party)
                let sharedParties = [];
                for (let partyId of t1BondedParties) {
                    if (t2BondedParties.has(partyId)) {
                        sharedParties.push(partyId);
                    }
                }
                
                // Handle shared bonded parties: Random assignment (each party keeps bonds with some, loses with others)
                for (let sharedId of sharedParties) {
                    // Random: 50% chance t1 keeps the bond, 50% chance t2 keeps it
                    if (Math.random() < 0.5) {
                        // t1 keeps the bond, t2 loses it
                        t2.diplomaticBonds[sharedId] = 0;
                        t2.commercialBonds[sharedId] = 0;
                        if (this.tribes[sharedId]) {
                            this.tribes[sharedId].diplomaticBonds[tribe2Id] = 0;
                            this.tribes[sharedId].commercialBonds[tribe2Id] = 0;
                        }
                    } else {
                        // t2 keeps the bond, t1 loses it
                        t1.diplomaticBonds[sharedId] = 0;
                        t1.commercialBonds[sharedId] = 0;
                        if (this.tribes[sharedId]) {
                            this.tribes[sharedId].diplomaticBonds[tribe1Id] = 0;
                            this.tribes[sharedId].commercialBonds[tribe1Id] = 0;
                        }
                    }
                }
                
                // Break t1's bonds with t2's bonded parties (excluding shared parties already handled)
                for (let t2PartyId of t2BondedParties) {
                    if (!sharedParties.includes(t2PartyId)) {
                        // Break bonds between t1 and t2's bonded party
                        t1.diplomaticBonds[t2PartyId] = 0;
                        const prevBond1 = t1.commercialBonds[t2PartyId] || 0;
                        const prevBond2 = t1.diplomaticBonds[t2PartyId] || 0;
                        t1.commercialBonds[t2PartyId] = 0;
                        t1.diplomaticBonds[t2PartyId] = 0;
                        if (this.tribes[t2PartyId]) {
                            const prevBond3 = this.tribes[t2PartyId].diplomaticBonds[tribe1Id] || 0;
                            const prevBond4 = this.tribes[t2PartyId].commercialBonds[tribe1Id] || 0;
                            this.tribes[t2PartyId].diplomaticBonds[tribe1Id] = 0;
                            this.tribes[t2PartyId].commercialBonds[tribe1Id] = 0;
                            // Reduce relations when bonds are broken due to war
                            this.updateOpinion(tribe1Id, t2PartyId, -10);
                            this.updateOpinion(t2PartyId, tribe1Id, -10);
                            
                            // Play bond breaking sounds if bonds were stable
                            if (typeof sfx !== 'undefined' && sfx.enabled) {
                                if (prevBond1 >= 30) sfx.play('link_broken', HARMONICS.C5, 0.1);
                                if (prevBond2 >= 30) sfx.play('link_broken', HARMONICS.A4, 0.1);
                                if (prevBond3 >= 30) sfx.play('link_broken', HARMONICS.A4, 0.1);
                                if (prevBond4 >= 30) sfx.play('link_broken', HARMONICS.C5, 0.1);
                            }
                        }
                    }
                }
                
                // Break t2's bonds with t1's bonded parties (excluding shared parties already handled)
                for (let t1PartyId of t1BondedParties) {
                    if (!sharedParties.includes(t1PartyId)) {
                        // Break bonds between t2 and t1's bonded party
                        t2.diplomaticBonds[t1PartyId] = 0;
                        t2.commercialBonds[t1PartyId] = 0;
                        if (this.tribes[t1PartyId]) {
                            this.tribes[t1PartyId].diplomaticBonds[tribe2Id] = 0;
                            this.tribes[t1PartyId].commercialBonds[tribe2Id] = 0;
                            // Reduce relations when bonds are broken due to war
                            this.updateOpinion(tribe2Id, t1PartyId, -10);
                            this.updateOpinion(t1PartyId, tribe2Id, -10);
                        }
                    }
                }
                
                // Relations plummet between the two warring parties
                t1.relations[tribe2Id] = Math.min(-80, t1.relations[tribe2Id] - 50);
                t2.relations[tribe1Id] = Math.min(-80, t2.relations[tribe1Id] - 50);
            }
            
            endWar(tribe1Id, tribe2Id, peaceTreaty = false) {
                let t1 = this.tribes[tribe1Id];
                let t2 = this.tribes[tribe2Id];
                if (!t1 || !t2) return;
                
                t1.atWarWith[tribe2Id] = false;
                t2.atWarWith[tribe1Id] = false;
                
                // PERFORMANCE: Clean up war-related data structures
                // Clear any war-related cached data that might be accumulating
                if (t1.leaderUnderAttack && t1.leaderUnderAttackTargetId) {
                    // Reset leader attack state after war
                    t1.leaderUnderAttack = false;
                    t1.leaderUnderAttackTargetId = null;
                }
                if (t2.leaderUnderAttack && t2.leaderUnderAttackTargetId) {
                    t2.leaderUnderAttack = false;
                    t2.leaderUnderAttackTargetId = null;
                }
                
                // PERFORMANCE: Cleanup after war ends to recover performance
                if (typeof sim !== 'undefined' && sim._cleanupAfterWar) {
                    sim._cleanupAfterWar();
                }
                t1.warExhaustion[tribe2Id] = 0;
                t2.warExhaustion[tribe1Id] = 0;
                
                // Update HUD status message
                if (typeof sim !== 'undefined') {
                    sim.setStatusMessage(`üïäÔ∏è WAR ENDED: Tribe ${tribe1Id} and Tribe ${tribe2Id} made peace`, 300); // Show for 300 frames
                }
                
                // WAR END SOUND - Play peaceful ascending tone when war ends
                if (typeof sfx !== 'undefined' && sfx.enabled) {
                    if (peaceTreaty) {
                        // Peace treaty: harmonious tones
                        sfx.play('bond', 440, 0.15); // A note
                        setTimeout(() => {
                            if (typeof sfx !== 'undefined' && sfx.enabled) {
                                sfx.play('bond', 554, 0.12); // C# note (harmony)
                            }
                        }, 100);
                    } else {
                        // Simple war end
                        sfx.play('bond', 330, 0.12); // Lower peaceful tone
                    }
                }
                
                if (peaceTreaty) {
                    // Peace treaty: relations improve, diplomatic bonds start
                    t1.relations[tribe2Id] = Math.max(-20, t1.relations[tribe2Id] + 30);
                    t2.relations[tribe1Id] = Math.max(-20, t2.relations[tribe1Id] + 30);
                    t1.diplomaticBonds[tribe2Id] = 20;
                    t2.diplomaticBonds[tribe1Id] = 20;
                }
            }
            
            isAtWar(tribe1Id, tribe2Id) {
                let t1 = this.tribes[tribe1Id];
                if (!t1) return false;
                return t1.atWarWith[tribe2Id] === true;
            }
            
            // PROFIT-BASED BOND SYSTEM - Bonds persist as long as they're mutually beneficial!
            updateBonds(tribeId) {
                let tribe = this.tribes[tribeId];
                if (!tribe) return;
                
                let currentFrame = typeof sim !== 'undefined' ? sim.frame : 0;
                
                for (let otherId in this.tribes) {
                    if (otherId == tribeId) continue;
                    
                    // Skip if at war - war breaks all bonds immediately
                    if (tribe.atWarWith[otherId]) {
                        tribe.diplomaticBonds[otherId] = 0;
                        tribe.commercialBonds[otherId] = 0;
                        continue;
                    }
                    
                    // MUTUALLY REINFORCING: Strong commercial bonds strengthen diplomatic bonds
                    let comBond = tribe.commercialBonds[otherId] || 0;
                    let dipBond = tribe.diplomaticBonds[otherId] || 0;
                    
                    // Track previous values to detect threshold crossings
                    const prevDipBond = dipBond;
                    const prevComBond = comBond;
                    const STABLE_BOND_THRESHOLD = 30; // Bonds are considered "stable" above this
                    
                    if (comBond > 50 && dipBond < comBond) {
                        // Strong trade creates diplomatic ties
                        tribe.diplomaticBonds[otherId] = Math.min(100, dipBond + 0.2); // Faster growth
                    }
                    
                    if (dipBond > 50 && comBond < dipBond) {
                        // Strong diplomacy encourages trade
                        tribe.commercialBonds[otherId] = Math.min(100, comBond + 0.2); // Faster growth
                    }
                    
                    // MUTUALLY REINFORCING (strong bonds automatically maintain)
                    if (comBond > CONFIG.bondReinforcementThreshold && dipBond > CONFIG.bondReinforcementThreshold) {
                        // Both bonds strong - they reinforce each other (GROW instead of decay!)
                        tribe.diplomaticBonds[otherId] = Math.min(100, dipBond + 0.1);
                        tribe.commercialBonds[otherId] = Math.min(100, comBond + 0.1);
                    }
                    
                    // Check if bonds crossed stable threshold (formed)
                    const newDipBond = tribe.diplomaticBonds[otherId] || 0;
                    const newComBond = tribe.commercialBonds[otherId] || 0;
                    
                    if (prevDipBond < STABLE_BOND_THRESHOLD && newDipBond >= STABLE_BOND_THRESHOLD) {
                        // Diplomatic bond just became stable - play sound
                        if (typeof sfx !== 'undefined' && sfx.enabled) {
                            sfx.play('link_formed', HARMONICS.A4, 0.12);
                        }
                    }
                    if (prevComBond < STABLE_BOND_THRESHOLD && newComBond >= STABLE_BOND_THRESHOLD) {
                        // Commercial bond just became stable - play sound
                        if (typeof sfx !== 'undefined' && sfx.enabled) {
                            sfx.play('link_formed', HARMONICS.C5, 0.12);
                        }
                    }
                    
                    // Check if bonds dropped below stable threshold (broken)
                    if (prevDipBond >= STABLE_BOND_THRESHOLD && newDipBond < STABLE_BOND_THRESHOLD && newDipBond > 0) {
                        // Diplomatic bond just broke - play sound
                        if (typeof sfx !== 'undefined' && sfx.enabled) {
                            sfx.play('link_broken', HARMONICS.A4, 0.1);
                        }
                    }
                    if (prevComBond >= STABLE_BOND_THRESHOLD && newComBond < STABLE_BOND_THRESHOLD && newComBond > 0) {
                        // Commercial bond just broke - play sound
                        if (typeof sfx !== 'undefined' && sfx.enabled) {
                            sfx.play('link_broken', HARMONICS.C5, 0.1);
                        }
                    }
                    
                    // ============================================
                    // COMMERCIAL BONDS: Decay ONLY if UNPROFITABLE
                    // COMPETITIVE RELATIONSHIPS: Break if trading with enemy
                    // ============================================
                    if (comBond > 0) {
                        // COMPETITIVE COMMERCIAL RELATIONSHIPS
                        // If other tribe has commercial relationships with our enemies, break the bond
                        let otherTribe = this.tribes[otherId];
                        if (otherTribe) {
                            for (let enemyId in tribe.atWarWith) {
                                if (tribe.atWarWith[enemyId] && otherTribe.commercialBonds[enemyId] > 20) {
                                    // They're trading with our enemy - break commercial bond!
                                    tribe.commercialBonds[otherId] = 0;
                                    otherTribe.commercialBonds[tribeId] = 0;
                                    // Reduce relations as well
                                    this.updateOpinion(tribeId, otherId, -15);
                                    this.updateOpinion(otherId, tribeId, -15);
                                    sfx.play('link_broken', 440, 0.1);
                                    continue; // Skip rest of processing for this bond
                                }
                            }
                            // Check if other tribe is at war with any of our commercial partners
                            for (let partnerId in tribe.commercialBonds) {
                                if (tribe.commercialBonds[partnerId] > 20 && otherTribe.atWarWith[partnerId]) {
                                    // They're at war with our commercial partner - break bond!
                                    tribe.commercialBonds[otherId] = 0;
                                    otherTribe.commercialBonds[tribeId] = 0;
                                    this.updateOpinion(tribeId, otherId, -15);
                                    this.updateOpinion(otherId, tribeId, -15);
                                    sfx.play('link_broken', 440, 0.1);
                                    continue;
                                }
                            }
                        }
                        
                        let lastTrade = tribe.lastTradeTime[otherId] || 0;
                        let framesSinceLastTrade = currentFrame - lastTrade;
                        let tradeProfit = tribe.tradeProfit[otherId] || 0;
                        
                        // Calculate recent profit (rolling window)
                        let recentProfit = 0;
                        if (tribe.tradeProfitHistory[otherId]) {
                            tribe.tradeProfitHistory[otherId].forEach(entry => {
                                if (currentFrame - entry.frame < 500) { // Last 500 frames
                                    recentProfit += entry.profit;
                                }
                            });
                        }
                        
                        // BONDS PERSIST IF TRADE IS PROFITABLE!
                        if (recentProfit > 0) {
                            // Trade is profitable - MAINTAIN bond automatically!
                            // No decay needed - the bond is economically justified
                            // Optional: Small growth if very profitable
                            if (recentProfit > 100) {
                                tribe.commercialBonds[otherId] = Math.min(100, comBond + 0.05);
                            }
                        } else if (framesSinceLastTrade > 1000) {
                            // No trade for 1000 frames AND no recent profit - might decay
                            // But check if they CAN trade (do they have resources?)
                            let nest = this.nests.find(n => n.tribeId == tribeId);
                            let otherNest = this.nests.find(n => n.tribeId == otherId);
                            
                            if (nest && otherNest) {
                                // Both nests exist - check if they CAN trade
                                let canTrade = nest.wealth > 30 && otherNest.wealth > 30;
                                
                                if (!canTrade) {
                                    // Can't afford to trade - slow decay
                                    let newComBond = Math.max(0, comBond - CONFIG.bondDecayRate * 0.3); // Very slow
                                    
                                    // UNPROFITABLE BOND BREAKS ‚Üí DISLIKE!
                                    if (comBond >= 10 && newComBond < 10) {
                                        sfx.play('link_broken', 460, 0.1);
                                        // Reduce relations when bond breaks due to unprofitability
                                        this.updateOpinion(tribeId, otherId, -20); // Significant hit to relations!
                                        this.updateOpinion(otherId, tribeId, -20);
                                    }
                                    
                                    tribe.commercialBonds[otherId] = newComBond;
                                } else if (framesSinceLastTrade > 2000) {
                                    // Can trade but haven't for 2000 frames - very slow decay
                                    let newComBond = Math.max(0, comBond - CONFIG.bondDecayRate * 0.1);
                                    
                                    // Long inactivity hurts relations slightly
                                    if (comBond >= 10 && newComBond < 10) {
                                        this.updateOpinion(tribeId, otherId, -10); // Smaller hit
                                        this.updateOpinion(otherId, tribeId, -10);
                                    }
                                    
                                    tribe.commercialBonds[otherId] = newComBond;
                                }
                            }
                        }
                    }
                    
                    // ============================================
                    // DIPLOMATIC BONDS: Decay ONLY if NO BENEFITS
                    // ============================================
                    if (dipBond > 0) {
                        let lastDiplomacy = tribe.lastDiplomacyTime[otherId] || 0;
                        let framesSinceLastDiplomacy = currentFrame - lastDiplomacy;
                        let diplomaticValue = tribe.diplomaticBenefits[otherId] || 0;
                        
                        // Bonds persist if there's been recent diplomatic activity OR ongoing benefits
                        if (framesSinceLastDiplomacy < 1000 || diplomaticValue > 0) {
                            // Active diplomacy or benefits - MAINTAIN bond
                            // Slow decay of benefit counter
                            if (diplomaticValue > 0) {
                                tribe.diplomaticBenefits[otherId] *= 0.99; // Slow decay of benefits
                            }
                        } else if (framesSinceLastDiplomacy > 2000) {
                            // No diplomacy for 2000 frames AND no benefits - very slow decay
                            let newDipBond = Math.max(0, dipBond - CONFIG.bondDecayRate * 0.2);
                            
                            // DIPLOMATIC BOND BREAKS ‚Üí DISLIKE!
                            if (dipBond >= 10 && newDipBond < 10) {
                                sfx.play('link_broken', 420, 0.1);
                                // Reduce relations when diplomatic bond breaks
                                this.updateOpinion(tribeId, otherId, -15); // Diplomatic failure hurts relations
                                this.updateOpinion(otherId, tribeId, -15);
                            }
                            
                            tribe.diplomaticBonds[otherId] = newDipBond;
                        }
                    }
                    
                    // AUTO-DECLARE WAR if relations are terrible and no bonds exist
                    let relation = tribe.relations[otherId] || 0;
                    if (relation < CONFIG.warDeclarationThreshold && dipBond === 0 && comBond === 0) {
                        // Relations very low, no bonds - MUCH HIGHER chance of war
                        if (Math.random() < 0.35) { // 35% chance per update (was 15%)
                            this.declareWar(tribeId, otherId);
                            console.log(`WAR DECLARED between tribe ${tribeId} and ${otherId}! Relations: ${relation}`);
                        }
                    }
                    
                    // ESCALATION: Even with bonds, terrible relations can lead to war
                    if (relation < CONFIG.warDeclarationThreshold * 1.3 && (dipBond < 20 || comBond < 20)) {
                        // Weak bonds, terrible relations - can still go to war
                        if (Math.random() < 0.2) { // 20% chance (was 8%)
                            this.declareWar(tribeId, otherId);
                            console.log(`WAR ESCALATED between tribe ${tribeId} and ${otherId}! Relations: ${relation}`);
                        }
                    }
                    
                    // RIVALRY: MORE AGGRESSIVE deterioration
                    if (Math.random() < 0.05 && dipBond < 30 && comBond < 30) { // 5% chance (was 2%)
                        this.updateOpinion(tribeId, otherId, -3); // Faster deterioration (was -2)
                        this.updateOpinion(otherId, tribeId, -3);
                    }
                }
            }

            updateOpinion(fromTribe, toTribe, amount) {
                if (!this.tribes[fromTribe] || !this.tribes[toTribe] || fromTribe === toTribe) return;
                this.tribes[fromTribe].relations[toTribe] += amount;
                if (this.tribes[fromTribe].relations[toTribe] > 100) this.tribes[fromTribe].relations[toTribe] = 100;
                if (this.tribes[fromTribe].relations[toTribe] < -100) this.tribes[fromTribe].relations[toTribe] = -100;
            }
        }

        /* --- CLASSES --- */

        class Particle {
            constructor(x, y, color, type) {
                this.pos = new Vector(x, y);
                this.vel = Vector.random2D().mult(Math.random() * 2);
                this.life = 1.0;
                this.color = color;
                this.type = type || 'circle'; 
            }
            update() {
                this.pos.add(this.vel);
                this.life -= 0.05;
            }
            draw(ctx) {
                ctx.globalAlpha = Math.max(0, this.life);
                ctx.fillStyle = this.color;
                
                if (this.type === 'heart') {
                    ctx.beginPath();
                    ctx.arc(this.pos.x, this.pos.y, 3, 0, Math.PI*2);
                    ctx.fill();
                } else if (this.type === 'spark') {
                    ctx.beginPath();
                    ctx.rect(this.pos.x-1, this.pos.y-1, 2, 2);
                    ctx.fill();
                } else if (this.type === 'lightning') {
                    ctx.strokeStyle = this.color;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(this.pos.x, this.pos.y - 10);
                    ctx.lineTo(this.pos.x + 5, this.pos.y);
                    ctx.lineTo(this.pos.x, this.pos.y + 10);
                    ctx.stroke();
                } else if (this.type === 'star') {
                    // Five-pointed star
                    ctx.beginPath();
                    for(let i = 0; i < 5; i++) {
                        let angle = (i * 4 * Math.PI / 5) - Math.PI / 2;
                        let x = this.pos.x + Math.cos(angle) * 4;
                        let y = this.pos.y + Math.sin(angle) * 4;
                        if(i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.fill();
                } else if (this.type === 'ring') {
                    // Expanding ring
                    ctx.strokeStyle = this.color;
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(this.pos.x, this.pos.y, 5 * (1 - this.life), 0, Math.PI*2);
                    ctx.stroke();
                } else if (this.type === 'plus') {
                    // Plus sign for healing
                    ctx.fillRect(this.pos.x - 3, this.pos.y - 1, 6, 2);
                    ctx.fillRect(this.pos.x - 1, this.pos.y - 3, 2, 6);
                } else if (this.type === 'dollar') {
                    // Dollar sign for wealth
                    ctx.font = '8px monospace';
                    ctx.fillText('$', this.pos.x - 3, this.pos.y + 3);
                } else if (this.type === 'skull') {
                    // Skull emoji-like
                    ctx.font = '10px monospace';
                    ctx.fillText('‚úï', this.pos.x - 3, this.pos.y + 3);
                } else if (this.type === 'blood') {
                    // Blood splatter
                    ctx.beginPath();
                    ctx.arc(this.pos.x, this.pos.y, 1 + Math.random() * 2, 0, Math.PI*2);
                    ctx.fill();
                } else {
                    ctx.beginPath();
                    ctx.arc(this.pos.x, this.pos.y, 2, 0, Math.PI*2);
                    ctx.fill();
                }
                ctx.globalAlpha = 1.0;
            }
        }
        
        // PROJECTILE CLASS FOR RANGED COMBAT
        class Projectile {
            constructor(x, y, targetX, targetY, shooter, damage, type='arrow') {
                this.pos = new Vector(x, y);
                this.target = new Vector(targetX, targetY);
                this.shooter = shooter; // Agent who shot it
                this.damage = damage;
                this.type = type; // 'arrow', 'bolt', 'siege'
                this.speed = type === 'siege' ? 3 : 8;
                this.active = true;
                this.life = 180; // Max frames before disappearing
                
                // Calculate velocity towards target
                let direction = Vector.sub(this.target, this.pos);
                direction.normalize();
                this.vel = direction.mult(this.speed);
            }
            
            update(agents, nests) {
                if (!this.active) return false;
                
                this.pos.add(this.vel);
                this.life--;
                
                if (this.life <= 0) {
                    this.active = false;
                    return false;
                }
                
                // Check collision with agents
                for (let agent of agents) {
                    if (agent.dead) continue;
                    if (agent === this.shooter) continue; // Can't hit self
                    
                    let d = Vector.dist(this.pos, agent.pos);
                    if (d < agent.radius + 5) {
                        // Hit!
                        agent.health -= this.damage;
                        this.active = false;
                        
                        // VFX
                        if (typeof sim !== 'undefined') {
                            sim.particles.push(new Particle(agent.pos.x, agent.pos.y, '#dc2626', 'blood'));
                            sfx.play('attack', 350, 0.1);
                            
                            // DETERIORATE RELATIONS when projectile hits
                            if (this.shooter && this.shooter.tribeId !== undefined && agent.tribeId !== undefined && 
                                this.shooter.tribeId !== -1 && agent.tribeId !== -1 && 
                                this.shooter.tribeId !== agent.tribeId) {
                                sim.tribes.updateOpinion(this.shooter.tribeId, agent.tribeId, -2); // Aggressor dislikes victim more
                                sim.tribes.updateOpinion(agent.tribeId, this.shooter.tribeId, -4); // Victim REALLY dislikes aggressor
                            }
                        }
                        return false;
                    }
                }
                
                // Check collision with nests (siege weapons)
                if (this.type === 'siege') {
                    for (let nest of nests) {
                        let d = Vector.dist(this.pos, nest.pos);
                        if (d < nest.radius) {
                            // Hit nest! - Defense level reduces damage
                            let baseDamage = this.damage;
                            // Defense reduces damage: each defense level reduces damage by 15% (max 75% reduction at DEF 5+)
                            let defenseReduction = Math.min(0.75, nest.defenseLevel * 0.15);
                            let actualDamage = baseDamage * (1.0 - defenseReduction);
                            nest.health -= actualDamage;
                            nest.hp -= actualDamage; // Also damage HP
                            this.active = false;
                            
                            // VFX
                            if (typeof sim !== 'undefined') {
                                sim.particles.push(new Particle(nest.pos.x, nest.pos.y, '#f59e0b', 'lightning'));
                                sim.particles.push(new Particle(nest.pos.x, nest.pos.y, '#dc2626', 'spark'));
                                sfx.play('attack', 200, 0.2);
                                
                                // SEVERELY DETERIORATE RELATIONS when nest is attacked
                                if (this.shooter && this.shooter.tribeId !== undefined && nest.tribeId !== undefined && 
                                    this.shooter.tribeId !== -1 && nest.tribeId !== -1 && 
                                    this.shooter.tribeId !== nest.tribeId) {
                                    sim.tribes.updateOpinion(this.shooter.tribeId, nest.tribeId, -3); // Aggressor really dislikes target
                                    sim.tribes.updateOpinion(nest.tribeId, this.shooter.tribeId, -8); // Victim tribe is FURIOUS!
                                    
                                    // Aquatic sound for major event
                                    sfx.play('bubble', 250, 0.12);
                                }
                            }
                            return false;
                        }
                    }
                }
                
                return true;
            }
            
            draw(ctx) {
                if (!this.active) return;
                
                ctx.save();
                ctx.globalAlpha = Math.min(1.0, this.life / 60);
                
                if (this.type === 'siege') {
                    // Siege projectile - large boulder
                    ctx.fillStyle = '#78350f';
                    ctx.beginPath();
                    ctx.arc(this.pos.x, this.pos.y, 6, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#f59e0b';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                } else {
                    // Arrow/bolt - line with point
                    ctx.strokeStyle = this.type === 'bolt' ? '#60a5fa' : '#a8a29e';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(this.pos.x - this.vel.x, this.pos.y - this.vel.y);
                    ctx.lineTo(this.pos.x, this.pos.y);
                    ctx.stroke();
                    
                    // Arrowhead
                    ctx.fillStyle = this.type === 'bolt' ? '#3b82f6' : '#57534e';
                    ctx.beginPath();
                    ctx.arc(this.pos.x, this.pos.y, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.restore();
            }
        }

        class Agent {
            constructor(x, y, dna, parents, tribeId) {
                this.pos = new Vector(x, y);
                this.vel = Vector.random2D();
                this.acc = new Vector(0, 0);
                this.wanderTheta = 0; 
                
                this.id = Math.random().toString(36).substr(2, 6).toUpperCase();
                this.age = 0;
                this.lifespan = (CONFIG.lifespanBase + (Math.random() * 1000)) * CONFIG.deathRate; 
                this.maxLifespan = this.lifespan * 2;
                
                // Roaming & oscillating movement state
                this.nextNestReturn = 0; // Frame when roamer should return to nest
                this.nextGrazerSpawn = 0; // Frame when farmer should spawn next grazer
                this.oscillatePhase = 0; // Current phase in oscillation cycle (0-3)
                
                this.dead = false;
                this.state = "Wander";
                this.isHero = false;
                
                // Food chain roles
                this.isGrazer = false;
                this.isPredator = false;
                this.isPrey = false;
                
                this.energy = 100;
                this.maxEnergy = 300;
                this.wealth = 0; 
                this.health = 100;
                this.maxHealth = 100;
                
                // Inherit Skills from Tribe Tech Level
                let startSkill = 0;
                if (parents && sim.tribes.tribes[tribeId]) {
                    let tier = sim.tribes.tribes[tribeId].techTier;
                    if ((sim.tribes.tribes[tribeId].roles['Scientist'] || 0) > 0) startSkill = 1;
                    
                    // Safe access to parent wealth (parents might not have p1/p2 or wealth)
                    let parentWealth = 0;
                    if (parents.p1 && typeof parents.p1.wealth !== 'undefined') parentWealth += parents.p1.wealth;
                    if (parents.p2 && typeof parents.p2.wealth !== 'undefined') parentWealth += parents.p2.wealth;
                    let healthBonus = Math.min(200, parentWealth / 10); 
                    this.maxHealth += healthBonus;
                    this.health = this.maxHealth;
                }
                
                this.charisma = 0; 
                this.carrying = null;
                this.home = null; 
                this.partners = []; 
                this.lastPos = new Vector(x, y);
                this.stuckCounter = 0;
                this.targetId = null;
                this.shootCooldown = 0;

                this.kills = 0;
                // Set generation: if parents provided and have valid gen, increment it; otherwise start at 1
                if (parents && typeof parents.gen === 'number' && !isNaN(parents.gen)) {
                    this.generation = parents.gen + 1;
                } else {
                    this.generation = 1;
                }
                this.mateCooldown = 0;
                this.loyalty = {}; 
                this.kin = []; 

                this.disease = 0; 
                this.immunity = 0; 
                
                // Rigid bond bonuses
                this.shieldBonus = 0;
                this.huntBonus = 1.0;
                this.gatherRangeBonus = 1.0;
                
                // Ranged combat
                this.shotCooldown = 0; // Frames until can shoot again
                this.canShootRanged = false; // Only soldiers can shoot (set in determineRole)
                
                // Diplomat/Merchant properties
                this.isSustainedByTribe = false; // Set true for diplomats/merchants
                this.canDefendSelf = true; // Set false for diplomats/merchants

                this.researchPoints = 0;
                this.skills = {
                    SPEED: startSkill,
                    ENERGY: startSkill,
                    HEALTH: startSkill,
                    MANUFACTURE: startSkill,
                    SENSE: startSkill,
                    SHIELD: startSkill,
                    FARMING: startSkill,
                    COMBAT: startSkill,
                    DIPLOMACY: startSkill
                };

                if (tribeId !== undefined) this.tribeId = tribeId;
                else if (parents && parents.tribeId !== undefined) this.tribeId = parents.tribeId;
                else this.tribeId = Math.floor(Math.random() * CONFIG.tribeCount);

                this.frenzyTimer = 0; 

                // DEFAULT DNA + MERGE (For Monsters)
                let defaults = {
                    aggression: Math.random(), social: Math.random(), builder: Math.random(),
                    speed: 0.3+Math.random()*0.7, size: 0.4+Math.random()*0.6, sense: 0.2+Math.random()*0.8,
                    botany: Math.random(), mining: Math.random(), defense: Math.random(),
                    raiding: Math.random(), defending: Math.random(), manufacturing: Math.random(),
                    intelligence: Math.random(), commerce: Math.random(), 
                    predator_target: Math.random(), prey_signal: Math.random(),
                    twitch: Math.random(), sociability: Math.random(),
                    altruism: Math.random(), curiosity: Math.random(),
                    // Movement genes (bias for compass directions)
                    move_n: Math.random(), move_s: Math.random(), move_e: Math.random(), move_w: Math.random(),
                    move_ne: Math.random(), move_se: Math.random(), move_nw: Math.random(), move_sw: Math.random(),
                    // Rigid bond gene (rare, low frequency, additive)
                    rigid_bond_preference: Math.random() * CONFIG.rigidBondChance,
                    // Bond type preference genes
                    family_bond_pref: Math.random(),
                    romantic_bond_pref: Math.random(),
                    alliance_bond_pref: Math.random(),
                    mentor_bond_pref: Math.random(),
                    friendship_bond_pref: Math.random(),
                    // Roaming gene (0 = stay near nest, 1 = roam freely)
                    roaming: Math.random(),
                    nest_return_frequency: Math.random(), // How often to return when roaming
                    // Oscillating movement pattern genes (up to 8-move cycles)
                    oscillate_cycle_speed: Math.random(), // How fast to cycle through pattern (frames per step)
                    oscillate_amplitude: Math.random() * 0.5, // How strongly to apply pattern (reduced to prevent sticking)
                    movement_tendency: 0.5 + Math.random() * 0.5, // Bias toward forward movement (0.5-1.0, prevents stasis)
                    movement_pattern: Math.floor(Math.random() * 6), // Movement behavior gene
                    // Movement pattern: array of 8 direction values (0-7 representing N,NE,E,SE,S,SW,W,NW)
                    // Each agent has a unique pattern that can mutate, with weighted probabilities
                    oscillate_pattern: Array(8).fill(0).map(() => Math.floor(Math.random() * 8)),
                    oscillate_weights: Array(8).fill(0).map(() => 0.5 + Math.random() * 0.5), // Weight for each direction (0.5-1.0)
                    resource_conversion_preference: Math.random(),
                    converter_special_gene: Math.random()
                };
                
                if (dna) this.dna = { ...defaults, ...dna };
                else this.dna = defaults;

                this.maxBonds = Math.max(1, Math.floor(this.dna.sociability * 4)); 
                
                // Bond types: Each partner has a bond type with different effects
                this.bondTypes = {}; // Map from partner ID to bond type
                this.rigidBonds = {}; // Map from partner ID to rigid bond type ('shield', 'hunt', 'gather', 'swift', null) 

                this.prefs = {
                    hunt: 1.0,
                    social: 1.0,
                    build: 1.0,
                    flee: 1.0
                };

                this.determineRole(parents);
                this.baseRadius = this.dna.size * 5 + 3;
                this.radius = this.baseRadius;
                this.baseSpeed = this.dna.speed * 2 + 1 + (this.dna.agility || 0.5) * 0.5; 
                this.maxSpeed = this.baseSpeed;
                this.baseMaxLifespan = this.maxLifespan;
                this.hasRigidLifespanBonus = false;
                this.structureStability = 0;
                this.lastPartnerHash = '';
                this.structureBandActive = false;
                this.structureStabilityGroupSize = 1;
                this.groupFormationFrame = typeof sim !== 'undefined' ? sim.frame : 0;
                // REMOVED CACHING - No longer using group cache to prevent doubling artifacts
                this.isGroupEntity = false;
                this.groupEntityMembers = [];
                this.groupAscendedFrame = -Infinity;
                this.groupEntityParent = null;
                this.converterBondGroups = [];
                this.lastBonderSpawnFrame = -Infinity;
                this.isConverterUnit = false;
                this.converterSource = null;
                this.converterTarget = null;
                this.converterOwner = null;
                this.isConverterBonder = false;
                this.lastBondAttempt = -Infinity;
                this.lastBonderSpawnFrame = 0;
                
                // MOMENTUM - agents have inertia based on size and health
                this.momentum = new Vector(0, 0);
                this.mass = this.baseRadius * (this.health / 100); // Mass = size √ó health factor
                this.maxForce = 0.3; 
                this.baseSense = 120 + (this.dna.sense * 150);
                this.senseRad = this.baseSense; 
                
                if (parents && parents.skills) {
                    for(let k in parents.skills) {
                        if (Math.random() < 0.5) this.learnSkill(k, parents.skills[k]);
                    }
                }

                // NEW: Start as child
                if (parents) {
                    this.radius *= 0.6;
                    this.maxSpeed *= 0.8;
                    if (parents.p1) { this.addPartner(parents.p1); this.kin.push(parents.p1.id); parents.p1.kin.push(this.id); }
                    if (parents.p2) { this.addPartner(parents.p2); this.kin.push(parents.p2.id); parents.p2.kin.push(this.id); }
                }
                
                // SOFT MUSICAL TONE WHEN AGENT IS BORN
                // Play a gentle, pleasant musical tone for agent birth
                if (typeof sfx !== 'undefined' && sfx.enabled) {
                    // Use pentatonic scale notes for pleasant, harmonious sound
                    // Musical scale frequencies: C, D, E, G, A (pentatonic - sounds pleasant)
                    let musicalNotes = [HARMONICS.C5, HARMONICS.D5, HARMONICS.E5, HARMONICS.G5, HARMONICS.A5]; // Harmonic pentatonic
                    let note = musicalNotes[Math.floor(Math.random() * musicalNotes.length)];
                    // Soft, gentle tone - lower volume and longer duration for pleasant effect
                    sfx.play('birth', note, 0.15, 0.4); // 0.15s duration, 40% volume for softness
                }
            }

            determineRole(parents) {
                if (this.dna.monster) {
                    this.role = 'Monster';
                    this.color = '#581c87'; 
                    this.radius = 25;
                    this.maxEnergy = 2000;
                    this.energy = 2000;
                    this.health = 500;
                    this.lifespan = CONFIG.monsterLifespan; 
                    this.tribeId = -1; 
                    // Leaders/Guardians/Monsters get super stats
                    this.maxHealth = 2000;
                    this.health = 2000;
                    return;
                }

                // EMERGENCE: Use Tech Tree Logic
                if (typeof sim !== 'undefined' && parents && sim.tribes && sim.tribes.tribes[this.tribeId]) {
                    let mutationChance = 0.1;
                    if (parents.p1 && parents.p2 && parents.p1.role && parents.p2.role && parents.p1.role !== parents.p2.role) mutationChance = 0.5; 
                    
                    if (Math.random() < mutationChance) {
                        let desired = sim.tribes.getDesiredRole(this.tribeId);
                        if (desired) {
                            this.role = desired;
                            this.assignColor();
                            return;
                        }
                    }
                }

                // Calculate commercial bond bonus for merchant role
                let commerceBonus = 0.3; // Base bonus to ensure merchants spawn
                if (typeof sim !== 'undefined' && this.tribeId !== -1 && sim.tribes && sim.tribes.tribes[this.tribeId]) {
                    let myTribe = sim.tribes.tribes[this.tribeId];
                    let totalCommercial = 0;
                    for (let otherId in myTribe.commercialBonds) {
                        totalCommercial += myTribe.commercialBonds[otherId];
                    }
                    // Strong commercial ties boost merchant births even more
                    commerceBonus += totalCommercial / 100; // Up to +1.0 bonus for max bonds
                }
                
                // Calculate manufacturing bonus for artisan role (MASSIVELY BOOSTED!)
                let manufacturingBonus = commerceBonus * 2.0 + 0.5; // 4x increase + base bonus

                const traits = [
                    { name: 'Garbage Collector', val: (this.dna.mining + this.dna.altruism + this.dna.curiosity) / 2.0 + 0.2 }, // Early tech tree role
                    { name: 'Farmer', val: (this.dna.botany + this.dna.altruism + this.dna.defense) / 2.0 + 0.15 }, // Spawns grazers, protects them
                    { name: 'Soldier', val: this.dna.aggression * 1.8 + 0.3 }, // BOOSTED soldier spawning!
                    { name: 'Botanist', val: this.dna.botany },
                    { name: 'Builder', val: this.dna.builder },
                    { name: 'Guardian', val: (this.dna.defense + this.dna.defending)/2 },
                    { name: 'Scout', val: this.dna.speed },
                    { name: 'Miner', val: this.dna.mining + 0.2 }, // Small boost
                    { name: 'Raider', val: this.dna.raiding },
                    { name: 'Artisan', val: this.dna.manufacturing * 2.0 + manufacturingBonus }, // DOUBLED base + huge bonus!
                    { name: 'Scientist', val: this.dna.intelligence * 1.5 + 0.2 }, // Boosted from 1.2 to 1.5
                    { name: 'Merchant', val: this.dna.commerce * 1.5 + commerceBonus }, // Boosted 1.5x plus bonus
                    { name: 'Healer', val: (this.dna.altruism + this.dna.botany) / 1.5 + 0.15 }, // Small boost
                    { name: 'Diplomat', val: (this.dna.social + this.dna.commerce + this.dna.curiosity) / 2.5 },
                    { name: 'Teacher', val: (this.dna.social + this.dna.intelligence) / 2.0 + 0.2 } // Small boost
                ];
                traits.sort((a, b) => b.val - a.val);
                this.role = traits[0].name;
                this.assignColor();
                
                // Buff Guardians/Leaders
                if (this.role === 'Guardian') {
                    this.maxHealth = 500; 
                    this.health = 500;
                }
            }

            assignColor() {
                // Reset ranged combat ability
                this.canShootRanged = false;
                
                switch(this.role) {
                    case 'Garbage Collector': this.color = '#78716c'; break; // Brown-grey
                    case 'Farmer': this.color = '#a3e635'; break; // Lime green
                    case 'Soldier': 
                        this.color = '#ef4444'; 
                        this.canShootRanged = true; // ONLY SOLDIERS CAN SHOOT
                        this.isSustainedByTribe = true; // Don't hunt food/resources
                        this.maxHealth = 150; // Higher health
                        this.health = Math.min(this.health, 150);
                        break; 
                    case 'Botanist': this.color = '#10b981'; break; 
                    case 'Builder': this.color = '#eab308'; break; 
                    case 'Guardian': this.color = '#64748b'; break; 
                    case 'Scout': this.color = '#22d3ee'; break; 
                    case 'Miner': 
                        this.color = '#ea580c'; 
                        this.isSoloActor = true; // Does not bond
                        break;
                    case 'Raider': this.color = '#6366f1'; break; 
                    case 'Artisan': 
                        this.color = '#a5f3fc'; 
                        this.isSustainedByTribe = true; // Tribe-sustained
                        this.canDefendSelf = false; // Defenseless
                        this.maxHealth = 120;
                        this.health = Math.min(this.health, 120);
                        break;
                    case 'Scientist': 
                        this.color = '#ffffff'; 
                        this.isSustainedByTribe = true; // Tribe-sustained
                        this.canDefendSelf = false; // Defenseless
                        this.maxHealth = 120;
                        this.health = Math.min(this.health, 120);
                        break; 
                    case 'Merchant': this.color = '#be123c'; break;
                    case 'Healer': this.color = '#fbcfe8'; break; 
                    case 'Diplomat': this.color = '#fde047'; break; 
                    case 'Teacher': 
                        this.color = '#c7d2fe'; 
                        this.isSustainedByTribe = true; // Tribe-sustained
                        this.canDefendSelf = false; // Defenseless
                        this.maxHealth = 120;
                        this.health = Math.min(this.health, 120);
                        break; 
                    default: this.color = '#fff';
                }
            }

            isAdult() {
                return this.age > CONFIG.adultAge;
            }
            
            getBondedGroup() {
                // Returns all agents in the bonded group (recursively finds all connected partners)
                let group = new Set([this]);
                let toCheck = [...this.partners];
                let checked = new Set([this]);
                
                while (toCheck.length > 0) {
                    let agent = toCheck.pop();
                    if (!agent || agent.dead || checked.has(agent)) continue;
                    
                    checked.add(agent);
                    group.add(agent);
                    
                    // Add this agent's partners to check
                    for (let partner of agent.partners) {
                        if (!checked.has(partner)) {
                            toCheck.push(partner);
                        }
                    }
                }
                
                return Array.from(group);
            }

            invalidateGroupCache() {
                // REMOVED CACHING - No longer needed, always recalculate
                // This method kept for compatibility but does nothing
            }

            getCachedBondedGroup() {
                // REMOVED CACHING - Causing doubling artifacts during high activity
                // Always recalculate to ensure accuracy and prevent visual glitches
                return this.getBondedGroup();
            }
            
            getGroupSynergies() {
                // Calculate emergent abilities from bonded group composition
                // Returns object with bonus multipliers and new capabilities
                
                let group = this.getBondedGroup();
                if (group.length <= 1) {
                    return { size: 1, multipliers: {}, capabilities: [] };
                }
                
                // Collect group DNA and roles
                let dnaAverages = {};
                let dnaVariances = {};
                let roles = {};
                let totalHealth = 0;
                let totalEnergy = 0;
                
                // Calculate averages
                for (let agent of group) {
                    if (agent.dead) continue;
                    
                    for (let gene in agent.dna) {
                        if (typeof agent.dna[gene] === 'number') {
                            dnaAverages[gene] = (dnaAverages[gene] || 0) + agent.dna[gene];
                        }
                    }
                    
                    roles[agent.role] = (roles[agent.role] || 0) + 1;
                    totalHealth += agent.health / agent.maxHealth;
                    totalEnergy += agent.energy / agent.maxEnergy;
                }
                
                let activeCount = group.filter(a => !a.dead).length;
                for (let gene in dnaAverages) {
                    dnaAverages[gene] /= activeCount;
                }
                
                // Calculate variances (diversity bonus)
                for (let agent of group) {
                    if (agent.dead) continue;
                    for (let gene in dnaAverages) {
                        let diff = agent.dna[gene] - dnaAverages[gene];
                        dnaVariances[gene] = (dnaVariances[gene] || 0) + diff * diff;
                    }
                }
                for (let gene in dnaVariances) {
                    dnaVariances[gene] = Math.sqrt(dnaVariances[gene] / activeCount);
                }
                
                // EMERGENT BONUSES (not hard-coded, calculated from composition)
                let synergies = {
                    size: activeCount,
                    multipliers: {},
                    capabilities: []
                };
                
                // 1. RESOURCE SYNERGY: High average botany/manufacturing + diversity = better harvesting
                if (dnaAverages.botany && dnaAverages.manufacturing) {
                    let resourcePower = (dnaAverages.botany + dnaAverages.manufacturing) / 2;
                    let diversityBonus = 1 + (dnaVariances.botany || 0) * 0.5;
                    synergies.multipliers.resourceHarvest = 1 + (resourcePower * diversityBonus * 0.4);
                    if (synergies.multipliers.resourceHarvest > 1.15) synergies.capabilities.push('efficient_harvesting');
                }
                
                // 2. COMBAT SYNERGY: High aggression + defense + variance = better fighting
                if (dnaAverages.aggression && dnaAverages.defense) {
                    let combatPower = (dnaAverages.aggression + dnaAverages.defense) / 2;
                    let tacticDiversity = (dnaVariances.aggression || 0) + (dnaVariances.defense || 0);
                    synergies.multipliers.combatEffectiveness = 1 + (combatPower * (1 + tacticDiversity) * 0.3);
                    if (synergies.multipliers.combatEffectiveness > 1.2) synergies.capabilities.push('pack_tactics');
                }
                
                // 3. MOBILITY SYNERGY: High speed + coordinated movement = faster group
                if (dnaAverages.speed) {
                    let mobilityBonus = dnaAverages.speed;
                    let coordination = 1 - Math.min(0.5, (dnaVariances.speed || 0)); // Low variance = better coordination
                    synergies.multipliers.movementSpeed = 1 + (mobilityBonus * coordination * 0.25);
                    if (synergies.multipliers.movementSpeed > 1.12) synergies.capabilities.push('swift_formation');
                }
                
                // 4. INTELLIGENCE SYNERGY: High intelligence + education variance = problem solving
                if (dnaAverages.intelligence && dnaVariances.intelligence) {
                    let thinkPower = dnaAverages.intelligence;
                    let creativity = dnaVariances.intelligence;
                    synergies.multipliers.resourceConversion = 1 + (thinkPower * (1 + creativity) * 0.35);
                    if (synergies.multipliers.resourceConversion > 1.15) synergies.capabilities.push('innovative_crafting');
                }
                
                // 5. SOCIAL SYNERGY: High social/altruism = better cooperation
                if (dnaAverages.social && dnaAverages.altruism) {
                    let socialPower = (dnaAverages.social + dnaAverages.altruism) / 2;
                    synergies.multipliers.energySharing = 1 + (socialPower * 0.3);
                    synergies.multipliers.bondStrength = 1 + (socialPower * 0.2);
                    if (socialPower > 0.7) synergies.capabilities.push('communal_support');
                }
                
                // 6. ROLE SYNERGY: Specific role combinations unlock bonuses
                let roleCount = Object.keys(roles).length;
                if (roleCount >= 3) {
                    // Diverse roles = adaptability
                    synergies.multipliers.adaptability = 1 + (roleCount * 0.08);
                    synergies.capabilities.push('versatile_group');
                }
                
                // Builder + Miner = construction synergy
                if (roles.Builder && roles.Miner) {
                    synergies.multipliers.resourceConversion = (synergies.multipliers.resourceConversion || 1) * 1.3;
                    synergies.capabilities.push('construction_team');
                }
                
                // Soldier + Diplomat = strategic advantage
                if (roles.Soldier && roles.Diplomat) {
                    synergies.multipliers.combatEffectiveness = (synergies.multipliers.combatEffectiveness || 1) * 1.2;
                    synergies.capabilities.push('strategic_warfare');
                }
                
                // Merchant + Artisan = trade advantage
                if (roles.Merchant && roles.Artisan) {
                    synergies.multipliers.tradeValue = 1.4;
                    synergies.capabilities.push('master_traders');
                }
                
                // Scientist + Teacher = knowledge amplification
                if (roles.Scientist && roles.Teacher) {
                    synergies.multipliers.techGain = 1.5;
                    synergies.capabilities.push('research_institute');
                }
                
                // 7. HEALTH/ENERGY SYNERGY: Well-fed, healthy groups are more effective
                let groupVitality = (totalHealth + totalEnergy) / (2 * activeCount);
                if (groupVitality > 0.8) {
                    // Scale all multipliers by vitality
                    for (let key in synergies.multipliers) {
                        synergies.multipliers[key] *= (1 + (groupVitality - 0.8) * 0.5);
                    }
                }
                
                // 8. SIZE SCALING: Larger groups get diminishing returns but still benefit
                let sizeBonus = Math.min(1.3, 1 + Math.log(activeCount) * 0.15);
                for (let key in synergies.multipliers) {
                    synergies.multipliers[key] = (synergies.multipliers[key] || 1) * sizeBonus;
                }
                
                return synergies;
            }

            learnSkill(skill, level) {
                if (this.skills[skill] < level) {
                    this.skills[skill] = level;
                    this.applySkills();
                    sim.particles.push(new Particle(this.pos.x, this.pos.y, '#ffffff'));
                }
            }

            applySkills() {
                this.maxSpeed = this.baseSpeed + (this.skills.SPEED * 0.3); 
                this.maxEnergy = 300 + (this.skills.ENERGY * 100);
                this.maxHealth = 100 + (this.skills.HEALTH * 50);
                this.senseRad = this.baseSense + (this.skills.SENSE * 50);
            }
            
            learn(key, amount) {
                this.prefs[key] += amount * CONFIG.learningRate;
                this.prefs[key] = Math.max(0.1, Math.min(3.0, this.prefs[key]));
            }

            adjustLoyalty(id, amount) {
                if (!this.loyalty[id]) this.loyalty[id] = 0;
                this.loyalty[id] += amount;
                if (this.loyalty[id] > 100) this.loyalty[id] = 100;
                if (this.loyalty[id] < -100) this.loyalty[id] = -100;
            }

            getNetLoyalty(other) {
                if (!other) return 0; 
                if (this.kin.includes(other.id)) return 100;
                let personal = this.loyalty[other.id] || 0;
                if (this.tribeId !== -1 && other.tribeId !== -1 && sim.tribes) {
                    let tribal = sim.tribes.getOpinion(this.tribeId, other.tribeId);
                    return personal + tribal;
                }
                return personal;
            }

            resolveCollisions(resources) {
                // Nests are solid
                for(let n of sim.tribes.nests) {
                    if (Vector.dist(this.pos, n.pos) < n.radius + this.radius) {
                        let push = Vector.sub(this.pos, n.pos).normalize().mult(0.5);
                        this.pos.add(push);
                    }
                }
                for (let r of resources) {
                    if (r.type === 'MAT' || r.type === 'ORE') {
                        if (!r.carrier && r.active) {
                            let d = Vector.dist(this.pos, r.pos);
                            let minD = this.radius + r.config.radius;
                            if (d < minD) {
                                if (this.stuckCounter > 5) {
                                    r.active = false;
                                    sim.particles.push(new Particle(r.pos.x, r.pos.y, '#facc15'));
                                    this.energy += 10;
                                    if (this.energy > this.maxEnergy) this.energy = this.maxEnergy;
                                } else {
                                    let push = Vector.sub(this.pos, r.pos).normalize().mult(minD - d);
                                    this.pos.add(push);
                                }
                            }
                        }
                    }
                }
            }

            update(resources, agents, doExpensiveOps = true) {
                if (this.dead) return;
                
                // Initialize combat/mating state tracking if not already set
                if (this.inCombat === undefined) this.inCombat = false;
                if (this.isMating === undefined) this.isMating = false;
                if (this.lastCombatFrame === undefined) this.lastCombatFrame = 0;
                if (this.lastMatingFrame === undefined) this.lastMatingFrame = 0;
                
                // Play battle sounds every 150 frames during combat (MUCH LOWER VOLUME, LESS GRATING SOUND)
                // STRICT GLOBAL THROTTLE: Only ONE battle sound can play per frame globally to prevent buzzing
                if (this.inCombat && typeof sim !== 'undefined' && sim.frame) {
                    let framesSinceCombat = sim.frame - this.lastCombatFrame;
                    if (framesSinceCombat <= 300) { // Combat state lasts 300 frames (2 sound plays)
                        // Play sound every 150 frames (150, 300) - but only if no other battle sound this frame or recently
                        if (framesSinceCombat % 150 === 0 && framesSinceCombat > 0) {
                            let framesSinceLastBattleSound = sim.frame - soundThrottle.lastBattleSoundFrame;
                            // STRICT: Must pass cooldown AND no other battle sound played this frame
                            if (framesSinceLastBattleSound >= soundThrottle.battleSoundCooldown && !soundThrottle.battleSoundPlayedThisFrame) {
                                // Use low static buzz for battle
                                let battleFreq = HARMONICS.A3; // Low A (220 Hz) - base frequency for static
                                sfx.play('static', battleFreq, 0.015); // Low static buzz - louder so it's audible
                                soundThrottle.lastBattleSoundFrame = sim.frame; // Update global throttle
                                soundThrottle.battleSoundPlayedThisFrame = true; // Mark as played this frame
                            }
                        }
                    } else {
                        this.inCombat = false; // Clear combat state after 300 frames
                    }
                }
                
                // Play love/mating sounds every 150 frames during mating (MUCH LOWER VOLUME)
                // STRICT GLOBAL THROTTLE: Only ONE love sound can play per frame globally to prevent buzzing
                if (this.isMating && typeof sim !== 'undefined' && sim.frame) {
                    let framesSinceMating = sim.frame - this.lastMatingFrame;
                    if (framesSinceMating <= 300) { // Mating state lasts 300 frames (2 sound plays)
                        // Play sound every 150 frames (150, 300) - but only if no other love sound this frame or recently
                        if (framesSinceMating % 150 === 0 && framesSinceMating > 0) {
                            let framesSinceLastLoveSound = sim.frame - soundThrottle.lastLoveSoundFrame;
                            // STRICT: Must pass cooldown AND no other love sound played this frame
                            if (framesSinceLastLoveSound >= soundThrottle.loveSoundCooldown && !soundThrottle.loveSoundPlayedThisFrame) {
                                // Use slow quiet bell tone for mating - with lots of reverb
                                let matingFreq = LOVE_TONES[Math.floor(Math.random() * LOVE_TONES.length)];
                                sfx.play('mating', matingFreq, 0.012); // Slow quiet bell - louder so it's audible, with lots of reverb
                                soundThrottle.lastLoveSoundFrame = sim.frame; // Update global throttle
                                soundThrottle.loveSoundPlayedThisFrame = true; // Mark as played this frame
                            }
                        }
                    } else {
                        this.isMating = false; // Clear mating state after 300 frames
                    }
                }
                
                // Babies grow faster based on babyGrowthRate
                if (!this.isAdult()) {
                    this.age += CONFIG.babyGrowthRate;
                } else {
                this.age++;
                }
                
                if (this.mateCooldown > 0) this.mateCooldown--;
                
                // Health-based death rate: healthier agents live longer
                // Calculate health ratio (0.0 to 1.0)
                let healthRatio = this.health / this.maxHealth;
                
                // Death rate multiplier based on health:
                // - Very healthy (>80%): death rate is 20% of normal (lifespan decreases 80% slower)
                // - Healthy (>60%): death rate is 40% of normal
                // - Moderate (>40%): death rate is 70% of normal
                // - Unhealthy (‚â§40%): death rate is 100% of normal (full death rate)
                let deathRateMult = 1.0;
                if (healthRatio > 0.8) {
                    deathRateMult = 0.2; // Very healthy: 80% slower death
                } else if (healthRatio > 0.6) {
                    deathRateMult = 0.4; // Healthy: 60% slower death
                } else if (healthRatio > 0.4) {
                    deathRateMult = 0.7; // Moderate: 30% slower death
                }
                // else deathRateMult = 1.0 (unhealthy: normal death rate)
                
                // Apply health-based death rate: only decrement lifespan probabilistically
                // Healthier agents have a lower chance of aging each frame
                if (Math.random() < deathRateMult) {
                this.lifespan--;
                }
                
                if (this.age >= CONFIG.adultAge && this.age - CONFIG.babyGrowthRate < CONFIG.adultAge) {
                    this.breakAllBonds();
                    sim.particles.push(new Particle(this.pos.x, this.pos.y, '#ffffff'));
                }

                // Bond snapping - rigid bonds are harder to break
                if (this.partners.length > 0) {
                     let luckyIndex = Math.floor(Math.random() * this.partners.length);
                     let p = this.partners[luckyIndex];
                     let rigidType = this.rigidBonds[p.id];
                     let breakRate = CONFIG.bondBreakRate;
                     if (rigidType) {
                         // Rigid bonds break much slower
                         breakRate *= (1.0 - CONFIG.rigidBondBreakResistance);
                     }
                     if (Math.random() < breakRate) {
                     this.removePartner(p);
                     p.removePartner(this);
                     }
                }
                
                // Tribal conversion through bonded groups
                if (this.partners.length > 0 && this.age % 100 === 0 && this.tribeId !== -1 && this.role !== 'Monster') {
                    // Count tribes in bonded group
                    let tribeCounts = {};
                    let totalBonded = 0;
                    
                    this.partners.forEach(p => {
                        if (!p.dead && p.tribeId !== -1 && p.role !== 'Monster') {
                            tribeCounts[p.tribeId] = (tribeCounts[p.tribeId] || 0) + 1;
                            totalBonded++;
                        }
                    });
                    
                    // Find majority tribe
                    let majorityTribe = null;
                    let maxCount = 0;
                    for (let tid in tribeCounts) {
                        if (tribeCounts[tid] > maxCount) {
                            maxCount = tribeCounts[tid];
                            majorityTribe = parseInt(tid);
                        }
                    }
                    
                    // Convert if majority is different tribe and represents >50% of bonded group
                    if (majorityTribe !== null && majorityTribe !== this.tribeId && maxCount > totalBonded / 2) {
                        // Small chance to convert based on group pressure
                        if (Math.random() < 0.1) {
                            this.tribeId = majorityTribe;
                            if (sim.tribes.tribes[majorityTribe]) {
                                this.color = sim.tribes.tribes[majorityTribe].color;
                                sim.particles.push(new Particle(this.pos.x, this.pos.y, this.color, 'spark'));
                            }
                        }
                    }
                }

                if (this.lifespan <= 0 && this.role !== 'Monster') {
                    this.dead = true;
                    this.breakAllBonds();
                    return;
                }

                if (Vector.dist(this.pos, this.lastPos) < 1.0) this.stuckCounter++;
                else this.stuckCounter = 0;
                this.lastPos = this.pos.copy();

                if (this.carrying) {
                    if (!this.carrying.active) this.carrying = null; 
                    else {
                        this.carrying.pos.x = this.pos.x;
                        this.carrying.pos.y = this.pos.y - this.radius - 5; 
                    }
                }

                // Resource Sharing & Child Feeding
                if (this.partners.length > 0 && this.age % 10 === 0) {
                    this.partners.forEach(p => {
                        if (!p.dead) {
                            if (this.isAdult() && !p.isAdult() && this.energy > 50) {
                                let flow = 5;
                                this.energy -= flow;
                                p.energy += flow;
                            }
                            else if (this.energy > p.energy) {
                                let flow = (this.energy - p.energy) * 0.05; 
                                this.energy -= flow;
                                p.energy += flow;
                            }
                        }
                    });
                }
                
                // WELFARE SYSTEM
                let myNest = sim.tribes.nests.find(n => n.tribeId === this.tribeId);
                if (this.energy < 50 && myNest && Vector.dist(this.pos, myNest.pos) < 150 && myNest.wealth > 5) {
                     // Welfare check (MUCH CHEAPER!)
                     this.energy += 20;
                     myNest.wealth -= 0.1; // Reduced from 1 to 0.1 (90% cost reduction!)
                     this.state = "On Welfare";
                }

                if (!this.isAdult()) {
                    this.energy -= 0.05; 
                }
                
                // Exile Logic
                if (this.tribeId !== -1 && sim.tribes.tribes[this.tribeId].leaderId) {
                     let leaderId = sim.tribes.tribes[this.tribeId].leaderId;
                     if (this.loyalty[leaderId] < -50) {
                         this.tribeId = -1; // Exile
                         this.color = "#555"; // Grey
                     }
                }
                
                // UNAFFILIATED AGENTS JOIN WEALTHY TRIBES - Weighted chance to join top 3 wealthiest tribes
                // Only applies to unaffiliated agents (exiled, not monsters)
                if (this.tribeId === -1 && this.role !== 'Monster' && typeof sim !== 'undefined' && sim.tribes && sim.tribes.nests) {
                    // Check periodically (every 200 frames to avoid performance issues)
                    if (sim.frame % 200 === 0 && Math.random() < 0.15) { // 15% chance per check
                        // Get all tribes with their nest wealth
                        let tribeWealths = [];
                        for (let tid in sim.tribes.tribes) {
                            let tribeId = parseInt(tid);
                            let nest = sim.tribes.nests.find(n => n.tribeId === tribeId && n.hp > 0);
                            if (nest) {
                                tribeWealths.push({
                                    tribeId: tribeId,
                                    wealth: nest.wealth,
                                    nest: nest
                                });
                            }
                        }
                        
                        // Sort by wealth (descending) and get top 3
                        tribeWealths.sort((a, b) => b.wealth - a.wealth);
                        let top3Tribes = tribeWealths.slice(0, 3);
                        
                        if (top3Tribes.length > 0) {
                            // Calculate weights based on wealth (wealthier = higher chance)
                            let totalWealth = top3Tribes.reduce((sum, t) => sum + t.wealth, 0);
                            
                            if (totalWealth > 0) {
                                // Weighted random selection
                                let random = Math.random() * totalWealth;
                                let cumulative = 0;
                                let selectedTribe = null;
                                
                                for (let tribe of top3Tribes) {
                                    cumulative += tribe.wealth;
                                    if (random <= cumulative) {
                                        selectedTribe = tribe;
                                        break;
                                    }
                                }
                                
                                // Fallback to first if somehow none selected
                                if (!selectedTribe) selectedTribe = top3Tribes[0];
                                
                                // Join the selected wealthy tribe
                                this.tribeId = selectedTribe.tribeId;
                                this.assignColor(); // Update color based on role
                                
                                // VFX for joining a tribe
                                sim.particles.push(new Particle(this.pos.x, this.pos.y, '#3b82f6', 'star'));
                                sfx.play('link_formed', 500 + Math.random() * 100, 0.1);
                            }
                        }
                     }
                }

                if (this.role !== 'Monster') {
                    let growthFactor = 0.7 + (this.energy / this.maxEnergy) * 0.8;
                    if (!this.isAdult()) growthFactor *= 0.6; 
                    if(this.role === 'Monster') {
                         growthFactor += (this.partners.length * 0.5); 
                    }
                    if (this.isHero) growthFactor *= 1.2;
                    growthFactor = Math.min(2.5, growthFactor); 
                    this.radius = this.baseRadius * growthFactor;
                }

                // IMMORTALITY CHECK
                let isVIP = (this.role === 'Guardian' || (this.tribeId !== -1 && sim.tribes.tribes[this.tribeId].leaderId === this.id));
                
                if (isVIP && myNest && myNest.wealth > 0) {
                    if (this.energy < 50) { this.energy += 50; myNest.wealth = Math.max(0, myNest.wealth - 1); }
                    if (this.health < 50) { this.health += 50; myNest.wealth = Math.max(0, myNest.wealth - 1); }
                    this.lifespan = this.maxLifespan; // Reset age timer
                }

                if (this.disease > 0) {
                    this.disease--;
                    this.energy -= 0.2; 
                    this.maxSpeed = this.baseSpeed * 0.5; 
                    if (this.disease % 20 === 0) sim.particles.push(new Particle(this.pos.x, this.pos.y, '#22c55e'));
                } else {
                    this.maxSpeed = this.baseSpeed + (this.skills.SPEED * 0.3); 
                }

                if (this.immunity > 0) {
                    this.immunity--; 
                    if (this.disease > 0) this.disease = 0; 
                }

                if (this.role === 'Scientist') {
                    this.researchPoints += CONFIG.researchSpeed;
                    // Scientists also generate tech points for their tribe
                    if (typeof sim !== 'undefined' && sim.tribes && this.tribeId !== -1 && Math.random() < 0.1) {
                        sim.tribes.progressTech(this.tribeId, 'science', 1);
                    }
                    if (this.researchPoints > 100) {
                        this.researchPoints = 0;
                        const skillKeys = Object.keys(this.skills);
                        const learned = skillKeys[Math.floor(Math.random() * skillKeys.length)];
                        this.learnSkill(learned, this.skills[learned] + 1);
                        sim.particles.push(new Particle(this.pos.x, this.pos.y, '#60a5fa')); 
                    }
                }

                if (this.skills.HEALTH > 0 && this.health < this.maxHealth) {
                    let groupBenefits = this.getGroupBenefits();
                    this.health += 0.05 * this.skills.HEALTH * groupBenefits.healingBonus;
                }

                // BOTANIST BEHAVIOR - Find food areas and grow more food
                if (this.role === 'Botanist') {
                    this.energy += 0.1; // Botanists are energy efficient
                    
                    // Fertilize nearby food resources (extend their life)
                    if (Math.random() < CONFIG.botanistFertilizeRate) {
                        let nearbyFood = resources.filter(r => 
                            r.type === 'FOOD' && 
                            Vector.dist(this.pos, r.pos) < CONFIG.botanistFertilizeRadius
                        );
                        nearbyFood.forEach(r => {
                            if (r.life < r.maxLife) {
                                r.life = Math.min(r.maxLife, r.life + 50); // Restore life
                            }
                        });
                    }
                    
                    // When near food areas, plant more food
                    let nearbyFoodCount = resources.filter(r => 
                        r.type === 'FOOD' && 
                        r.active &&
                        Vector.dist(this.pos, r.pos) < 80
                    ).length;
                    
                    // If in a food-rich area and have energy, grow more food
                    if (nearbyFoodCount >= 2 && this.energy > 50 && Math.random() < 0.03) {
                        // Plant new food near existing food
                        let plantX = this.pos.x + (Math.random() * 60 - 30);
                        let plantY = this.pos.y + (Math.random() * 60 - 30);
                        sim.spawnResource(null, plantX, plantY, 'FOOD', false, this.tribeId);
                        this.energy -= 20;
                        sim.particles.push(new Particle(this.pos.x, this.pos.y, '#4ade80', 'leaf'));
                        this.state = "Growing Food";
                    }
                }
                
                if (this.role === 'Healer') {
                    let groupBenefits = this.getGroupBenefits();
                    if (this.health < this.maxHealth) this.health += 0.2 * groupBenefits.healingBonus;
                }

                let load = 0;
                if (this.carrying) {
                    load = 0.05; 
                    if (this.role === 'Builder' && this.carrying.type === 'MAT') load = 0;
                    if (this.role === 'Scout' && this.carrying.type === 'FOOD') load = 0;
                    if (this.role === 'Merchant') load = 0; 
                    if (this.role === 'Miner' && this.carrying.type === 'ORE') load = 0.1; 
                }

                let groupBenefits = this.getGroupBenefits();
                let structureBandFactor = this.structureBandActive ? CONFIG.structureStabilityBandBonus : 1;
                let structureBonus = 1 + Math.min(2, this.structureStability / 200) * structureBandFactor;
                let cost = (CONFIG.energyBurnRate + (this.dna.speed * 0.04) + (this.radius * 0.02) + load) * groupBenefits.energyMultiplier;
                cost *= 1 - Math.min(0.4, this.structureStability * 0.0006 * structureBandFactor); // reduce cost as structure stabilizes
                
                // WAR COST MULTIPLIER - 80% increase per war (additive costs for multiple wars)
                if (this.tribeId !== -1 && typeof sim !== 'undefined' && sim.tribes) {
                    let tribe = sim.tribes.tribes[this.tribeId];
                    if (tribe && tribe.atWarWith) {
                        // Count how many wars the tribe is actively engaged in
                        let warCount = 0;
                        for (let otherId in tribe.atWarWith) {
                            if (tribe.atWarWith[otherId] === true) {
                                warCount++;
                            }
                        }
                        // War costs are additive: 80% per war (1 war = 1.8x, 2 wars = 2.6x, 3 wars = 3.4x, etc.)
                        if (warCount > 0) {
                            cost *= (1.0 + (warCount * 0.8));
                        }
                    }
                }
                let rigidCount = this.getRigidBondCount();
                if (rigidCount > 0) {
                    cost *= 0.5;
                    if (!this.hasRigidLifespanBonus) {
                        this.maxLifespan = this.baseMaxLifespan * 1.5;
                        this.hasRigidLifespanBonus = true;
                    }
                } else if (this.hasRigidLifespanBonus) {
                    this.maxLifespan = this.baseMaxLifespan;
                    this.hasRigidLifespanBonus = false;
                }
                if (this.structureStability > 0) {
                    this.maxLifespan = Math.max(this.maxLifespan, this.baseMaxLifespan * structureBonus);
                    if (this.health < this.maxHealth) {
                        this.health += 0.02 * (structureBonus - 1) * structureBandFactor;
                    }
                }
                if (this.isGroupEntity) {
                    cost *= Math.max(0.1, CONFIG.groupAgentEnergyCostMult);
                    this.maxLifespan = Math.max(this.maxLifespan, this.baseMaxLifespan * CONFIG.groupAgentLifespanMult);
                }
                if (this.frenzyTimer > 0) { cost *= 2; this.frenzyTimer--; }
                // Garbage Collectors are very energy efficient
                if (this.role === 'Garbage Collector') cost *= 0.3; // 70% reduction
                // Botanists and Farmers eat less food - more energy efficient
                if (this.role === 'Botanist' || this.role === 'Farmer') cost *= 0.5; // 50% reduction - they need less food
                this.energy -= cost;
                if (this.energy > this.maxEnergy) this.energy = this.maxEnergy;

                if (this.energy > 150 && this.health < this.maxHealth && this.role !== 'Monster') {
                    this.energy -= 0.5; this.health += 0.5;
                }

                if (this.energy <= 0 || this.health <= 0) {
                    if (this.carrying) {
                        this.carrying.carrier = null; 
                        this.carrying = null;
                    }
                    this.dead = true;
                    this.breakAllBonds();
                    this.spawnDeathResource();
                    this.spawnDeathFoodBurst();
                    this.spawnGroupAgentBabies(sim);
                    sim.particles.push(new Particle(this.pos.x, this.pos.y, '#fff', 'skull'));
                    sfx.play('death', getHarmonicFreq([HARMONICS.A3, HARMONICS.E4, HARMONICS.A4], 5), 0.3);
                    return;
                }

                this.interact(resources, agents, doExpensiveOps);
                this.attemptGroupAscension();
                if (this.isGroupEntity) {
                    // PERFORMANCE OPTIMIZATION: Very aggressive throttling of expensive group entity operations
                    // Only do these expensive operations every 4-6 frames for group entities
                    let groupEntityCount = (typeof sim !== 'undefined' && sim.agents) ? 
                        sim.agents.filter(a => a.isGroupEntity).length : 0;
                    
                    let throttleInterval = 3; // Default: every 3 frames
                    if (groupEntityCount > 25) {
                        throttleInterval = 6; // Every 6 frames when many group entities
                    } else if (groupEntityCount > 15) {
                        throttleInterval = 4; // Every 4 frames when moderate group entities
                    }
                    
                    let groupEntityUpdateOffset = (typeof sim !== 'undefined' && sim.frame) ? sim.frame % throttleInterval : 0;
                    let agentUpdateOffset = (this.id ? this.id.charCodeAt(0) : 0) % throttleInterval;
                    
                    if (groupEntityUpdateOffset === agentUpdateOffset) {
                        this.cleanupConverterBonds(sim);
                        this.attemptSpawnConverterBonder(sim);
                        this.huntNearbyGroupResources(resources);
                        this.consumeNearbyEnemiesForEnergy(agents);
                    }
                }
                
                this.vel.add(this.acc);
                let speedLimit = this.maxSpeed * (groupBenefits.propulsionBoost || 1);
                if (this.carrying && load > 0) speedLimit *= 0.7; 
                if (this.frenzyTimer > 0) speedLimit *= 1.5;
                if (this.role === 'Monster') speedLimit *= 0.8; 
                
                this.vel.limit(speedLimit);
                this.pos.add(this.vel);
                // Wrap position on torus
                if (typeof sim !== 'undefined') {
                    this.pos.wrap(sim.width, sim.height);
                }
                
                this.resolveCollisions(resources);
                
                this.acc.mult(0);
                this.boundaries();
            }

            wander() {
                let wanderPoint = this.vel.copy();
                wanderPoint.normalize();
                wanderPoint.mult(50); 
                wanderPoint.add(this.pos);
                let wanderRadius = 30;
                
                // Apply movement gene biases (compass directions)
                let geneBias = new Vector(0, 0);
                geneBias.x += (this.dna.move_e - this.dna.move_w) * 0.3;
                geneBias.y += (this.dna.move_s - this.dna.move_n) * 0.3;
                geneBias.x += (this.dna.move_ne - this.dna.move_sw) * 0.21;
                geneBias.y += (this.dna.move_se - this.dna.move_nw) * 0.21;
                geneBias.x += (this.dna.move_se - this.dna.move_nw) * 0.21;
                geneBias.y -= (this.dna.move_ne - this.dna.move_sw) * 0.21;
                
                // WEIGHTED OSCILLATING MOVEMENT PATTERNS (prevents stasis)
                // Update oscillation phase based on cycle speed
                let cycleSpeed = Math.max(1, Math.floor(10 + this.dna.oscillate_cycle_speed * 90)); // 10-100 frames per step
                if (typeof sim !== 'undefined' && sim.frame % cycleSpeed === 0) {
                    this.oscillatePhase = (this.oscillatePhase + 1) % 8; // Cycle through 8 positions
                }
                
                // Get current direction from pattern (0-7 = N,NE,E,SE,S,SW,W,NW) with weight
                let patternDirection = this.dna.oscillate_pattern[this.oscillatePhase];
                let patternWeight = this.dna.oscillate_weights[this.oscillatePhase];
                let oscillateBias = new Vector(0, 0);
                
                // Convert direction to vector (0=N, 1=NE, 2=E, 3=SE, 4=S, 5=SW, 6=W, 7=NW)
                let angle = (patternDirection * Math.PI / 4) - Math.PI / 2; // -90¬∞ offset (N is up)
                oscillateBias.x = Math.cos(angle);
                oscillateBias.y = Math.sin(angle);
                // Apply weight, amplitude, and config strength (all reduced to prevent sticking)
                oscillateBias.mult(patternWeight * this.dna.oscillate_amplitude * CONFIG.oscillatingMovementStrength * 0.5);
                
                // Add drift component to prevent perfect cancellation (always moves slightly forward)
                let driftBias = this.vel.copy().normalize().mult(this.dna.movement_tendency * 0.3);
                
                geneBias.add(oscillateBias);
                geneBias.add(driftBias);
                
                let theta = this.wanderTheta + this.vel.heading();
                let x = wanderRadius * Math.cos(theta);
                let y = wanderRadius * Math.sin(theta);
                wanderPoint.add(new Vector(x, y));
                let steer = wanderPoint.sub(this.pos);
                steer.limit(this.maxForce);
                
                // Apply movement gene bias (scaled by movement_tendency to favor actual movement)
                steer.add(geneBias);
                steer.mult(this.dna.movement_tendency); // Agents with high tendency move more, low oscillate more
                steer.add(this.getMovementPatternBias(steer));
                
                let changeRate = 0.1 + (this.dna.twitch * 0.8);
                this.wanderTheta += (Math.random() - 0.5) * changeRate;
                
                // Curiosity Gene: Wanders further
                if (this.dna.curiosity > 0.7) steer.mult(1.2);

                return steer;
            }

            interact(resources, agents, doExpensiveOps = true) {
                if (this.isConverterUnit) {
                    this.converterInteract(resources);
                    return;
                }
                if (this.isConverterBonder) {
                    this.runConverterBonding(sim, agents);
                    return;
                }
                let localRes = [];
                let localAgents = [];

                this.targetId = null;

                // PERFORMANCE OPTIMIZATION: Skip expensive operations for some agents to maintain smooth updates
                // Always do basic movement, but skip expensive group/combat calculations for some agents
                let effectiveSenseRad = this.senseRad;
                let myGroup = [];
                let myGroupStrength = 0;
                let inGroup = false;
                let combatRange = CONFIG.groupCombatRange || 220;
                let groupBenefits = {
                    rangeBonus: 1.0,
                    gatherRangeBonus: 1.0,
                    conversionBonus: 1.0,
                    healingBonus: 1.0,
                    energyMultiplier: 1.0,
                    propulsionBoost: 1.0
                };
                
                if (doExpensiveOps !== false) {
                // Apply group benefits and gather bond bonus to sensing range
                    groupBenefits = this.getGroupBenefits();
                    effectiveSenseRad = this.senseRad * groupBenefits.rangeBonus * this.gatherRangeBonus * groupBenefits.gatherRangeBonus;
                    
                    myGroup = this.getCachedBondedGroup();
                    myGroupStrength = this.getGroupStrength(myGroup);
                    inGroup = myGroup.length > 1;
                } else {
                    // Lightweight mode: use basic sense radius, no group calculations
                    effectiveSenseRad = this.senseRad * this.gatherRangeBonus;
                }
                
                // PERFORMANCE OPTIMIZATION: Use spatial grid for O(n) distance checks instead of O(n¬≤)
                // Reuse arrays to reduce allocations
                localRes.length = 0;
                localAgents.length = 0;
                if (typeof sim !== 'undefined' && sim.spatialGrid && sim.gridCols > 0) {
                    let nearby = sim.getNearbyEntities(this.pos.x, this.pos.y, effectiveSenseRad);
                    // Reuse arrays instead of creating new ones
                    for (let r of nearby.resources) localRes.push(r);
                    for (let a of nearby.agents) if (a !== this) localAgents.push(a);
                } else {
                    // Fallback to brute force if spatial grid not available
                for (let r of resources) if (Vector.dist(this.pos, r.pos) < effectiveSenseRad) localRes.push(r);
                for (let a of agents) if (a !== this && Vector.dist(this.pos, a.pos) < effectiveSenseRad) localAgents.push(a);
                }

                let forces = {
                    base: new Vector(0,0),
                    food: new Vector(0,0),
                    hunt: new Vector(0,0),
                    flee: new Vector(0,0),
                    social: new Vector(0,0),
                    wander: new Vector(0,0),
                    mine: new Vector(0,0),
                    raid: new Vector(0,0),
                    trade: new Vector(0,0),
                    bond: new Vector(0,0),
                    war: new Vector(0,0) 
                };

                let chaseTarget = null;
                let chaseDist = Infinity;
                let fleeTarget = null;
                let fleeDist = Infinity;
                // Only do expensive combat calculations if doing expensive ops
                if (doExpensiveOps !== false) {
                    for (let enemy of localAgents) {
                        if (!enemy || enemy.dead || enemy.tribeId === this.tribeId || enemy.tribeId === -1) continue;
                        let enemyGroup = enemy.getCachedBondedGroup();
                        let enemyStrength = enemy.getGroupStrength(enemyGroup);
                        if (enemyStrength <= 0) continue;
                        let d = Vector.dist(this.pos, enemy.pos);
                        if (d > combatRange) continue;
                        let enemyInGroup = enemyGroup.length > 1;
                        let ratio = myGroupStrength / (enemyStrength + 0.01);
                        if (inGroup && ratio > 1.2 && d < chaseDist) {
                            chaseTarget = enemy;
                            chaseDist = d;
                        }
                        if ((inGroup && ratio < 0.8) || (!inGroup && enemyInGroup && enemyStrength > myGroupStrength * 1.2)) {
                            if (d < fleeDist) {
                                fleeTarget = enemy;
                                fleeDist = d;
                            }
                        }
                    }
                }
                let active = false;
                if (chaseTarget) {
                    forces.hunt.add(this.seek(chaseTarget.pos).mult(2.4));
                    this.state = "Group Assault";
                    active = true;
                } else if (fleeTarget) {
                    forces.flee.add(this.flee(fleeTarget.pos).mult(2.1));
                    this.state = "Group Evade";
                    active = true;
                }
                let tribeInfo = sim.tribes && sim.tribes.tribes[this.tribeId];
                if (tribeInfo && tribeInfo.leaderUnderAttack && tribeInfo.leaderUnderAttackTargetId && this.tribeId !== -1 && this.id !== tribeInfo.leaderId) {
                    let attacker = sim.agents.find(a => a.id === tribeInfo.leaderUnderAttackTargetId);
                    if (attacker && !attacker.dead) {
                        let distToAttacker = Vector.dist(this.pos, attacker.pos);
                        if (distToAttacker < 400) {
                            forces.hunt.add(this.seek(attacker.pos).mult(2.2));
                            this.state = "Defending Leader";
                            active = true;
                        }
                    } else {
                        tribeInfo.leaderUnderAttack = false;
                        tribeInfo.leaderUnderAttackTargetId = null;
                    }
                }

                this.state = "Wander";
                let hunger = (this.maxEnergy - this.energy) / this.maxEnergy; 
                let isStarving = hunger > 0.7;

                // Nest Logic
                let myNest = sim.tribes.nests.find(n => n.tribeId === this.tribeId);
                let distToNest = myNest ? Vector.dist(this.pos, myNest.pos) : Infinity;
                
                // NEST TETHER (LEADERS/GUARDIANS)
                if (this.tribeId !== -1 && myNest) {
                    let isLeader = sim.tribes.tribes[this.tribeId].leaderId === this.id;
                    if (isLeader || this.role === 'Guardian') {
                        // Leaders/Guardians stay within reasonable radius from nest
                        // Radius is based on nest size plus configurable max wander distance
                        let nestRadius = myNest.radius || 20;
                        let maxWanderRadius = (CONFIG.leaderMaxWanderRadius || 120) + nestRadius;
                        let tether = maxWanderRadius;
                        
                        if (distToNest > tether) {
                            // Stronger pull the further they are from nest
                            let overshoot = distToNest - tether;
                            let k = 0.12; // Stronger tether force (was 0.05)
                            let force = Vector.sub(myNest.pos, this.pos).normalize().mult(overshoot * k);
                            forces.base.add(force);
                            // Stronger dampening when far from nest
                            this.vel.mult(0.90); // More dampening (was 0.95)
                            // Also reduce acceleration to prevent overshoot
                            this.acc.mult(0.8);
                            if (!active) { 
                                this.state = isLeader ? "Returning to Nest" : "Guarding"; 
                                active = true; 
                            }
                        } else if (distToNest > tether * 0.8) {
                            // Gentle pull when getting close to max radius
                            let pullStrength = (distToNest - tether * 0.8) / (tether * 0.2);
                            let k = 0.03 * pullStrength;
                            let force = Vector.sub(myNest.pos, this.pos).normalize().mult(k * 10);
                            forces.base.add(force);
                        }
                    } else if (!inGroup) {
                        // ROAMING BEHAVIOR (for non-leaders/non-guardians)
                        // High roaming gene = wander far, low = stay near nest
                        let roamingStrength = this.dna.roaming * CONFIG.roamingGeneStrength;
                        
                        if (roamingStrength < 0.3) {
                            // Stay near nest
                            let comfortDistance = 200;
                            if (distToNest > comfortDistance) {
                                let k = 0.02;
                                let force = Vector.sub(myNest.pos, this.pos).normalize().mult((distToNest - comfortDistance) * k);
                                forces.base.add(force);
                                this.state = "Returning Home";
                            }
                        } else if (roamingStrength > 0.7) {
                            // Roam freely, return periodically
                            if (this.nextNestReturn === 0) {
                                // Set next return time
                                let minReturn = CONFIG.nestReturnFrequencyMin;
                                let maxReturn = CONFIG.nestReturnFrequencyMax;
                                let returnFreq = minReturn + this.dna.nest_return_frequency * (maxReturn - minReturn);
                                this.nextNestReturn = sim.frame + returnFreq;
                            }
                            
                            if (sim.frame >= this.nextNestReturn) {
                                // Time to return to nest
                                if (distToNest > 100) {
                                    let k = 0.03;
                                    let force = Vector.sub(myNest.pos, this.pos).normalize().mult(k * 20);
                                    forces.base.add(force);
                                    this.state = "Returning to Nest";
                                } else {
                                    // Reached nest, reset timer
                                    this.nextNestReturn = 0;
                                    this.state = "Resting at Nest";
                                }
                            } else {
                                this.state = "Roaming";
                            }
                        }
                    } else {
                        this.state = "Group Roaming";
                        this.nextNestReturn = 0;
                    }

                    // 2. Builder Gathering Override
                    if (this.role === 'Builder' && !this.carrying) {
                        // Look for MAT specifically
                        let bestMat = null;
                        let minDist = Infinity;
                        for (let r of localRes) {
                            if (r.type === 'MAT' && !r.carrier && r.active) {
                                let d = Vector.dist(this.pos, r.pos);
                                if (d < minDist) { minDist = d; bestMat = r; }
                            }
                        }
                        if (bestMat) {
                            forces.food = this.seek(bestMat.pos).mult(3.0);
                            this.state = "Fetching Supply";
                            active = true;
                        }
                    }
                }
                
                // NEST DEFENSE
                if (myNest && sim.tribes.tribes[this.tribeId].underAttack) {
                    forces.base = this.seek(myNest.pos).mult(4.0);
                    this.state = "DEFENDING NEST";
                    active = true;
                }

                // ALLIANCE DEFENSE
                if (!active && myNest) {
                     let allies = Object.keys(sim.tribes.tribes).filter(tid => tid != this.tribeId && sim.tribes.getOpinion(this.tribeId, tid) > 50);
                     for(let allyId of allies) {
                         if (sim.tribes.tribes[allyId].underAttack) {
                             let allyNest = sim.tribes.nests.find(n => n.tribeId == allyId);
                             if (allyNest) {
                                 forces.base = this.seek(allyNest.pos).mult(3.0);
                                 this.state = "Helping Ally";
                                 active = true;
                                 break;
                             }
                         }
                     }
                }

                // ARTISAN: Manufacturing
                if (this.role === 'Artisan' && myNest && distToNest < 100 && this.energy > 80) {
                    if (Math.random() < 0.02) { // Production chance
                        this.energy -= 30;
                        sim.spawnResource(null, this.pos.x + (Math.random()*20-10), this.pos.y + (Math.random()*20-10), 'MAT', false, this.tribeId);
                        sim.particles.push(new Particle(this.pos.x, this.pos.y, '#a5f3fc', 'spark'));
                        this.state = "Manufacturing";
                    }
                }

                // HEALER BEHAVIOR
                if (this.role === 'Healer') {
                    let patient = null;
                    let minHealth = 100;
                    for(let a of localAgents) {
                        if (a.tribeId === this.tribeId && a.health < a.maxHealth * 0.8 && a.health < minHealth) {
                            minHealth = a.health;
                            patient = a;
                        }
                    }
                    if (patient) {
                        forces.social = this.seek(patient.pos).mult(2.0);
                        this.state = "Healing";
                        active = true;
                        if (Vector.dist(this.pos, patient.pos) < 20) {
                            if (this.energy > 20) {
                                this.energy -= 1;
                                patient.health += 2;
                                if (Math.random() < 0.1) sim.particles.push(new Particle(patient.pos.x, patient.pos.y, '#fbcfe8', 'heart'));
                            }
                        }
                    }
                }

                // TEACHER BEHAVIOR
                if (this.role === 'Teacher') {
                    let pupil = localAgents.find(a => a.tribeId === this.tribeId && !a.isAdult());
                    if (pupil) {
                         forces.social = this.seek(pupil.pos).mult(1.5);
                         this.state = "Teaching";
                         active = true;
                         if (Vector.dist(this.pos, pupil.pos) < 30) {
                             pupil.age += 0.5; // Grow faster
                             if (Math.random() < 0.05) pupil.learnSkill('SENSE', 1);
                         }
                    }
                }

                // SCOUT BEHAVIOR - Explore and find resources
                if (this.role === 'Scout' && !this.carrying && !active) {
                    // Scouts actively explore to find resources
                    // They're attracted to areas with resources they haven't seen recently
                    let nearbyResources = localRes.filter(r => 
                        r.active && 
                        !r.carrier &&
                        Vector.dist(this.pos, r.pos) < 200
                    );
                    
                    if (nearbyResources.length > 0) {
                        // Find the most valuable unexplored resource
                        let bestResource = null;
                        let bestValue = -1;
                        for (let r of nearbyResources) {
                            let value = weightedResourceEnergy(r.type) || 10;
                            // Prefer resources further from nest (exploration)
                            let distFromNest = myNest ? Vector.dist(r.pos, myNest.pos) : 0;
                            value += distFromNest / 50; // Bonus for distant resources
                            if (value > bestValue) {
                                bestValue = value;
                                bestResource = r;
                            }
                        }
                        
                        if (bestResource) {
                            forces.food = this.seek(bestResource.pos).mult(1.5);
                            this.state = "Scouting";
                            active = true;
                        }
                    } else {
                        // No nearby resources - explore outward
                        forces.wander = this.wander().mult(2.0);
                        this.state = "Exploring";
                        active = true;
                    }
                }

                // BOTANIST BEHAVIOR - Seek food areas to cultivate
                if (this.role === 'Botanist' && !this.carrying) {
                    // Find nearby food resources to cultivate
                    let foodTargets = localRes.filter(r => 
                        r.type === 'FOOD' && 
                        r.active && 
                        !r.carrier &&
                        Vector.dist(this.pos, r.pos) < 150
                    );
                    
                    if (foodTargets.length > 0) {
                        // Seek the closest food area
                        let closestFood = foodTargets.sort((a, b) => 
                            Vector.dist(this.pos, a.pos) - Vector.dist(this.pos, b.pos)
                        )[0];
                        
                        let foodDist = Vector.dist(this.pos, closestFood.pos);
                        if (foodDist > 40) {
                            // Move toward food areas
                            forces.food = this.seek(closestFood.pos).mult(1.2);
                            this.state = "Seeking Food Area";
                            active = true;
                        }
                    }
                }

                // BUILDER: Nest Fortification Logic (NEW)
                if (this.role === 'Builder' && this.carrying && this.carrying.type === 'MAT' && myNest) {
                    forces.base = this.seek(myNest.pos).mult(2.0);
                    this.state = "Upgrading Nest";
                    active = true;
                    
                    if (distToNest < myNest.radius + 20) {
                        // Build
                        this.carrying.active = false; this.carrying = null;
                        myNest.defenseLevel += 1;
                        myNest.hp += 200;
                        this.learn('build', 0.5);
                        sim.particles.push(new Particle(this.pos.x, this.pos.y, '#a16207', 'spark')); // Dust
                    }
                }

                // Multi-cellular Physics - Elastic vs Rigid Bonds with type-specific benefits
                this.partners = this.partners.filter(p => !p.dead);
                
                // BREAK BONDS WITH ENEMIES - Check if any partners became enemies
                for (let i = this.partners.length - 1; i >= 0; i--) {
                    let p = this.partners[i];
                    if (this.tribeId !== -1 && p.tribeId !== -1 && typeof sim !== 'undefined' && sim.tribes) {
                        let tribe1 = sim.tribes.tribes[this.tribeId];
                        let tribe2 = sim.tribes.tribes[p.tribeId];
                        if (tribe1 && tribe2) {
                            // Break bond if tribes are at war
                            if ((tribe1.atWarWith && tribe1.atWarWith[p.tribeId] === true) ||
                                (tribe2.atWarWith && tribe2.atWarWith[this.tribeId] === true)) {
                                this.removePartner(p);
                                p.removePartner(this);
                                continue;
                            }
                            // Break bond if opinion dropped below hate threshold
                            let opinion = sim.tribes.getOpinion(this.tribeId, p.tribeId);
                            if (opinion < (CONFIG.hateThreshold || -40)) {
                                this.removePartner(p);
                                p.removePartner(this);
                                continue;
                            }
                        }
                    }
                }
                
                // ELASTIC BOND LEADERSHIP - Find strongest member in elastic-bonded groups
                let elasticGroup = this.getCachedBondedGroup();
                let hasElasticBonds = false;
                for (let partner of this.partners) {
                    if (!this.rigidBonds[partner.id]) {
                        hasElasticBonds = true;
                        break;
                    }
                }
                
                let elasticLeader = null;
                if (hasElasticBonds && elasticGroup.length > 1) {
                    // Find strongest member (highest health + energy + stability)
                    let maxStrength = -1;
                    for (let member of elasticGroup) {
                        if (member.dead) continue;
                        let strength = (member.health / member.maxHealth) * 0.4 +
                                      (member.energy / member.maxEnergy) * 0.3 +
                                      (member.structureStability / CONFIG.structureStabilityCap) * 0.3;
                        if (strength > maxStrength) {
                            maxStrength = strength;
                            elasticLeader = member;
                        }
                    }
                }
                
                // MUTUAL REPULSION for rigid bonds to prevent overlap (maintain stable shape)
                this.partners.forEach(p => {
                    let rigidType = this.rigidBonds[p.id];
                    if (rigidType) {
                    let d = Vector.dist(this.pos, p.pos);
                        let minSeparation = this.radius + p.radius + 10; // Minimum comfortable distance
                        
                        if (d < minSeparation && d > 0) {
                            // Repel if too close (prevents overlap)
                            let repulsionStrength = (minSeparation - d) * 0.3;
                            let repulsion = Vector.sub(this.pos, p.pos).normalize().mult(repulsionStrength);
                            forces.bond.add(repulsion);
                        }
                    }
                });
                
                let rigidCount = this.getRigidBondCount();
                this.partners.forEach(p => {
                    let d = Vector.dist(this.pos, p.pos);
                    let rigidType = this.rigidBonds[p.id];
                    
                    // Calculate partner's influence weight based on health and energy (strength)
                    let partnerStrength = 1.0;
                    if (CONFIG.bondInfluenceByStrength) {
                        let healthFactor = p.health / p.maxHealth; // 0-1
                        let energyFactor = Math.min(1.0, p.energy / p.maxEnergy); // 0-1
                        partnerStrength = (healthFactor * 0.6 + energyFactor * 0.4); // Weighted average
                        partnerStrength = Math.max(0.2, partnerStrength); // Minimum 20% influence
                    }
                    
                    // Rigid bonds are harder to break
                    let totalBonds = Math.max(1, this.partners.length);
                    let rigidRatio = (rigidCount / totalBonds);
                    let bandMultiplier = this.structureBandActive ? CONFIG.structureStabilityBandBonus : 1;
                    let stabilityBonus = 1 + this.structureStability * 0.002 * bandMultiplier;
                    // Limit elastic bond length for group agents
                    let maxElasticLength = 150;
                    if ((this.isGroupEntity || (p && p.isGroupEntity)) && !rigidType) {
                        maxElasticLength = CONFIG.groupAgentElasticBondMaxLength || 180;
                    }
                    let breakDist = (rigidType ? 200 : maxElasticLength) + (rigidRatio * 40) * stabilityBonus;
                    let baseResistance = rigidType ? CONFIG.rigidBondBreakResistance : 1.0;
                    let breakResistance = baseResistance * (1 + rigidRatio * 0.75) * stabilityBonus;
                    
                    if (d > breakDist || this.getNetLoyalty(p) < -10 * breakResistance) {
                        this.removePartner(p);
                        p.removePartner(this);
                    } else {
                        if (rigidType) {
                            // Rigid bond: maintain fixed length with strong spring
                            let rigidLength = CONFIG.rigidBondLength;
                            let displacement = d - rigidLength;
                            let k = CONFIG.rigidBondStiffness * partnerStrength; // Weight by strength
                            let force = Vector.sub(p.pos, this.pos).normalize().mult(displacement * k);
                            forces.bond.add(force);
                            // Stronger velocity coupling for rigid bonds, weighted by partner strength
                            this.vel.add(p.vel.copy().mult(0.08 * partnerStrength));
                            
                            // TYPE-SPECIFIC EMERGENT BEHAVIORS
                            if (rigidType === 'shield') {
                                // Shield pairs: increased defense and health regen when close
                                if (d < rigidLength * 1.2) {
                                    if (this.health < this.maxHealth) this.health += 0.15;
                                    // Reduce incoming damage
                                    this.shieldBonus = 0.3; // 30% damage reduction
                                    // Energy efficiency when defending together
                                    if (this.state === "Guarding") {
                                        this.energy += 0.1;
                                    }
                                    // Boost loyalty between shield partners
                                    this.adjustLoyalty(p.id, 0.05);
                                }
                            } else if (rigidType === 'hunt') {
                                // Hunt pairs: synchronized hunting, damage boost when attacking same target
                                if (this.targetId && p.targetId === this.targetId && d < rigidLength * 1.5) {
                                    // Coordinated attack bonus (2x damage when synchronized)
                                    this.huntBonus = 2.0;
                                    this.prefs.hunt = Math.min(3.0, this.prefs.hunt + 0.01);
                                    // Share target detection range
                                    if (p.state === "Hunting") {
                                        this.state = "Hunting";
                                    }
                                } else {
                                    this.huntBonus = 1.0;
                                }
                            } else if (rigidType === 'gather') {
                                // Gather pairs: increased resource detection and carry capacity
                                if (d < rigidLength * 1.2) {
                                    // Share resources more efficiently
                                    if (this.carrying && !p.carrying && p.energy < p.maxEnergy * 0.5) {
                                        if (this.carrying.type === 'FOOD' || this.carrying.type === 'UNIQUE') {
                                            // Quick energy transfer from carrier
                                            p.energy += 0.5;
                                            this.energy -= 0.5;
                                        }
                                    }
                                    // Both gain resource detection bonus
                                    this.gatherRangeBonus = 1.5; // 50% wider detection
                                    // Reduced energy cost when foraging together
                                    if (this.state === "Foraging" && p.state === "Foraging") {
                                        this.energy += 0.05;
                                    }
                                    // Occasionally duplicate resources
                                    if (this.carrying && Math.random() < 0.001) {
                                        let bonus = { ...this.carrying };
                                        bonus.pos = this.pos.copy();
                                        bonus.carrier = null;
                                        sim.resources.push(bonus);
                                    }
                                }
                            } else if (rigidType === 'swift') {
                                // Swift pairs: increased movement speed and coordination
                                if (d < rigidLength * 1.2) {
                                    this.maxSpeed = Math.min(this.baseSpeed * 1.4, this.maxSpeed + 0.01);
                                    // Perfect velocity matching for synchronized movement
                                    this.vel.add(p.vel.copy().mult(0.05));
                                    // Lower energy cost when moving together
                                    if (this.vel.mag() > 0.5 && p.vel.mag() > 0.5) {
                                        this.energy += 0.03;
                                    }
                                    // Shared navigation (if partner sees something, both benefit)
                                    if (p.targetId && !this.targetId) {
                                        this.targetId = p.targetId;
                                    }
                                }
                            }
                        } else {
                            // Elastic bond: flexible spring, weighted by partner strength
                        let idealDist = this.radius + p.radius + 5;
                        let displacement = d - idealDist;
                            let k = 0.05 * partnerStrength; // Weight by strength
                        let force = Vector.sub(p.pos, this.pos).normalize().mult(displacement * k);
                        forces.bond.add(force);
                            this.vel.add(p.vel.copy().mult(0.02 * partnerStrength)); // Weight velocity coupling
                        }
                    }
                });
                
                // ELASTIC BOND LEADERSHIP CONSTRAINT - Prevent members from moving opposite to leader
                if (elasticLeader && elasticLeader !== this && hasElasticBonds) {
                    // Check if this agent has any elastic bonds
                    let hasElasticBond = false;
                    for (let partner of this.partners) {
                        if (!this.rigidBonds[partner.id]) {
                            hasElasticBond = true;
                            break;
                        }
                    }
                    
                    if (hasElasticBond) {
                        // Get leader's movement direction
                        let leaderVel = elasticLeader.vel.copy();
                        if (leaderVel.mag() > 0.1) {
                            leaderVel.normalize();
                            
                            // Get this agent's intended movement direction (from accumulated forces)
                            let myIntendedDir = new Vector(0, 0);
                            for (let key in forces) {
                                if (forces[key] && forces[key].mag) {
                                    myIntendedDir.add(forces[key]);
                                }
                            }
                            
                            if (myIntendedDir.mag() > 0.1) {
                                myIntendedDir.normalize();
                                
                                // Calculate dot product (1 = same direction, -1 = opposite)
                                let dotProduct = leaderVel.x * myIntendedDir.x + leaderVel.y * myIntendedDir.y;
                                
                                // If moving in opposite direction (dot product < -0.3), constrain movement
                                if (dotProduct < -0.3) {
                                    // Project movement onto perpendicular to leader's direction
                                    // This allows movement perpendicular but not opposite
                                    let perpX = -leaderVel.y;
                                    let perpY = leaderVel.x;
                                    
                                    // Project intended direction onto perpendicular
                                    let perpDot = myIntendedDir.x * perpX + myIntendedDir.y * perpY;
                                    let constrainedDir = new Vector(perpX * perpDot, perpY * perpDot);
                                    
                                    // Also allow some movement towards leader (following)
                                    let toLeader = Vector.subTorus(elasticLeader.pos, this.pos, sim.width, sim.height);
                                    if (toLeader.mag() > 0.1) {
                                        toLeader.normalize();
                                        constrainedDir.add(toLeader.mult(0.3));
                                    }
                                    
                                    // Apply constraint to forces - reduce opposite movement
                                    let constraintStrength = Math.abs(dotProduct) * 0.4; // Stronger constraint for more opposite movement
                                    for (let key in forces) {
                                        if (forces[key] && forces[key].mag) {
                                            let oppositeComponent = forces[key].copy();
                                            oppositeComponent.normalize();
                                            let oppDot = oppositeComponent.x * leaderVel.x + oppositeComponent.y * leaderVel.y;
                                            if (oppDot < -0.3) {
                                                // Reduce opposite component
                                                forces[key].mult(1 - constraintStrength);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                
                this.updateStructureStability();
                
                // BONDED GROUP RESOURCE SHARING - Groups pool energy and wealth
                if (this.partners.length > 0 && this.frame % 30 === 0) { // Check every 30 frames
                    let group = this.getBondedGroup();
                    if (group.length > 1) {
                        // Calculate total group resources
                        let totalEnergy = 0;
                        let totalWealth = 0;
                        let groupSize = 0;
                        
                        for (let member of group) {
                            if (!member.dead) {
                                totalEnergy += member.energy;
                                totalWealth += member.wealth;
                                groupSize++;
                            }
                        }
                        
                        if (groupSize > 1) {
                            // Calculate fair share per member
                            let avgEnergy = totalEnergy / groupSize;
                            let avgWealth = totalWealth / groupSize;
                            
                            // Redistribute resources (move towards average, but not instantly)
                            let shareRate = 0.15; // 15% redistribution per cycle
                            
                            for (let member of group) {
                                if (!member.dead) {
                                    // Energy sharing (helps starving members)
                                    if (member.energy < avgEnergy * 0.7 && avgEnergy > 50) { // Only share if group has surplus
                                        let transfer = (avgEnergy - member.energy) * shareRate;
                                        member.energy += transfer;
                                        
                                        // Visual feedback
                                        if (Math.random() < 0.1) {
                                            sim.particles.push(new Particle(member.pos.x, member.pos.y, '#4ade80', 'plus'));
                                        }
                                    }
                                    
                                    // Wealth sharing (less aggressive, for emergencies only)
                                    if (member.wealth < avgWealth * 0.5 && avgWealth > 100) {
                                        let transfer = (avgWealth - member.wealth) * (shareRate * 0.5); // Half rate
                                        member.wealth += transfer;
                                        
                                        // Visual feedback
                                        if (Math.random() < 0.1) {
                                            sim.particles.push(new Particle(member.pos.x, member.pos.y, '#fbbf24', 'coin'));
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                let amPredator = false;
                let amPrey = false;

                if (this.role === 'Monster') {
                    let nearest = null;
                    let dNear = Infinity;
                    for(let a of localAgents) {
                        if (a.role === 'Monster') continue;
                        
                        // Don't attack bonded group members
                        let isInBondedGroup = this.partners.includes(a);
                        if (!isInBondedGroup) {
                            for (let p of this.partners) {
                                if (!p.dead && p.partners.includes(a)) {
                                    isInBondedGroup = true;
                                    break;
                                }
                            }
                        }
                        if (isInBondedGroup) continue;
                        
                        let d = Vector.dist(this.pos, a.pos);
                        if(d < dNear) { dNear = d; nearest = a; }
                    }
                    if(nearest) {
                        forces.hunt = this.seek(nearest.pos).mult(2.0);
                        this.state = "Rampage";
                        if(dNear < this.radius + nearest.radius + 5) {
                            nearest.health -= 10;
                            this.energy += 10; 
                            if(this.energy > this.maxEnergy) this.energy = this.maxEnergy; 
                            
                            // BLOODY PARTICLE SCATTER EFFECTS - Local bloody particles during Monster combat
                            for (let i = 0; i < 5; i++) {
                                let angle = Math.random() * Math.PI * 2;
                                let dist = Math.random() * 15;
                                let particleX = nearest.pos.x + Math.cos(angle) * dist;
                                let particleY = nearest.pos.y + Math.sin(angle) * dist;
                                // Blood particles - red variations with slight scatter
                                let bloodColors = ['#dc2626', '#b91c1c', '#991b1b', '#ef4444'];
                                let bloodColor = bloodColors[Math.floor(Math.random() * bloodColors.length)];
                                sim.particles.push(new Particle(particleX, particleY, bloodColor, 'spark'));
                            }
                            sim.particles.push(new Particle(nearest.pos.x, nearest.pos.y, '#ef4444', 'spark'));
                        }
                    } else {
                        forces.wander = this.wander();
                    }
                    this.applyForce(forces.hunt);
                    this.applyForce(forces.wander);
                    return; 
                }

                // MERCHANT - Enhanced trading with all non-enemy tribes
                if (this.role === 'Merchant') {
                    if (this.carrying) {
                        let tradePartner = null;
                        let closestTrade = Infinity;
                        
                        // Seek merchants from non-enemy tribes (not just carrying merchants)
                        for(let a of localAgents) {
                            if (a.role === 'Merchant' && a.tribeId !== this.tribeId && a.tribeId !== -1) {
                                // Check if tribes are not at war
                                let relation = sim.tribes.getOpinion(this.tribeId, a.tribeId);
                                if (relation > CONFIG.hateThreshold) { // Not enemies
                                let d = Vector.dist(this.pos, a.pos);
                                    // Prioritize partners who are carrying
                                    let priority = a.carrying ? 1.0 : 0.5;
                                    let effectiveD = d / priority;
                                    if (effectiveD < closestTrade) { 
                                        closestTrade = d; 
                                        tradePartner = a; 
                                    }
                                }
                            }
                        }
                        
                        if (tradePartner) {
                            forces.trade = this.seek(tradePartner.pos).mult(2.5);
                            this.state = "Trading";
                            active = true;
                            if (closestTrade < this.radius + tradePartner.radius + 10) {
                                // Commerce transactions can be any exchange
                                let tradeHappened = false;
                                
                                if (this.carrying && tradePartner.carrying) {
                                    // Both have items - swap them
                                let myItem = this.carrying;
                                let theirItem = tradePartner.carrying;
                                this.carrying = theirItem;
                                tradePartner.carrying = myItem;
                                theirItem.carrier = this;
                                myItem.carrier = tradePartner;
                                    tradeHappened = true;
                                } else if (this.carrying && !tradePartner.carrying) {
                                    // Only I have item - give it to them (they'll return the favor later)
                                    tradePartner.carrying = this.carrying;
                                    this.carrying.carrier = tradePartner;
                                    this.carrying = null;
                                    tradeHappened = true;
                                }
                                
                                if (tradeHappened) {
                                    // Trade strengthens relations significantly (faster than decay)
                                    sim.tribes.updateOpinion(this.tribeId, tradePartner.tribeId, 10.0);
                                    sim.tribes.updateOpinion(tradePartner.tribeId, this.tribeId, 10.0);
                                    
                                    // Strengthen commercial bonds between nests
                                    let myTribe = sim.tribes.tribes[this.tribeId];
                                    let theirTribe = sim.tribes.tribes[tradePartner.tribeId];
                                    if (myTribe && theirTribe) {
                                        let oldBond1 = myTribe.commercialBonds[tradePartner.tribeId] || 0;
                                        let oldBond2 = theirTribe.commercialBonds[this.tribeId] || 0;
                                        
                                        myTribe.commercialBonds[tradePartner.tribeId] = Math.min(100, oldBond1 + 8);
                                        theirTribe.commercialBonds[this.tribeId] = Math.min(100, oldBond2 + 8);
                                        
                                        // ECONOMIC BOND FORMATION SOUND - Play when commercial bond reaches threshold
                                        let newBond1 = myTribe.commercialBonds[tradePartner.tribeId];
                                        if (oldBond1 < 10 && newBond1 >= 10) {
                                            // New economic bond formed
                                            sfx.play('bond', getHarmonicFreq([HARMONICS.A4, HARMONICS.C5, HARMONICS.E5, HARMONICS.G5], 10), 0.12); // Commercial/trade sound (harmonic)
                                        }
                                    }
                                    
                                    // Both merchants gain wealth from trade
                                    this.wealth += 5;
                                    tradePartner.wealth += 5;
                                    this.energy += 10;
                                    tradePartner.energy += 10;
                                    
                                    // Enhanced trade VFX
                                    sim.particles.push(new Particle(this.pos.x, this.pos.y, '#fbbf24', 'dollar'));
                                    sim.particles.push(new Particle(tradePartner.pos.x, tradePartner.pos.y, '#fbbf24', 'dollar'));
                                    sim.particles.push(new Particle((this.pos.x + tradePartner.pos.x)/2, (this.pos.y + tradePartner.pos.y)/2, '#22d3ee', 'star')); 
                            }
                            }
                        } else {
                            // Wander toward other nests to find trading opportunities
                            if (Math.random() < 0.3) {
                                let targetNest = null;
                                let closestNest = Infinity;
                                for (let nest of sim.tribes.nests) {
                                    if (nest.tribeId !== this.tribeId) {
                                        let relation = sim.tribes.getOpinion(this.tribeId, nest.tribeId);
                                        if (relation > CONFIG.hateThreshold) { // Not enemies
                                            let d = Vector.dist(this.pos, nest.pos);
                                            if (d < closestNest) {
                                                closestNest = d;
                                                targetNest = nest;
                                            }
                                        }
                                    }
                                }
                                if (targetNest) {
                                    forces.wander = this.seek(targetNest.pos).mult(0.8);
                        } else {
                            forces.wander = this.wander().mult(1.5);
                                }
                            } else {
                                forces.wander = this.wander().mult(1.5);
                            }
                        }
                    } else {
                        if (myNest && distToNest < 100) {
                            let exportItem = null;
                            for(let r of localRes) {
                                if (!r.carrier && r.active && (r.type === 'FOOD' || r.type === 'MAT')) {
                                    exportItem = r;
                                    break; 
                                }
                            }
                            if (exportItem) {
                                forces.food = this.seek(exportItem.pos); 
                                if (Vector.dist(this.pos, exportItem.pos) < this.radius + exportItem.config.radius) {
                                    exportItem.carrier = this;
                                    this.carrying = exportItem;
                                }
                            }
                        } else if (myNest) {
                            forces.base = this.seek(myNest.pos);
                        }
                    }
                }

                // ARTISAN & MANUFACTURE
                let canManufacture = this.role === 'Artisan' || this.skills.MANUFACTURE > 0;
                if (canManufacture) {
                    let cost = this.role === 'Artisan' ? 100 : 150 - (this.skills.MANUFACTURE * 10);
                    if (this.carrying && this.carrying.type === 'MAT' && this.energy > cost + 50) {
                        this.carrying.active = false; 
                        sim.spawnResource(null, this.pos.x, this.pos.y, 'TREASURE', false, this.tribeId);
                        this.carrying = null;
                        this.energy -= cost;
                        this.charisma += 1; 
                        this.wealth += 10;
                    }
                    if (this.skills.MANUFACTURE > 0 && Math.random() < 0.001 * this.skills.MANUFACTURE) {
                         sim.spawnResource(null, this.pos.x, this.pos.y, 'MAT', false, this.tribeId);
                    }
                }

                // MINER
                if (this.role === 'Miner') {
                    let target = null;
                    let dTarget = Infinity;
                    let searchPool = localRes.length > 0 ? localRes : resources;
                    for(let r of searchPool) {
                        if((r.type === 'MAT' || r.type === 'ORE') && !r.carrier && r.active) {
                            let d = Vector.dist(this.pos, r.pos);
                            if (d < dTarget) { dTarget = d; target = r; }
                        }
                    }
                    if(target) {
                        forces.mine = this.seek(target.pos).mult(1.5);
                        this.state = "Mining";
                        active = true;
                        if(dTarget < 20) {
                            target.active = false; 
                            let val = target.type === 'ORE' ? 30 : 5;
                            this.energy += 30;
                            this.wealth += val;
                            if(this.energy > this.maxEnergy) this.energy = this.maxEnergy;
                            sim.particles.push(new Particle(target.pos.x, target.pos.y, target.type === 'ORE' ? '#94a3b8' : '#facc15', 'spark'));
                        }
                    }
                }

                // WAR COMBAT - All agents hunt and fight enemy agents during war
                if (this.tribeId !== -1 && typeof sim !== 'undefined' && sim.tribes) {
                    let myTribe = sim.tribes.tribes[this.tribeId];
                    if (myTribe && myTribe.atWarWith) {
                        // Check if tribe is at war with anyone
                        let atWar = false;
                        let enemyTribeIds = [];
                        for (let otherId in myTribe.atWarWith) {
                            if (myTribe.atWarWith[otherId] === true) {
                                atWar = true;
                                enemyTribeIds.push(otherId);
                            }
                        }
                        
                        if (atWar && enemyTribeIds.length > 0) {
                            // Find nearby enemy agents to fight
                            let enemyTarget = null;
                            let minEnemyDist = Infinity;
                            
                            for (let a of localAgents) {
                                // Only target agents from enemy tribes (not food chain agents)
                                // Compare tribe IDs properly (handle both string and number)
                                if (a.tribeId !== -1 && !a.dead) {
                                    let isEnemy = false;
                                    for (let enemyId of enemyTribeIds) {
                                        // Compare as both string and number to handle type mismatches
                                        if (a.tribeId == enemyId || a.tribeId.toString() === enemyId.toString()) {
                                            isEnemy = true;
                                            break;
                                        }
                                    }
                                    if (isEnemy) {
                                        let d = Vector.distTorus(this.pos, a.pos, sim.width, sim.height);
                                        if (d < minEnemyDist && d < 200) { // Combat range: 200
                                            minEnemyDist = d;
                                            enemyTarget = a;
                                        }
                                    }
                                }
                            }
                            
                            if (enemyTarget) {
                                // Hunt enemy agent - add to forces object
                                forces.war.add(this.seek(enemyTarget.pos).mult(1.5));
                                this.state = "Fighting";
                                active = true;
                                
                                // Ranged attack if possible
                                if (minEnemyDist < 150 && this.shootCooldown <= 0) {
                                    sim.projectiles.push(new Projectile(this.pos.x, this.pos.y, enemyTarget, this));
                                    this.shootCooldown = 40; // Slightly longer cooldown for non-combat roles
                                }
                                
                                // Melee combat
                                if (minEnemyDist < this.radius + enemyTarget.radius + 5) {
                                    // All agents can fight during war, but less effectively than combat roles
                                    let damage = (this.role === 'Soldier' || this.role === 'Guardian') ? 5 : 2;
                                    enemyTarget.health -= damage;
                                    enemyTarget.energy -= damage * 2;
                                    
                                    // War fighting deteriorates relations
                                    if (Math.random() < 0.1 && enemyTarget.tribeId !== -1) {
                                        sim.tribes.updateOpinion(enemyTarget.tribeId, this.tribeId, -1);
                                        sim.tribes.updateOpinion(this.tribeId, enemyTarget.tribeId, -0.5);
                                    }
                                    
                                    sim.particles.push(new Particle(enemyTarget.pos.x, enemyTarget.pos.y, '#dc2626', 'spark'));
                                }
                            }
                        }
                    }
                }

                // RAIDER & SOLDIER Aggression - TARGET NON-ALLIED TRIBES!
                if (this.role === 'Raider' || this.role === 'Soldier' || this.role === 'Guardian') {
                    let target = null;
                    let minDist = Infinity;
                    let bestTarget = null;
                    let bestScore = -Infinity;
                    
                    // STRATEGIC TARGETING: Prioritize non-allied, disliked, and at-war tribes
                    for (let enemyNest of sim.tribes.nests) {
                        if (enemyNest.tribeId === this.tribeId) continue;
                        
                        let myTribe = sim.tribes.tribes[this.tribeId];
                        if (!myTribe) continue; // Safety check for food chain agents or missing tribes
                        
                        let relation = sim.tribes.getOpinion(this.tribeId, enemyNest.tribeId) || 0;
                        let dipBond = myTribe.diplomaticBonds[enemyNest.tribeId] || 0;
                        let comBond = myTribe.commercialBonds[enemyNest.tribeId] || 0;
                        let atWar = myTribe.atWarWith[enemyNest.tribeId] || false;
                        
                        // Skip allied tribes (strong bonds)
                        if (dipBond > 40 || comBond > 40) continue;
                        
                        let distance = Vector.dist(this.pos, enemyNest.pos);
                        
                        // Calculate target priority score
                        let score = 0;
                        
                        // 1. Prioritize at-war tribes (highest priority)
                        if (atWar) score += 1000;
                        
                        // 2. Prioritize disliked tribes (negative relations)
                        if (relation < 0) score += Math.abs(relation) * 5; // More dislike = higher priority
                        
                        // 3. Prioritize neutral/unknown tribes (no bonds)
                        if (dipBond === 0 && comBond === 0 && relation <= 10) score += 50;
                        
                        // 4. Prioritize wealthy nests (plunder opportunity!)
                        score += enemyNest.wealth / 10;
                        
                        // 5. Prefer closer targets (distance penalty)
                        score -= distance / 10;
                        
                        // 6. Raiders especially target weak, wealthy nests
                        if (this.role === 'Raider') {
                            score += (enemyNest.wealth / enemyNest.hp) * 100; // wealth-to-hp ratio
                        }
                        
                        if (score > bestScore) {
                            bestScore = score;
                            bestTarget = enemyNest;
                            minDist = distance;
                        }
                    }
                    
                    target = bestTarget;

                    if (target) {
                        // Soldier attacks nests even harder
                        let forceMult = this.role === 'Soldier' ? 3.0 : 2.5;
                        forces.raid = this.seek(target.pos instanceof Vector ? target.pos : target.pos).mult(forceMult); 
                        this.state = "Sieging";
                        active = true;
                        
                        if (minDist < this.radius + (target.radius || 20)) {
                            if (target instanceof Nest) {
                                // Attack nest - defense level reduces damage
                                let baseDamage = (this.role === 'Soldier' ? 8 : 5);
                                // Defense reduces damage: each defense level reduces damage by 15% (max 75% reduction at DEF 5+)
                                let defenseReduction = Math.min(0.75, target.defenseLevel * 0.15);
                                let damage = baseDamage * (1.0 - defenseReduction);
                                target.hp -= damage;
                                sim.tribes.tribes[target.tribeId].underAttack = true; // TRIGGER DEFENSE
                                sim.particles.push(new Particle(target.pos.x, target.pos.y, '#ef4444', 'spark'));
                                
                                // ATTACKING DETERIORATES RELATIONS!
                                if (Math.random() < 0.3) { // 30% chance per attack
                                    sim.tribes.updateOpinion(target.tribeId, this.tribeId, -2); // Victim dislikes attacker
                                    sim.tribes.updateOpinion(this.tribeId, target.tribeId, -0.5); // Attacker also becomes more hostile
                                }
                            }
                        } else if (distToNest < 150 && this.shootCooldown <= 0) {
                            // Ranged Attack
                            sim.projectiles.push(new Projectile(this.pos.x, this.pos.y, target, this));
                            this.shootCooldown = 30;
                        }
                    } else {
                        // If no nest, hunt agents
                        for(let a of localAgents) {
                            if (a.tribeId !== this.tribeId && a.tribeId !== -1) {
                                let d = Vector.dist(this.pos, a.pos);
                                if (d < minDist) { minDist = d; target = a; }
                            }
                        }
                        if (target) {
                            forces.raid = this.seek(target.pos).mult(2.0);
                            this.state = "Raiding";
                            active = true;
                            if (minDist < 150 && this.shootCooldown <= 0) {
                                sim.projectiles.push(new Projectile(this.pos.x, this.pos.y, target, this));
                                this.shootCooldown = 30;
                            }
                            
                            if (minDist < this.radius + target.radius + 5) {
                                // Steal wealth
                                let steal = Math.min(target.wealth, (this.role === 'Raider' ? 50 : 10)); // Raiders steal huge amounts
                                target.wealth -= steal;
                                this.wealth += steal;
                                target.energy -= 10;
                                this.energy += 10;
                                sim.particles.push(new Particle(target.pos.x, target.pos.y, '#a855f7', 'spark'));
                                
                                // RAIDING DETERIORATES RELATIONS!
                                if (Math.random() < 0.2 && target.tribeId !== -1 && this.tribeId !== -1) {
                                    sim.tribes.updateOpinion(target.tribeId, this.tribeId, -3); // Victim strongly dislikes raider
                                    sim.tribes.updateOpinion(this.tribeId, target.tribeId, -1); // Raider becomes more hostile
                                }
                            }
                        } else {
                            forces.wander = this.wander().mult(1.5);
                        }
                    }
                }

                // GARBAGE COLLECTOR BEHAVIOR
                if (this.role === 'Garbage Collector') {
                    // Hunt for orphaned resources from dead tribes
                    let garbageResources = localRes.filter(r => {
                        // Resources without carrier that don't belong to my tribe
                        if (r.carrier || !r.active) return false;
                        // Check if resource is near any active nest
                        let nearMyNest = false;
                        for (let nest of sim.tribes.nests) {
                            if (nest.tribeId === this.tribeId && Vector.dist(r.pos, nest.pos) < 100) {
                                nearMyNest = true;
                                break;
                            }
                        }
                        // Collect anything not near my own nest
                        return !nearMyNest && (r.type === 'MAT' || r.type === 'ORE' || r.type === 'TREASURE' || r.type === 'STIM' || r.type === 'HERB');
                    });
                    
                    if (garbageResources.length > 0) {
                        // Find closest garbage
                        let closest = garbageResources.sort((a, b) => 
                            Vector.dist(this.pos, a.pos) - Vector.dist(this.pos, b.pos)
                        )[0];
                        
                        let d = Vector.dist(this.pos, closest.pos);
                        if (d < this.radius + closest.config.radius) {
                            // Collect garbage
                            closest.active = false;
                            this.energy += 10; // Small energy boost
                            
                            // RECYCLE: 20% chance to shit out valuable material
                            if (Math.random() < 0.2) {
                                let recycledTypes = ['MAT', 'ORE', 'TREASURE'];
                                let recycled = recycledTypes[Math.floor(Math.random() * recycledTypes.length)];
                                sim.spawnResource(null, this.pos.x + (Math.random()*20-10), this.pos.y + (Math.random()*20-10), recycled, false, this.tribeId);
                                sim.particles.push(new Particle(this.pos.x, this.pos.y, '#a3e635', 'spark'));
                                sfx.play('trade', 380, 0.08);
                            }
                            
                            this.state = "Recycling";
                            active = true;
                        } else {
                            // Seek garbage
                            forces.food.add(this.seek(closest.pos).mult(2.5));
                            this.state = "Collecting Garbage";
                            active = true;
                        }
                    }
                }
                
                // FARMER BEHAVIOR
                if (this.role === 'Farmer') {
                    // Initialize spawn timer if not set
                    if (this.nextGrazerSpawn === 0) {
                        this.nextGrazerSpawn = sim.frame + 10;
                    }
                    
                    // Farmers spawn 1 grazer every 10 steps (if they have enough energy)
                    if (sim.frame >= this.nextGrazerSpawn && this.energy > 50) {
                        // Spawn a grazer nearby
                        let spawnX = this.pos.x + (Math.random() * 60 - 30);
                        let spawnY = this.pos.y + (Math.random() * 60 - 30);
                        
                        // Create grazer DNA
                        let grazerDna = {
                            grazer_gene: 0.9,
                            speed: 0.5 + Math.random() * 0.3,
                            size: 0.4 + Math.random() * 0.2,
                            sociability: 0.7 + Math.random() * 0.3
                        };
                        
                        let grazer = new Agent(spawnX, spawnY, grazerDna, null, -1);
                        grazer.role = 'Grazer';
                        grazer.isGrazer = true;
                        sim.agents.push(grazer);
                        
                        this.energy -= 30;
                        sim.particles.push(new Particle(this.pos.x, this.pos.y, '#84cc16', 'leaf'));
                        sfx.play('birth', HARMONICS.A4, 0.1); // Harmonic birth tone
                        this.state = "Spawning Grazer";
                        
                        // Schedule next spawn in 10 steps
                        this.nextGrazerSpawn = sim.frame + 10;
                    }
                    
                    // Aggressively attack predators
                    let nearbyPredators = localAgents.filter(a => a.isPredator && !a.dead);
                    if (nearbyPredators.length > 0) {
                        let closest = nearbyPredators.sort((a, b) => 
                            Vector.dist(this.pos, a.pos) - Vector.dist(this.pos, b.pos)
                        )[0];
                        
                        forces.hunt.add(this.seek(closest.pos).mult(3.0));
                        this.state = "Protecting Prey";
                        active = true;
                        
                        let d = Vector.dist(this.pos, closest.pos);
                        if (d < this.radius + closest.radius + 5) {
                            let damage = CONFIG.damageRate * 200; // Strong attack
                            closest.health -= damage;
                            markLeaderUnderAttack(closest, this);
                            sim.particles.push(new Particle(closest.pos.x, closest.pos.y, '#dc2626', 'blood'));
                            // Sound handled by throttled system in update() - no direct call here
                        }
                    }
                }
                
                // SOLDIER BEHAVIOR - Defend nest, kill enemies, attack enemy nests
                if (this.role === 'Soldier' && myNest) {
                    // TRIBE SUSTENANCE - Soldiers sustained by tribe wealth (MUCH CHEAPER NOW!)
                    if (this.energy < 60 && myNest.wealth > 5) {
                        this.energy += 3; // Sustained by tribe
                        myNest.wealth -= 0.2; // Reduced from 1.5 to 0.2 (87% cost reduction!)
                    }
                    // Die faster if tribe is poor
                    if (myNest.wealth < 20) { // Lowered threshold from 50 to 20
                        this.health -= 0.8; // Faster starvation than diplomats
                    }
                    
                    // DEFEND NEST - Stay near nest when not engaging enemies
                    let distToNest = Vector.dist(this.pos, myNest.pos);
                    if (distToNest > 200 && !active) {
                        forces.social.add(this.seek(myNest.pos).mult(1.0));
                        this.state = "Patrolling";
                    }
                    
                    // DEFEND SPECIALISTS - Protect diplomats, merchants, artisans, teachers, scientists from same tribe AND LINKED TRIBES
                    let protectTargets = localAgents.filter(a => {
                        if (a.dead) return false;
                        
                        // Always protect same tribe specialists
                        if (a.tribeId === this.tribeId && 
                            (a.role === 'Diplomat' || a.role === 'Merchant' || a.role === 'Artisan' || 
                             a.role === 'Teacher' || a.role === 'Scientist')) {
                            return true;
                        }
                        
                        // Also protect specialists from LINKED (allied) tribes
                        if (a.tribeId !== this.tribeId && 
                            (a.role === 'Diplomat' || a.role === 'Merchant' || a.role === 'Artisan' || 
                             a.role === 'Teacher' || a.role === 'Scientist')) {
                            let myTribe = sim.tribes.tribes[this.tribeId];
                            if (!myTribe) return false;
                            
                            // Check diplomatic OR commercial bonds
                            let diploBond = myTribe.diplomaticBonds[a.tribeId] || 0;
                            let commBond = myTribe.commercialBonds[a.tribeId] || 0;
                            
                            // Defend if strong link (bonds > 40)
                            return diploBond > 40 || commBond > 40;
                        }
                        
                        return false;
                    });
                    
                    if (protectTargets.length > 0) {
                        // Find threatened diplomats/merchants
                        for (let target of protectTargets) {
                            let nearbyThreats = localAgents.filter(e => {
                                if (e.dead || e.tribeId === this.tribeId) return false;
                                let loyalty = this.getNetLoyalty(e);
                                return loyalty < -20 && Vector.dist(target.pos, e.pos) < 100;
                            });
                            
                            if (nearbyThreats.length > 0) {
                                // Move to protect
                                forces.social.add(this.seek(target.pos).mult(2.0));
                                this.state = "Protecting Diplomat/Merchant";
                                active = true;
                                break;
                            }
                        }
                    }
                    
                    // ATTACK ENEMIES - Find and engage enemies (LIMITED RANGE for performance)
                    if (!active) {
                        // Limit combat search range to 180 (reduced from sense radius) for performance during war
                        const combatRange = CONFIG.groupCombatRange || 180;
                        let combatLocalAgents = [];
                        if (typeof sim !== 'undefined' && sim.spatialGrid && sim.gridCols > 0) {
                            let nearby = sim.getNearbyEntities(this.pos.x, this.pos.y, combatRange);
                            combatLocalAgents = nearby.agents.filter(a => a !== this && !a.dead);
                        } else {
                            // Fallback: filter from localAgents by distance
                            combatLocalAgents = localAgents.filter(a => Vector.dist(this.pos, a.pos) < combatRange);
                        }
                        
                        // Dynamically reduce range if many wars are active
                        let effectiveCombatRange = combatRange;
                        if (typeof sim !== 'undefined' && sim.tribes && sim.tribes.activeWars > 2) {
                            effectiveCombatRange = combatRange * 0.7; // Reduce by 30% when many wars
                            // Re-filter with reduced range
                            combatLocalAgents = combatLocalAgents.filter(a => Vector.dist(this.pos, a.pos) < effectiveCombatRange);
                        }
                        
                        let enemies = combatLocalAgents.filter(other => {
                            if (other.dead || other === this) return false;
                            if (this.partners.includes(other)) return false;
                            
                            // Quick war check first (cheaper than loyalty calculation)
                            if (this.tribeId !== -1 && other.tribeId !== -1 && typeof sim !== 'undefined' && sim.tribes.isAtWar(this.tribeId, other.tribeId)) {
                                return true;
                            }
                            
                            // Only check loyalty if not at war (expensive calculation)
                            let loyalty = this.getNetLoyalty(other);
                            return loyalty < -30;
                        });
                        
                        if (enemies.length > 0) {
                            let closest = enemies.sort((a, b) => 
                                Vector.dist(this.pos, a.pos) - Vector.dist(this.pos, b.pos)
                            )[0];
                            
                            let d = Vector.dist(this.pos, closest.pos);
                            
                            // RANGED COMBAT - Shoot if in range and cooldown ready
                            if (d > 50 && d < CONFIG.rangedCombatRange && this.canShootRanged) {
                                if (!this.rangedCombatCooldown) this.rangedCombatCooldown = 0;
                                
                                if (this.rangedCombatCooldown <= 0 && Math.random() < CONFIG.rangedCombatChance) {
                                    // FIRE PROJECTILE!
                                    sim.projectiles.push(new Projectile(
                                        this.pos.x, 
                                        this.pos.y, 
                                        closest.pos.x, 
                                        closest.pos.y, 
                                        this, 
                                        CONFIG.rangedCombatDamage, 
                                        'arrow'
                                    ));
                                    this.rangedCombatCooldown = CONFIG.rangedCombatCooldown;
                                    this.state = "Shooting Enemy";
                                    active = true;
                                    
                                    // MORE VISIBLE VFX for ranged attacks
                                    sim.particles.push(new Particle(this.pos.x, this.pos.y, '#fbbf24', 'spark'));
                                    // Sound handled by throttled system in update() - no direct call here
                                }
                            }
                            
                            // Move towards enemy
                            forces.hunt.add(this.seek(closest.pos).mult(2.5));
                            if (!active) this.state = "Engaging Enemy";
                            active = true;
                            
                            // Melee combat (close range)
                            if (d < this.radius + closest.radius + 5) {
                                let damage = CONFIG.damageRate * 100; // Strong damage
                                closest.health -= damage;
                                markLeaderUnderAttack(closest, this);
                                sim.particles.push(new Particle(closest.pos.x, closest.pos.y, '#dc2626', 'blood'));
                                // Sound handled by throttled system in update() - no direct call here
                                
                                // DETERIORATE RELATIONS when attacking
                                if (this.tribeId !== -1 && closest.tribeId !== -1 && this.tribeId !== closest.tribeId) {
                                    sim.tribes.updateOpinion(this.tribeId, closest.tribeId, -1.5); // Aggressor dislikes victim more
                                    sim.tribes.updateOpinion(closest.tribeId, this.tribeId, -3); // Victim REALLY dislikes aggressor
                                }
                            }
                        }
                    }
                    
                    // Decrement ranged combat cooldown
                    if (this.rangedCombatCooldown > 0) this.rangedCombatCooldown--;
                }
                
                // MINER BEHAVIOR - Solo resource hunters seeking dense clusters
                if (this.role === 'Miner') {
                    // Miners are solo actors - seek ALL types of resources for their tribe
                    if (!this.carrying && !active) {
                        let valuableResources = localRes.filter(r => 
                            r.active && !r.carrier && 
                            (r.type === 'MAT' || r.type === 'ORE' || r.type === 'TREASURE' || r.type === 'UNIQUE' || r.type === 'FOOD')
                        );
                        
                        if (valuableResources.length > 0) {
                            // DENSITY-BASED SEEKING: Find areas with highest resource density
                            let bestTarget = null;
                            let bestScore = -1;
                            
                            for (let resource of valuableResources.slice(0, 10)) { // Sample top 10 closest
                                let density = 0;
                                // Count nearby resources within 100px radius
                                for (let other of valuableResources) {
                                    if (Vector.dist(resource.pos, other.pos) < 100) {
                                        density++;
                                    }
                                }
                                
                                let distance = Vector.dist(this.pos, resource.pos);
                                // Score = density / distance (prefer dense + close)
                                let score = density / Math.max(10, distance);
                                
                                if (score > bestScore) {
                                    bestScore = score;
                                    bestTarget = resource;
                                }
                            }
                            
                            if (bestTarget) {
                                let d = Vector.dist(this.pos, bestTarget.pos);
                                if (d < this.radius + bestTarget.config.radius) {
                                    // Pick up resource
                                    this.carrying = bestTarget;
                                    bestTarget.carrier = this;
                                    this.state = "Mining Resources";
                                    active = true;
                                } else {
                                    // Seek densest cluster
                                    forces.food.add(this.seek(bestTarget.pos).mult(2.5));
                                    this.state = "Seeking Resource Cluster";
                                    active = true;
                                }
                            }
                        }
                    }
                    
                    // Return to nest with resources
                    if (this.carrying && myNest) {
                        let distToNest = Vector.dist(this.pos, myNest.pos);
                        if (distToNest > myNest.radius) {
                            forces.social.add(this.seek(myNest.pos).mult(2.0));
                            this.state = "Delivering Resources";
                            active = true;
                        } else {
                            // Drop off at nest
                            let resourceValue = this.carrying.config.val || 10;
                            this.carrying.active = false;
                            this.carrying.carrier = null;
                            this.carrying = null;
                            myNest.wealth += resourceValue * 5; // Miners contribute 5√ó resource value (MASSIVE INCREASE!)
                            sim.particles.push(new Particle(myNest.pos.x, myNest.pos.y, '#ea580c', 'spark'));
                            sim.particles.push(new Particle(myNest.pos.x + 10, myNest.pos.y, '#fbbf24', 'coin')); // Extra VFX
                        }
                    }
                }
                
                // GARBAGE COLLECTOR BEHAVIOR - Clean up dead tribe resources, seek dense clusters
                if (this.role === 'Garbage Collector') {
                    if (!this.carrying && !active) {
                        // Look for orphaned resources from OTHER TRIBES (not own tribe)
                        let garbageResources = localRes.filter(r => {
                            if (!r.active || r.carrier) return false;
                            if (r.type === 'FOOD') return false; // Don't collect food
                            
                            // Check if resource is from a different (dead or existing) tribe
                            if (r.nestId !== undefined && r.nestId !== this.tribeId) {
                                return true; // Garbage from other tribes
                            }
                            
                            // Also collect resources that have no tribe association
                            return r.nestId === undefined;
                        });
                        
                        if (garbageResources.length > 0) {
                            // DENSITY-BASED SEEKING: Find areas with highest garbage density
                            let bestTarget = null;
                            let bestScore = -1;
                            
                            let sampled = garbageResources.slice(0, 10); // Sample closest 10
                            for (let resource of sampled) {
                                let density = 0;
                                // Count nearby garbage within 120px radius
                                for (let other of garbageResources) {
                                    if (Vector.dist(resource.pos, other.pos) < 120) {
                                        density++;
                                    }
                                }
                                
                                let distance = Vector.dist(this.pos, resource.pos);
                                // Score = density / distance (prefer dense + close)
                                let score = density / Math.max(10, distance);
                                
                                if (score > bestScore) {
                                    bestScore = score;
                                    bestTarget = resource;
                                }
                            }
                            
                            let closest = bestTarget || garbageResources[0];
                            
                            let d = Vector.dist(this.pos, closest.pos);
                            if (d < this.radius + closest.config.radius) {
                                // Collect garbage
                                this.carrying = closest;
                                closest.carrier = this;
                                this.state = "Collecting Garbage";
                                active = true;
                                
                                // RECYCLE: 20% chance to convert to useful resource
                                if (Math.random() < CONFIG.garbageRecycleChance) {
                                    closest.active = false;
                                    this.carrying = null;
                                    
                                    // Spawn recycled resource (silver, ore, mat)
                                    let recycledTypes = ['MAT', 'ORE', 'TREASURE'];
                                    let recycledType = recycledTypes[Math.floor(Math.random() * recycledTypes.length)];
                                    sim.spawnResource(null, this.pos.x, this.pos.y, recycledType, false, this.tribeId);
                                    
                                    sim.particles.push(new Particle(this.pos.x, this.pos.y, '#22c55e', 'spark'));
                                    sfx.play('collect', HARMONICS.C5, 0.1);
                                }
                            } else {
                                // Seek garbage
                                forces.food.add(this.seek(closest.pos).mult(1.8));
                                this.state = "Seeking Garbage";
                                active = true;
                            }
                        }
                    }
                    
                    // Energy efficiency: GCs burn less energy
                    if (this.energy > 0) {
                        this.energy += (CONFIG.energyBurnRate * (1 - CONFIG.garbageCollectorEnergyEfficiency)); // Compensate for burn
                    }
                }
                
                // PREDATOR BEHAVIOR - Avoid farmers, hunt prey/grazers
                if (this.isPredator) {
                    // PREDATORS AVOID FARMERS (they are dangerous)
                    let nearbyFarmers = localAgents.filter(a => a.role === 'Farmer' && !a.dead);
                    if (nearbyFarmers.length > 0) {
                        let closestFarmer = nearbyFarmers.sort((a, b) => 
                            Vector.dist(this.pos, a.pos) - Vector.dist(this.pos, b.pos)
                        )[0];
                        let farmerDist = Vector.dist(this.pos, closestFarmer.pos);
                        
                        if (farmerDist < 200) { // Fear radius
                            // Flee from farmer
                            forces.flee.add(Vector.sub(this.pos, closestFarmer.pos).normalize().mult(2.5));
                            this.state = "Avoiding Farmer";
                            active = true;
                        }
                    }
                    
                    // Hunt prey/grazers (but not if near farmer)
                    if (!active) {
                        let targets = localAgents.filter(a => (a.isPrey || a.isGrazer) && !a.dead);
                        // Filter out prey protected by farmers
                        targets = targets.filter(target => {
                            let protectedByFarmer = false;
                            for (let partner of target.partners) {
                                if (partner.role === 'Farmer' && !partner.dead) {
                                    protectedByFarmer = true;
                                    break;
                                }
                            }
                            // Also check if farmer is nearby
                            let farmerNearby = localAgents.some(a => 
                                a.role === 'Farmer' && 
                                Vector.dist(a.pos, target.pos) < 100
                            );
                            return !protectedByFarmer && !farmerNearby;
                        });
                        
                        if (targets.length > 0) {
                            let closest = targets.sort((a, b) => 
                                Vector.dist(this.pos, a.pos) - Vector.dist(this.pos, b.pos)
                            )[0];
                            
                            forces.hunt.add(this.seek(closest.pos).mult(2.0 * CONFIG.predatorPackBonus * (this.partners.length + 1)));
                            this.state = "Hunting";
                            active = true;
                            
                            let d = Vector.dist(this.pos, closest.pos);
                            if (d < this.radius + closest.radius + 5) {
                                let damage = CONFIG.damageRate * 150;
                                closest.health -= damage;
                                markLeaderUnderAttack(closest, this);
                                this.energy += 50; // Gain energy from kill
                                sim.particles.push(new Particle(closest.pos.x, closest.pos.y, '#dc2626', 'blood'));
                                // Sound handled by throttled system in update() - no direct call here
                            }
                        }
                    }
                }
                
                // PREY BEHAVIOR - Seek DENSE food areas, evade predators, reproduce more with food
                if (this.isPrey) {
                    // Evade predators (PRIORITY #1)
                    let nearbyPredators = localAgents.filter(a => a.isPredator && !a.dead);
                    if (nearbyPredators.length > 0) {
                        let closestPredator = nearbyPredators.sort((a, b) => 
                            Vector.dist(this.pos, a.pos) - Vector.dist(this.pos, b.pos)
                        )[0];
                        let predatorDist = Vector.dist(this.pos, closestPredator.pos);
                        
                        if (predatorDist < 200) { // Increased detection radius from 150 to 200
                            // Flee from predator (SCATTER!)
                            forces.flee.add(Vector.sub(this.pos, closestPredator.pos).normalize().mult(CONFIG.preyEvadeBonus * 2.5));
                            this.state = "Fleeing Predator";
                            active = true;
                            this.lastFleeTime = this.frame || 0; // Remember when we fled
                        }
                    }
                    
                    // Seek food sources if not fleeing (DENSITY-BASED SEEKING)
                    if (!active) {
                        let nearbyFood = localRes.filter(r => r.type === 'FOOD' && r.active && !r.carrier);
                        if (nearbyFood.length > 0) {
                            // DENSITY-BASED: Find areas with highest food concentration
                            let bestTarget = null;
                            let bestScore = -1;
                            
                            // Sample up to 15 closest food items
                            let sampled = nearbyFood.slice(0, 15);
                            for (let food of sampled) {
                                let density = 0;
                                // Count nearby food within 80px radius
                                for (let other of nearbyFood) {
                                    if (Vector.dist(food.pos, other.pos) < 80) {
                                        density++;
                                    }
                                }
                                
                                let distance = Vector.dist(this.pos, food.pos);
                                // Score = density / distance (prefer dense + close)
                                let score = density / Math.max(10, distance);
                                
                                // BOOST: If we were recently fleeing, prefer returning to dense food areas
                                if (this.lastFleeTime && (this.frame - this.lastFleeTime) < 100) {
                                    score *= (1 + density * 0.2); // Bonus for regrouping
                                }
                                
                                if (score > bestScore) {
                                    bestScore = score;
                                    bestTarget = food;
                                }
                            }
                            
                            if (bestTarget) {
                                forces.food.add(this.seek(bestTarget.pos).mult(1.8));
                                this.state = "Seeking Food Cluster";
                                active = true;
                                
                                // REPRODUCTION BOOST: Track food consumption for reproduction rate
                                let d = Vector.dist(this.pos, bestTarget.pos);
                                if (d < this.radius + bestTarget.config.radius) {
                                    this.foodEaten = (this.foodEaten || 0) + 1; // Track food eaten
                                }
                            }
                        }
                    }
                }
                
                // DIPLOMAT BEHAVIOR - Visit foreign nests, create diplomatic bonds
                if (this.role === 'Diplomat' && myNest) {
                    // TRIBE SUSTENANCE - Diplomats draw from tribe wealth, not self-sufficient (MUCH CHEAPER!)
                    if (this.energy < 50 && myNest.wealth > 3) {
                        this.energy += 2; // Sustained by tribe
                        myNest.wealth -= 0.1; // Reduced from 0.5 to 0.1 (80% cost reduction!)
                    }
                    // Die faster if tribe is poor
                    if (myNest.wealth < 20) { // Lowered from 50 to 20
                        this.health -= 0.5; // Starvation
                    }
                    
                    // Check if this tribe is at war
                    let myTribe = sim.tribes.tribes[this.tribeId];
                    let isAtWar = false;
                    let warTargets = [];
                    if (myTribe && myTribe.atWarWith) {
                        for (let warId in myTribe.atWarWith) {
                            if (myTribe.atWarWith[warId] === true) {
                                isAtWar = true;
                                warTargets.push(parseInt(warId));
                            }
                        }
                    }
                    
                    // Find nearby foreign nests
                    let foreignNests = sim.tribes.nests.filter(n => 
                        n.tribeId !== this.tribeId && 
                        Vector.dist(this.pos, n.pos) < 800
                    );
                    
                    if (foreignNests.length > 0) {
                        let targetNest;
                        
                        // WAR-TIME AGGRESSIVE DIPLOMACY: Prioritize enemies of opponent and neutral parties
                        if (isAtWar && warTargets.length > 0) {
                            // Find nests that are enemies of our opponent(s) or neutral
                            let strategicTargets = [];
                            let neutralTargets = [];
                            
                            foreignNests.forEach(nest => {
                                let relation = sim.tribes.getOpinion(this.tribeId, nest.tribeId);
                                let atWarWithNest = sim.tribes.isAtWar(this.tribeId, nest.tribeId);
                                
                                // Skip if at war with this nest (don't visit enemies directly during war)
                                if (atWarWithNest) return;
                                
                                // Check if this nest is an enemy of our opponent (potential ally)
                                let isEnemyOfOpponent = false;
                                for (let warTargetId of warTargets) {
                                    if (sim.tribes.isAtWar(nest.tribeId, warTargetId)) {
                                        isEnemyOfOpponent = true;
                                        break;
                                    }
                                }
                                
                                // Check if neutral (not strong allies, not enemies)
                                let isNeutral = relation >= -20 && relation <= 20;
                                
                                if (isEnemyOfOpponent) {
                                    strategicTargets.push({nest: nest, relation: relation, priority: 100}); // Highest priority
                                } else if (isNeutral) {
                                    neutralTargets.push({nest: nest, relation: relation, priority: 50}); // Medium priority
                                }
                            });
                            
                            // Sort strategic targets by relation (higher first)
                            strategicTargets.sort((a, b) => b.relation - a.relation);
                            neutralTargets.sort((a, b) => Math.abs(b.relation) - Math.abs(a.relation)); // Closest to true neutral first
                            
                            // Prioritize: enemies of opponent > neutral parties > others
                            if (strategicTargets.length > 0) {
                                targetNest = strategicTargets[0].nest;
                            } else if (neutralTargets.length > 0) {
                                targetNest = neutralTargets[0].nest;
                            } else {
                                // Fallback: sort by relation (visit allies first)
                                foreignNests.sort((a, b) => {
                                    let relA = sim.tribes.getOpinion(this.tribeId, a.tribeId);
                                    let relB = sim.tribes.getOpinion(this.tribeId, b.tribeId);
                                    return relB - relA;
                                });
                                targetNest = foreignNests[0];
                            }
                        } else {
                            // Normal peacetime diplomacy: Sort by relation (visit allies first)
                        foreignNests.sort((a, b) => {
                            let relA = sim.tribes.getOpinion(this.tribeId, a.tribeId);
                            let relB = sim.tribes.getOpinion(this.tribeId, b.tribeId);
                            return relB - relA; // Higher relation first
                        });
                            targetNest = foreignNests[0];
                        }
                        
                        let relation = sim.tribes.getOpinion(this.tribeId, targetNest.tribeId);
                        let atWar = sim.tribes.isAtWar(this.tribeId, targetNest.tribeId);
                        
                        // Visit neutral, friendly nests, OR enemy nests for PEACE NEGOTIATIONS
                        // During war, also visit enemies of opponent and neutral parties aggressively (even if slightly negative relation)
                        if (relation >= -10 || atWar || (isAtWar && relation >= -30)) {
                            let d = Vector.dist(this.pos, targetNest.pos);
                            
                            if (d > targetNest.radius + 20) {
                                // Travel to foreign nest
                                forces.social.add(this.seek(targetNest.pos).mult(1.5));
                                this.state = "Diplomatic Mission";
                                active = true;
                            } else {
                                // At foreign nest - conduct diplomacy
                                this.state = "Negotiating";
                                active = true;
                                
                                // AGGRESSIVE DIPLOMACY DURING WAR: Higher frequency when at war
                                let negotiationFrequency = CONFIG.diplomatNegotiationFrequency;
                                if (isAtWar) {
                                    negotiationFrequency *= 3.0; // 3x more frequent during war (aggressive diplomacy)
                                }
                                
                                if (Math.random() < negotiationFrequency) { // Configurable negotiation frequency (boosted during war)
                                    // Calculate negotiation bonus from bonded diplomats/merchants
                                    let negotiationBonus = 1.0;
                                    let bondedDiplomats = this.partners.filter(p => 
                                        !p.dead && 
                                        (p.role === 'Diplomat' || p.role === 'Merchant') &&
                                        p.tribeId === this.tribeId
                                    ).length;
                                    negotiationBonus += bondedDiplomats * 0.2; // +20% per bonded diplomat/merchant
                                    
                                    // PEACE NEGOTIATIONS - End wars through diplomacy!
                                    if (atWar) {
                                        // Try to negotiate peace
                                        let myTribe = sim.tribes.tribes[this.tribeId];
                                        let theirTribe = sim.tribes.tribes[targetNest.tribeId];
                                        let myExhaustion = myTribe.warExhaustion[targetNest.tribeId] || 0;
                                        let theirExhaustion = theirTribe.warExhaustion[this.tribeId] || 0;
                                        
                                        // Peace more likely if both sides exhausted or diplomacy strong
                                        let peaceChance = 0.02 * negotiationBonus; // Base 2% chance
                                        peaceChance += Math.min(myExhaustion, theirExhaustion) / 1000; // Higher if exhausted
                                        
                                        if (Math.random() < peaceChance) {
                                            // PEACE TREATY!
                                            sim.tribes.endWar(this.tribeId, targetNest.tribeId, true); // Treaty = true
                                            // PERFORMANCE: Cleanup after war ends
                                            sim._cleanupAfterWar();
                                            
                                            // Establish diplomatic bonds
                                            let oldDipBond1 = sim.tribes.tribes[this.tribeId].diplomaticBonds[targetNest.tribeId] || 0;
                                            let oldDipBond2 = sim.tribes.tribes[targetNest.tribeId].diplomaticBonds[this.tribeId] || 0;
                                            
                                            sim.tribes.tribes[this.tribeId].diplomaticBonds[targetNest.tribeId] = 30;
                                            sim.tribes.tribes[targetNest.tribeId].diplomaticBonds[this.tribeId] = 30;
                                            
                                            // DIPLOMATIC BOND FORMATION SOUND - Play when diplomatic bond is created from peace treaty
                                            if (oldDipBond1 < 10 && 30 >= 10) {
                                                sfx.play('bond', getHarmonicFreq([HARMONICS.A4, HARMONICS.C5, HARMONICS.E5, HARMONICS.G5], 10), 0.12); // Diplomatic tone (harmonic)
                                            }
                                            
                                            // Improve relations significantly
                                            sim.tribes.updateOpinion(this.tribeId, targetNest.tribeId, 20);
                                            sim.tribes.updateOpinion(targetNest.tribeId, this.tribeId, 20);
                                            
                                            // VFX - Peace celebration
                                            sim.particles.push(new Particle(this.pos.x, this.pos.y, '#22c55e', 'star'));
                                            sim.particles.push(new Particle(targetNest.pos.x, targetNest.pos.y, '#22c55e', 'star'));
                                            sim.particles.push(new Particle(this.pos.x, this.pos.y, '#10b981', 'spark'));
                                            sfx.play('diplomacy', 620, 0.2);
                                            
                                            this.state = "Peace Treaty Signed!";
                                        } else {
                                            // Failed negotiations, but still improve relations slightly
                                            sim.tribes.updateOpinion(this.tribeId, targetNest.tribeId, 0.5 * negotiationBonus);
                                            sim.tribes.updateOpinion(targetNest.tribeId, this.tribeId, 0.5 * negotiationBonus);
                                            this.state = "Peace Talks";
                                        }
                                    } else {
                                        // Normal diplomacy (not at war with this target)
                                        // AGGRESSIVE BOND GROWTH DURING WAR: Diplomatic bonds form faster when at war
                                        let bondGrowth = CONFIG.diplomaticBondGrowth * negotiationBonus;
                                        if (isAtWar) {
                                            bondGrowth *= 2.5; // 2.5x faster bond growth during war (aggressive diplomacy)
                                        }
                                        
                                        let currentBond = sim.tribes.tribes[this.tribeId].diplomaticBonds[targetNest.tribeId] || 0;
                                        let newBond = Math.min(100, currentBond + bondGrowth);
                                        
                                        // SFX when bond forms (crosses threshold)
                                        if (currentBond < 20 && newBond >= 20) {
                                            sfx.play('link_formed', 520, 0.15);
                                            sim.particles.push(new Particle(this.pos.x, this.pos.y, '#fbbf24', 'star'));
                                            sim.particles.push(new Particle(targetNest.pos.x, targetNest.pos.y, '#fbbf24', 'star'));
                                        }
                                        
                                        sim.tribes.tribes[this.tribeId].diplomaticBonds[targetNest.tribeId] = newBond;
                                        sim.tribes.tribes[targetNest.tribeId].diplomaticBonds[this.tribeId] = newBond;
                                        
                                        // Also improve relations slightly (with bonus)
                                        let relationImprovement = 0.5 * negotiationBonus; // INCREASED from 0.3
                                        sim.tribes.updateOpinion(this.tribeId, targetNest.tribeId, relationImprovement);
                                        sim.tribes.updateOpinion(targetNest.tribeId, this.tribeId, relationImprovement);
                                        
                                        // VFX (brighter with better negotiation)
                                        sim.particles.push(new Particle(this.pos.x, this.pos.y, '#fde047', 'star'));
                                        if (negotiationBonus > 1.5) {
                                            sim.particles.push(new Particle(this.pos.x, this.pos.y, '#fbbf24', 'spark'));
                                        }
                                        sfx.play('diplomacy', 520, 0.12);
                                    }
                                    
                                    // TECH PROGRESSION: diplomacy activity grants tech points (always)
                                    sim.tribes.progressTech(this.tribeId, 'diplomacy', 2 * negotiationBonus);
                                    sim.tribes.progressTech(targetNest.tribeId, 'diplomacy', 1); // They also gain some
                                    
                                    // TRACK DIPLOMATIC BENEFITS (for bond maintenance)
                                    let currentFrame = sim.frame || 0;
                                    let myTribe = sim.tribes.tribes[this.tribeId];
                                    let theirTribe = sim.tribes.tribes[targetNest.tribeId];
                                    
                                    // Diplomacy provides ongoing value (improved relations, tech, future trade)
                                    let diplomaticValue = 10 * negotiationBonus; // Base value
                                    myTribe.diplomaticBenefits[targetNest.tribeId] = (myTribe.diplomaticBenefits[targetNest.tribeId] || 0) + diplomaticValue;
                                    theirTribe.diplomaticBenefits[this.tribeId] = (theirTribe.diplomaticBenefits[this.tribeId] || 0) + diplomaticValue;
                                    
                                    // Update last diplomacy time
                                    myTribe.lastDiplomacyTime[targetNest.tribeId] = currentFrame;
                                    theirTribe.lastDiplomacyTime[this.tribeId] = currentFrame;
                                }
                            }
                        }
                    }
                }
                
                // MERCHANT BEHAVIOR - Trade with allied nests
                if (this.role === 'Merchant' && myNest) {
                    // TRIBE SUSTENANCE - Merchants sustained by tribe wealth (MUCH CHEAPER!)
                    if (this.energy < 50 && myNest.wealth > 3) {
                        this.energy += 2; // Sustained by tribe
                        myNest.wealth -= 0.1; // Reduced from 0.5 to 0.1 (80% cost reduction!)
                    }
                    // Die faster if tribe is poor
                    if (myNest.wealth < 20) { // Lowered from 50 to 20
                        this.health -= 0.5; // Starvation
                    }
                    
                    // HARVEST RESOURCES FOR TRADE (if not carrying anything)
                    if (!this.carrying && !active) {
                        // Look for valuable resources scattered around landscape
                        let valuableResources = localRes.filter(r => 
                            r.active && !r.carrier && 
                            (r.type === 'MAT' || r.type === 'ORE' || r.type === 'TREASURE' || r.type === 'UNIQUE')
                        );
                        
                        if (valuableResources.length > 0) {
                            let closest = valuableResources.sort((a, b) => 
                                Vector.dist(this.pos, a.pos) - Vector.dist(this.pos, b.pos)
                            )[0];
                            
                            let d = Vector.dist(this.pos, closest.pos);
                            if (d < this.radius + closest.config.radius) {
                                // Pick up resource for trade
                                this.carrying = closest;
                                closest.carrier = this;
                                this.state = "Harvesting for Trade";
                                active = true;
                            } else {
                                // Seek resource
                                forces.food.add(this.seek(closest.pos).mult(2.0));
                                this.state = "Seeking Trade Goods";
                                active = true;
                            }
                        }
                    }
                    
                    // Find nearby allied nests to trade with
                    let tradePartners = sim.tribes.nests.filter(n => {
                        if (n.tribeId === this.tribeId) return false;
                        let relation = sim.tribes.getOpinion(this.tribeId, n.tribeId);
                        return relation >= CONFIG.minAllianceForTrade; // Only trade with allies
                    });
                    
                    if (tradePartners.length > 0 && this.carrying) {
                        // Sort by commercial bond strength (prefer strong trade partners)
                        tradePartners.sort((a, b) => {
                            let bondA = sim.tribes.tribes[this.tribeId].commercialBonds[a.tribeId] || 0;
                            let bondB = sim.tribes.tribes[this.tribeId].commercialBonds[b.tribeId] || 0;
                            return bondB - bondA;
                        });
                        
                        let targetNest = tradePartners[0];
                        let d = Vector.dist(this.pos, targetNest.pos);
                        
                        if (d > targetNest.radius + 30) {
                            // Travel to trade partner
                            forces.social.add(this.seek(targetNest.pos).mult(2.0));
                            this.state = "Trading Mission";
                            active = true;
                        } else {
                            // At trade partner nest - conduct trade
                            this.state = "Trading";
                            active = true;
                            
                            if (Math.random() < CONFIG.merchantTradeFrequency && this.carrying) {
                                // Calculate merchant's negotiation power (from bonded merchants/diplomats)
                                let myNegotiationPower = 1.0;
                                let bondedMerchants = this.partners.filter(p => 
                                    !p.dead && 
                                    (p.role === 'Merchant' || p.role === 'Diplomat') &&
                                    p.tribeId === this.tribeId
                                ).length;
                                myNegotiationPower += bondedMerchants * 0.15; // +15% per bonded merchant/diplomat
                                
                                // Calculate relative tribe strength (wealth, population, tech)
                                let myTribe = sim.tribes.tribes[this.tribeId];
                                let theirTribe = sim.tribes.tribes[targetNest.tribeId];
                                let myStrength = (myNest.wealth || 0) + sim.agents.filter(a => a.tribeId === this.tribeId).length * 10;
                                let theirStrength = (targetNest.wealth || 0) + sim.agents.filter(a => a.tribeId === targetNest.tribeId).length * 10;
                                
                                // Stronger party gets better deal (but trade is always beneficial to both)
                                let strengthRatio = myStrength / (theirStrength + 1); // Avoid division by zero
                                strengthRatio = Math.max(0.5, Math.min(2.0, strengthRatio)); // Clamp between 0.5 and 2.0
                                
                                // Calculate trade values (MASSIVELY INCREASED PROFITS!)
                                let baseValue = this.carrying.config.val;
                                let myProfit = baseValue * 15 * myNegotiationPower * strengthRatio; // Merchant profit (5√ó increase!)
                                let homeProfit = baseValue * 10 * strengthRatio; // Home nest profit (5√ó increase!)
                                let theirCost = baseValue * 5 / strengthRatio; // They pay (but increased)
                                let theirBenefit = baseValue * 10; // They benefit greatly! (6.7√ó increase!)
                                
                                // Complete trade
                                let theirNetProfit = theirBenefit - theirCost; // Net benefit to them
                                targetNest.wealth += theirNetProfit;
                                this.wealth += myProfit;
                                myNest.wealth += homeProfit;
                                
                                // TRACK TRADE PROFITS FOR BOTH PARTIES (for bond maintenance)
                                let myTotalProfit = myProfit + homeProfit;
                                let currentFrame = typeof sim !== 'undefined' ? sim.frame : 0;
                                
                                // Update profit tracking (rolling window of last 500 frames)
                                myTribe.tradeProfit[targetNest.tribeId] = (myTribe.tradeProfit[targetNest.tribeId] || 0) + myTotalProfit;
                                theirTribe.tradeProfit[this.tribeId] = (theirTribe.tradeProfit[this.tribeId] || 0) + theirNetProfit;
                                
                                // Add to profit history
                                if (!myTribe.tradeProfitHistory[targetNest.tribeId]) myTribe.tradeProfitHistory[targetNest.tribeId] = [];
                                if (!theirTribe.tradeProfitHistory[this.tribeId]) theirTribe.tradeProfitHistory[this.tribeId] = [];
                                
                                myTribe.tradeProfitHistory[targetNest.tribeId].push({ profit: myTotalProfit, frame: currentFrame });
                                theirTribe.tradeProfitHistory[this.tribeId].push({ profit: theirNetProfit, frame: currentFrame });
                                
                                // Keep only last 500 frames of history
                                if (myTribe.tradeProfitHistory[targetNest.tribeId].length > 100) {
                                    myTribe.tradeProfitHistory[targetNest.tribeId].shift();
                                }
                                if (theirTribe.tradeProfitHistory[this.tribeId].length > 100) {
                                    theirTribe.tradeProfitHistory[this.tribeId].shift();
                                }
                                
                                // Update last trade time
                                myTribe.lastTradeTime[targetNest.tribeId] = currentFrame;
                                theirTribe.lastTradeTime[this.tribeId] = currentFrame;
                                
                                this.carrying.active = false;
                                this.carrying = null;
                                
                                // Strengthen commercial bond (with negotiation bonus)
                                let bondGrowth = CONFIG.commercialBondGrowth * myNegotiationPower;
                                let currentBond = sim.tribes.tribes[this.tribeId].commercialBonds[targetNest.tribeId] || 0;
                                let newBond = Math.min(100, currentBond + bondGrowth);
                                
                                // SFX when bond forms (crosses threshold)
                                if (currentBond < 20 && newBond >= 20) {
                                    sfx.play('link_formed', 580, 0.15);
                                    sim.particles.push(new Particle(this.pos.x, this.pos.y, '#22d3ee', 'star'));
                                    sim.particles.push(new Particle(targetNest.pos.x, targetNest.pos.y, '#22d3ee', 'star'));
                                }
                                
                                sim.tribes.tribes[this.tribeId].commercialBonds[targetNest.tribeId] = newBond;
                                sim.tribes.tribes[targetNest.tribeId].commercialBonds[this.tribeId] = newBond;
                                
                                // Also improve relations slightly (with bonus)
                                let relationImprovement = 0.4 * myNegotiationPower; // DOUBLED from 0.2
                                sim.tribes.updateOpinion(this.tribeId, targetNest.tribeId, relationImprovement);
                                sim.tribes.updateOpinion(targetNest.tribeId, this.tribeId, relationImprovement);
                                
                                // TECH PROGRESSION: commerce activity grants tech points
                                sim.tribes.progressTech(this.tribeId, 'commerce', 3 * myNegotiationPower);
                                sim.tribes.progressTech(targetNest.tribeId, 'commerce', 2); // They also gain some
                                
                                // SFX for transaction
                                sfx.play('transaction', HARMONICS.E5, 0.08);
                                
                                // VFX (more coins for better deals)
                                sim.particles.push(new Particle(this.pos.x, this.pos.y, '#22d3ee', 'coin'));
                                if (myNegotiationPower > 1.5 || strengthRatio > 1.3) {
                                    sim.particles.push(new Particle(this.pos.x + 10, this.pos.y, '#fbbf24', 'coin'));
                                }
                                sfx.play('trade', 480, 0.15);
                            }
                        }
                    } else if (!this.carrying) {
                        // Go home to get resources to trade
                        if (distToNest > 50) {
                            forces.social.add(this.seek(myNest.pos).mult(1.5));
                            this.state = "Returning for Goods";
                            active = true;
                        }
                    }
                }
                
                // GRAZER BEHAVIOR - Convert resources, avoid predators
                if (this.isGrazer) {
                    // Evade predators and normal agents
                    let threats = localAgents.filter(a => (a.isPredator || (!a.isPrey && !a.isGrazer)) && !a.dead);
                    if (threats.length > 0) {
                        let closestThreat = threats.sort((a, b) => 
                            Vector.dist(this.pos, a.pos) - Vector.dist(this.pos, b.pos)
                        )[0];
                        let threatDist = Vector.dist(this.pos, closestThreat.pos);
                        
                        if (threatDist < 120) {
                            forces.flee.add(Vector.sub(this.pos, closestThreat.pos).normalize().mult(1.8));
                            this.state = "Fleeing Threat";
                            active = true;
                        }
                    }
                    
                    // Seek resources to convert if not fleeing
                    if (!active) {
                        let targetResources = localRes.filter(r => r.type === 'FOOD' && r.active && !r.carrier);
                        if (targetResources.length > 0) {
                            let closest = targetResources.sort((a, b) => 
                                Vector.dist(this.pos, a.pos) - Vector.dist(this.pos, b.pos)
                            )[0];
                            forces.food.add(this.seek(closest.pos).mult(1.2));
                            this.state = "Grazing";
                            active = true;
                        }
                    }
                }

                // RANGED COMBAT - SOLDIERS ONLY (LIMITED RANGE for performance)
                if (this.canShootRanged && this.shotCooldown <= 0) {
                    // Limit ranged combat search to actual ranged range (150) for performance
                    const rangedSearchRange = CONFIG.rangedCombatRange || 150;
                    let rangedLocalAgents = [];
                    if (typeof sim !== 'undefined' && sim.spatialGrid && sim.gridCols > 0) {
                        let nearby = sim.getNearbyEntities(this.pos.x, this.pos.y, rangedSearchRange);
                        rangedLocalAgents = nearby.agents.filter(a => a !== this && !a.dead);
                    } else {
                        rangedLocalAgents = localAgents.filter(a => Vector.dist(this.pos, a.pos) < rangedSearchRange);
                    }
                    
                    // Find enemies in range
                    let enemies = rangedLocalAgents.filter(other => {
                        if (other.dead || other === this) return false;
                        
                        // Can't shoot bonded group members
                        if (this.partners.includes(other)) return false;
                        let bondedGroup = this.getBondedGroup();
                        if (bondedGroup.includes(other)) return false;
                        
                        // Check if enemy
                        let loyalty = this.getNetLoyalty(other);
                        let isEnemy = loyalty < -30 || (this.tribeId !== -1 && other.tribeId !== -1 && sim.tribes.isAtWar(this.tribeId, other.tribeId));
                        
                        if (!isEnemy) return false;
                        
                        let d = Vector.dist(this.pos, other.pos);
                        return d > this.radius + other.radius + 20 && d < CONFIG.rangedCombatRange; // Medium range only
                    });
                    
                    if (enemies.length > 0 && Math.random() < CONFIG.rangedCombatChance) {
                        // Shoot at closest enemy
                        let target = enemies.sort((a, b) => 
                            Vector.dist(this.pos, a.pos) - Vector.dist(this.pos, b.pos)
                        )[0];
                        
                        // Create projectile
                        let projectile = new Projectile(
                            this.pos.x, this.pos.y,
                            target.pos.x, target.pos.y,
                            this,
                            CONFIG.rangedCombatDamage,
                            'arrow'
                        );
                        sim.projectiles.push(projectile);
                        
                        this.shotCooldown = CONFIG.rangedCombatCooldown;
                        this.state = "Shooting";
                        // Sound handled by throttled system in update() - no direct call here
                    }
                }
                
                // Cooldown decrement
                if (this.shotCooldown > 0) this.shotCooldown--;

                // GATHERING
                let foodScent = new Vector(0,0);
                let foodCount = 0;
                
                if (!this.isAdult()) {
                    // Children follow parents or sit tight
                    if (this.partners.length > 0) {
                        forces.social.add(this.seek(this.partners[0].pos).mult(2.0));
                    }
                } else {
                    // Adult Gathering
                    for (let r of localRes) {
                        if (r.type === 'SEED') continue; 
                        let d = Vector.dist(this.pos, r.pos);
                        // Agents cannot take from their OWN Nest (radius check)
                        let isMyNest = myNest && Vector.dist(r.pos, myNest.pos) < myNest.radius + 10;

                        // ALL AGENTS EAT FOOD WHEN THEY TOUCH IT IF NOT FULL
                        // Check if agent is touching food and not at full energy
                        if (d < this.radius + r.config.radius && r.type === 'FOOD' && r.active && !r.carrier) {
                            let isNotFull = this.energy < this.maxEnergy;
                            // Allow eating even if carrying something, or if not carrying
                            if (isNotFull && (!isMyNest || isStarving || this.energy < this.maxEnergy * 0.8)) {
                                     r.active = false; 
                                     let harvestMult = 1.0 + (this.wealth / 1000); 
                                     this.energy += r.config.val * harvestMult * CONFIG.foodNutritionalValue;
                                if (this.energy > this.maxEnergy) this.energy = this.maxEnergy;
                                // Small wealth gain from eating
                                this.wealth += 1;
                                // Continue to other resource handling if not carrying
                                if (!this.carrying) {
                                    // Don't process this resource again below
                                    continue;
                                }
                            }
                        }
                        
                        // HUNGER PRIORITY FIX: If starving, eat regardless of nest proximity
                        if (d < this.radius + r.config.radius && (!isMyNest || isStarving)) {
                            if (this.carrying) {
                                 // Food eating already handled above
                                 if (r.type === 'FOOD') continue; // Skip - already handled
                            } else {
                                // PICKUP
                                if (r.type === 'TREASURE' || r.type === 'RELIC') {
                                    let val = r.type === 'RELIC' ? 200 : 50;
                                    if (r.type === 'RELIC') {
                                        // Curiosity/Scientist Bonus
                                        if (this.role === 'Scientist' || this.dna.curiosity > 0.7) {
                                            this.learnSkill('SENSE', this.skills.SENSE + 1);
                                            sim.particles.push(new Particle(this.pos.x, this.pos.y, '#67e8f9', 'spark'));
                                        }
                                    }
                                    r.active = false; this.charisma += 5; this.wealth += val;
                                    sim.particles.push(new Particle(this.pos.x, this.pos.y, '#22d3ee', 'spark'));
                                }
                                else if (r.type === 'MAT' || r.type === 'ORE') {
                                    let builderPriority = this.role === 'Builder' && hunger < 0.5;
                                    if (hunger > 0.9) {
                                        r.active = false;
                                        this.energy += 5; 
                                        if(this.energy > this.maxEnergy) this.energy = this.maxEnergy;
                                        sim.particles.push(new Particle(this.pos.x, this.pos.y, '#facc15'));
                                    }
                                else if (!r.carrier && !this.carrying && groupBenefits.conversionBonus > 1.05 && hunger > 0.6 && this.role !== 'Miner' && this.role !== 'Builder') {
                                    r.active = false;
                                    let energyGain = r.config.val * 0.3 * groupBenefits.conversionBonus;
                                    this.energy = Math.min(this.maxEnergy, this.energy + energyGain);
                                    this.wealth += 2;
                                    sim.particles.push(new Particle(this.pos.x, this.pos.y, '#a855f7', 'spark'));
                                    this.state = "Feeding on Ore";
                                    }
                                    else if (builderPriority || (!r.carrier && this.role !== 'Miner' && this.role !== 'Merchant')) { 
                                        r.carrier = this;
                                        this.carrying = r;
                                    }
                                } else if (r.type === 'FOOD' || r.type === 'STIM' || r.type === 'HERB') {
                                    // Skip if food was already eaten by the earlier check
                                    if (r.type === 'FOOD' && !r.active) continue;
                                    
                                    // SOLDIERS, DIPLOMATS, MERCHANTS ARE TRIBE-SUSTAINED - don't gather food
                                    if (this.isSustainedByTribe) {
                                        // Skip food gathering for tribe-sustained roles
                                        continue;
                                    }
                                    
                                    // Bring food to nest if full (only if not already eaten)
                                    if (myNest && this.energy > this.maxEnergy * 0.8 && !r.carrier && !isStarving && r.active) {
                                        r.carrier = this; this.carrying = r;
                                    } else if (r.active) {
                                        if(this.role !== 'Merchant') {
                                            r.active = false;
                                            let harvestMult = 1.0 + (this.wealth / 1000);
                                            if (r.type === 'FOOD') { 
                                                this.energy += r.config.val * harvestMult * CONFIG.foodNutritionalValue; 
                                                if (this.energy > this.maxEnergy) this.energy = this.maxEnergy;
                                                this.wealth += 1; // Food is money
                                            }
                                            if (r.type === 'STIM') { this.energy += 50; this.frenzyTimer = 300; }
                                            if (r.type === 'HERB') { this.disease = 0; this.health += 50; this.immunity = 500; sim.particles.push(new Particle(this.pos.x, this.pos.y, '#e879f9', 'spark')); }
                                            
                                            // UNIQUE RESOURCES: amplify specific gene
                                            if (r.type === 'UNIQUE') {
                                                this.energy += r.config.val * harvestMult;
                                                
                                            let canAmplifyGene = false;
                                                if (this.tribeId === r.nestId) {
                                                canAmplifyGene = true; // Same tribe
                                                } else if (this.tribeId !== -1 && r.nestId !== -1) {
                                                    let myTribe = sim.tribes.tribes[this.tribeId];
                                                    let comBond = myTribe.commercialBonds[r.nestId] || 0;
                                                let dipBond = myTribe.diplomaticBonds[r.nestId] || 0;
                                                if (comBond > 30 || dipBond > 30) {
                                                    canAmplifyGene = true; // Strong ally
                                                    }
                                                }
                                                
                                            if (canAmplifyGene && r.geneBoost && this.dna[r.geneBoost] !== undefined) {
                                                    // Amplify the specific gene
                                                    let boost = 0.05; // 5% boost
                                                    this.dna[r.geneBoost] = Math.min(1.0, this.dna[r.geneBoost] + boost);
                                                    sim.particles.push(new Particle(this.pos.x, this.pos.y, r.config.color, 'spark'));
                                                }
                                            }
                                        } else if (hunger > 0.5) {
                                             r.active = false; this.energy += r.config.val * CONFIG.foodNutritionalValue;
                                        }
                                    }
                                }
                            }
                        }

                        if (r.active && !r.carrier && (r.type === 'FOOD' || r.type === 'UNIQUE')) {
                             let weight = 100 / (d*d);
                             // Botanists are strongly attracted to food areas to cultivate them
                             if (this.role === 'Botanist' && r.type === 'FOOD') {
                                 weight *= 2.0; // Botanists prioritize food areas
                             }
                             // UNIQUE resources are extra attractive for tribe members or commercial partners
                             if (r.type === 'UNIQUE') {
                                 if (this.tribeId === r.nestId) {
                                     weight *= 1.5; // Same tribe bonus
                                 } else if (this.tribeId !== -1 && r.nestId !== -1) {
                                     let myTribe = sim.tribes.tribes[this.tribeId];
                                     let comBond = myTribe.commercialBonds[r.nestId] || 0;
                                     if (comBond > 30) {
                                         weight *= 1.3; // Commercial bond bonus
                                     }
                                 }
                             }
                             let dir = Vector.sub(r.pos, this.pos).normalize().mult(weight);
                             foodScent.add(dir); foodCount++;
                        }
                        if (r.active && !r.carrier && r.type === 'MAT' && this.role === 'Builder') {
                            let weight = 200 / (d*d);
                             let dir = Vector.sub(r.pos, this.pos).normalize().mult(weight);
                             forces.food.add(dir); 
                             foodCount++;
                        }
                    }
                }

                if (foodCount > 0 && !this.carrying && this.role !== 'Miner' && this.role !== 'Raider' && this.role !== 'Merchant' && this.isAdult()) {
                    forces.food = foodScent.normalize().mult(this.maxSpeed * (hunger * 3 + 0.5));
                    if (forces.food.mag() > 0.1) { this.state = "Foraging"; active = true; }
                }

                // BASE RETURN & BUILDING
                if (this.carrying && this.state !== "Trading") {
                    // Builders skip generic return if they are in Build Mode
                    if (this.role === 'Builder' && this.carrying.type === 'MAT' && myNest) {
                        // Already handled in Builder Block above
                    } else {
                        this.state = "Returning"; active = true;
                        if (myNest) {
                            forces.base = this.seek(myNest.pos).mult(2.0);
                            if (distToNest < this.radius + myNest.radius + 20) {
                                // Deposit at nest - ALL RESOURCE TYPES CONVERT TO WEALTH
                                // Use the new value scale for proper conversion
                                let resourceType = this.carrying.type;
                                let resourceValue = weightedResourceEnergy(resourceType) || 30; // Get value from scale
                                
                                // Convert resource value to wealth (scaled appropriately)
                                let val = resourceValue; // Base value from scale
                                
                                // Special multipliers for certain resource types
                                if (resourceType === 'TREASURE') {
                                    val = resourceValue * 0.5; // Treasure: 200 * 0.5 = 100 wealth
                                } else if (resourceType === 'RELIC') {
                                    val = resourceValue * 0.5; // Relic: 120 * 0.5 = 60 wealth
                                } else if (resourceType === 'UNIQUE') {
                                    val = resourceValue * 0.4; // Unique: 150 * 0.4 = 60 wealth
                                } else if (resourceType === 'ORE') {
                                    val = resourceValue * 0.375; // Ore: 80 * 0.375 = 30 wealth
                                } else if (resourceType === 'HERB') {
                                    val = resourceValue * 0.25; // Herb: 60 * 0.25 = 15 wealth
                                } else if (resourceType === 'STIM') {
                                    val = resourceValue * 0.2; // Stim: 50 * 0.2 = 10 wealth
                                } else if (resourceType === 'MAT') {
                                    val = resourceValue * 0.25; // Mat: 40 * 0.25 = 10 wealth
                                } else if (resourceType === 'FOOD') {
                                    val = resourceValue * 0.2; // Food: 25 * 0.2 = 5 wealth
                                } else if (resourceType === 'SEED') {
                                    val = resourceValue * 0.2; // Seed: 30 * 0.2 = 6 wealth
                                }
                                    
                                    // Raiders deposit 10x value
                                    if (this.role === 'Raider') val *= 10;

                                    let taxRate = CONFIG.tribalTaxRate;
                                if (this.isGroupEntity && CONFIG.groupAgentTaxPremium) {
                                    taxRate = Math.min(0.95, taxRate + CONFIG.groupAgentTaxPremium);
                                }
                                    this.wealth += val * (1 - taxRate); // Keep portion after tax
                                    myNest.wealth += val * taxRate; // Tax to nest
                                
                                // Also call giveNestWealth for proper conversion tracking
                                giveNestWealth(this.tribeId, resourceType, this.carrying);
                                
                                    this.carrying.active = false;
                                    this.carrying = null;
                                    sim.particles.push(new Particle(myNest.pos.x, myNest.pos.y, '#fbbf24', 'spark'));
                            }
                        } else {
                             if (this.carrying.type === 'MAT') this.home = this.pos.copy();
                        }
                    }
                }

                // KIN HELPING BEHAVIOR
                for(let kin of localAgents) {
                    if (this.kin.includes(kin.id) && !kin.dead) {
                        let d = Vector.dist(this.pos, kin.pos);
                        
                        // Help injured kin (especially children)
                        if (kin.health < kin.maxHealth * 0.5 && d < this.senseRad * 0.6) {
                            forces.social.add(this.seek(kin.pos).mult(1.5));
                            this.state = "Helping Kin";
                            active = true;
                            
                            if (d < this.radius + kin.radius + 10) {
                                // Transfer health/energy
                                if (this.health > this.maxHealth * 0.6 && kin.health < kin.maxHealth * 0.8) {
                                    let transfer = Math.min(2, this.health * 0.05);
                                    this.health -= transfer;
                                    kin.health += transfer;
                                    if (Math.random() < 0.1) {
                                        sim.particles.push(new Particle(kin.pos.x, kin.pos.y, '#10b981', 'plus'));
                                        sim.particles.push(new Particle(kin.pos.x, kin.pos.y, '#6ee7b7', 'ring'));
                                        sfx.play('heal', 520, 0.12);
                                    }
                                }
                                if (this.energy > this.maxEnergy * 0.6 && kin.energy < kin.maxEnergy * 0.5) {
                                    let transfer = Math.min(3, this.energy * 0.05);
                                    this.energy -= transfer;
                                    kin.energy += transfer;
                                }
                            }
                        }
                        
                        // Extra help for children of kin
                        if (!kin.isAdult() && d < this.senseRad * 0.5) {
                            if (this.carrying && this.carrying.type === 'FOOD' && kin.energy < kin.maxEnergy * 0.7) {
                                if (d < this.radius + kin.radius + 10) {
                                    // Give food to child kin
                                    kin.energy += this.carrying.config.val * CONFIG.foodNutritionalValue;
                                    this.carrying.active = false;
                                    this.carrying = null;
                                    sim.particles.push(new Particle(kin.pos.x, kin.pos.y, '#4ade80', 'spark'));
                                    sfx.play('eat', 480, 0.08);
                                }
                            }
                        }
                    }
                }

                // SOCIAL
                let alignment = new Vector(0,0);
                let cohesion = new Vector(0,0);
                let socialCount = 0;

                for (let other of localAgents) {
                    let d = Vector.dist(this.pos, other.pos);
                    let loyalty = this.getNetLoyalty(other);
                    let isLover = loyalty > CONFIG.loveThreshold;
                    let isHater = loyalty < CONFIG.hateThreshold;
                    let isKin = this.kin.includes(other.id); // FIX: should check kin array not tribe
                    let isSameTribe = (this.tribeId !== -1) && (this.tribeId === other.tribeId);
                    
                    // PREDATOR AGGRESSION - ONLY AGAINST DIFFERENT TRIBES OR UNAFFILIATED
                    
                    // 1. BRIBERY
                    if (isLover && other.getNetLoyalty(this) < CONFIG.loveThreshold && this.energy > 60 && d < 50 && this.isAdult() && other.isAdult()) {
                        this.energy -= 5;
                        other.energy += 5;
                        other.adjustLoyalty(this.id, 3); 
                        this.state = "Bribing";
                        active = true;
                        if (Math.random() < 0.1) sim.particles.push(new Particle(other.pos.x, other.pos.y, '#f472b6', 'heart'));
                    }

                    // 2. JEALOUSY - attack rivals and their children
                    if (isLover) {
                        for(let rivalId in other.loyalty) {
                            if (other.loyalty[rivalId] > CONFIG.loveThreshold && rivalId !== this.id) {
                                let rival = localAgents.find(a => a.id === rivalId);
                                if (rival && rival !== this) {
                                    // Check if rival is in my bonded group
                                    let rivalInGroup = this.partners.includes(rival);
                                    if (!rivalInGroup) {
                                        for (let p of this.partners) {
                                            if (!p.dead && p.partners.includes(rival)) {
                                                rivalInGroup = true;
                                                break;
                                            }
                                        }
                                    }
                                    
                                    // Only attack if not in bonded group
                                    if (!rivalInGroup) {
                                    this.adjustLoyalty(rival.id, -5);
                                    forces.hunt.add(this.seek(rival.pos).mult(2.5));
                                    this.state = "Jealous";
                                    active = true;
                                    this.targetId = rival.id;
                                        
                                        // Attack the rival directly
                                    if (Vector.dist(this.pos, rival.pos) < this.radius + rival.radius + 5) {
                                            let myGroupBenefits = this.getGroupBenefits();
                                            let rivalGroupBenefits = rival.getGroupBenefits();
                                            let damage = CONFIG.damageRate * 100 * myGroupBenefits.damageBonus / rivalGroupBenefits.defenseBonus;
                                            // Apply hunt bonus and shield bonus
                                            damage *= this.huntBonus;
                                            damage *= (1 - rival.shieldBonus);
                                            rival.health -= damage;
                                            markLeaderUnderAttack(rival, this);
                                        sim.particles.push(new Particle(rival.pos.x, rival.pos.y, '#ef4444', 'spark'));
                                            sfx.play('jealousy', 350, 0.15);
                                        }
                                        
                                        // ALSO attack children of rival and my lover
                                        for (let child of localAgents) {
                                            if (child.kin.includes(rival.id) && child.kin.includes(other.id) && !child.isAdult()) {
                                                let dChild = Vector.dist(this.pos, child.pos);
                                                if (dChild < this.senseRad * 0.7) {
                                                    forces.hunt.add(this.seek(child.pos).mult(2.0));
                                                    this.state = "Jealous Rage";
                                                    if (dChild < this.radius + child.radius + 5) {
                                                        let damage = CONFIG.damageRate * 150; // Extra vicious
                                                        child.health -= damage;
                                                    markLeaderUnderAttack(child, this);
                                                        sim.particles.push(new Particle(child.pos.x, child.pos.y, '#dc2626', 'spark'));
                                                        // Sound handled by throttled system in update() - no direct call here
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }

                    // Check if other is in my bonded group (direct partner or partner's partner)
                    let isInBondedGroup = false;
                    if (this.partners.includes(other)) {
                        isInBondedGroup = true;
                    } else {
                        // Check if other is bonded to any of my partners
                        for (let p of this.partners) {
                            if (!p.dead && p.partners.includes(other)) {
                                isInBondedGroup = true;
                                break;
                            }
                        }
                    }

                    amPredator = Math.abs(this.dna.predator_target - other.dna.prey_signal) < CONFIG.predationRange;
                    amPrey = Math.abs(other.dna.predator_target - this.dna.prey_signal) < CONFIG.predationRange;

                    // Predator logic - only if NOT same tribe and NOT in bonded group
                    if (amPredator && !isSameTribe && !isInBondedGroup) {
                        forces.hunt.add(this.seek(other.pos).mult(2.0));
                        this.state = "Hunting"; active = true;
                        if (d < this.radius + other.radius + 5) {
                            let myGroupBenefits = this.getGroupBenefits();
                            let otherGroupBenefits = other.getGroupBenefits();
                            let damage = (CONFIG.damageRate * 200) * myGroupBenefits.damageBonus / otherGroupBenefits.defenseBonus;
                            // Apply hunt bonus and shield bonus
                            damage *= this.huntBonus;
                            damage *= (1 - other.shieldBonus);
                            other.health -= damage; this.energy += 20;
                            markLeaderUnderAttack(other, this);
                            if(this.energy > this.maxEnergy) this.energy = this.maxEnergy;
                            
                            // BLOODY PARTICLE SCATTER EFFECTS - Local bloody particles during combat
                            for (let i = 0; i < 3 + Math.floor(damage / 5); i++) {
                                let angle = Math.random() * Math.PI * 2;
                                let dist = Math.random() * 15;
                                let particleX = other.pos.x + Math.cos(angle) * dist;
                                let particleY = other.pos.y + Math.sin(angle) * dist;
                                // Blood particles - red variations with slight scatter
                                let bloodColors = ['#dc2626', '#b91c1c', '#991b1b', '#ef4444'];
                                let bloodColor = bloodColors[Math.floor(Math.random() * bloodColors.length)];
                                sim.particles.push(new Particle(particleX, particleY, bloodColor, 'spark'));
                            }
                            sim.particles.push(new Particle(other.pos.x, other.pos.y, '#ef4444', 'spark'));
                            
                            // BATTLE SOUND - Track combat state and play every 10 frames during combat
                            this.inCombat = true;
                            this.lastCombatFrame = (typeof sim !== 'undefined' && sim.frame) ? sim.frame : 0;
                            
                            if(other.health <= 0) this.kills++;
                        }
                    } else if (amPrey && !isSameTribe && !isInBondedGroup) {
                        forces.flee.add(this.flee(other.pos).mult(2.0));
                        this.state = "Fleeing"; active = true;
                    }

                    // Bonding - Priority based: kin > lovers > same tribe > neutral tribes > no hate
                    let isBonded = this.partners.includes(other);
                    let isMonster = this.role === 'Monster';
                    let otherMonster = other.role === 'Monster';
                    
                    // Nest-tethered bonding penalty
                    let amStationary = this.role === 'Guardian' || (this.tribeId !== -1 && sim.tribes.tribes[this.tribeId].leaderId === this.id);
                    let otherStationary = other.role === 'Guardian' || (other.tribeId !== -1 && sim.tribes.tribes[other.tribeId].leaderId === other.id);
                    let nestBondPenalty = 1.0;
                    // Apply penalty if one is stationary and the other is not
                    if ((amStationary && !otherStationary) || (!amStationary && otherStationary)) {
                        nestBondPenalty = CONFIG.nestBondedPenalty;
                    }

                    // Monster Bonding Logic (Only with other Monsters)
                    if (isMonster) {
                        if (otherMonster && !isBonded && d < this.radius + other.radius + 20 && this.partners.length < 3) {
                             this.addPartner(other);
                             other.addPartner(this);
                             sim.particles.push(new Particle(this.pos.x, this.pos.y, '#8b5cf6', 'spark'));
                             // Bonding sound - keep this one as it's not high-intensity mating
                        }
                    } 
                    // Normal Bonding - Priority system
                    else if (!isBonded && d < this.radius + other.radius + 10 && this.partners.length < this.maxBonds && other.partners.length < other.maxBonds && !otherMonster) {
                        // Check if bonding is allowed based on priority rules
                        let canBond = false;
                        let bondPriority = 0;
                        
                        // 1. Kin - highest priority
                        if (isKin) {
                            canBond = true;
                            bondPriority = 5.0;
                        }
                        // 2. Lovers - high priority
                        else if (loyalty > CONFIG.loveThreshold) {
                            canBond = true;
                            bondPriority = 4.0;
                        }
                        // 3. Same tribe - medium-high priority
                        else if (this.tribeId !== -1 && this.tribeId === other.tribeId) {
                            canBond = true;
                            bondPriority = 3.0;
                        }
                        // 4. Neutral/friendly tribes (not at war) - medium priority
                        else if (this.tribeId !== -1 && other.tribeId !== -1 && this.tribeId !== other.tribeId) {
                            let tribalRelation = sim.tribes.getOpinion(this.tribeId, other.tribeId);
                            if (tribalRelation >= CONFIG.hateThreshold) { // Not at war
                                canBond = true;
                                bondPriority = 2.0;
                            }
                        }
                        // 5. No personal hate - low priority
                        else if (loyalty >= CONFIG.hateThreshold) {
                            canBond = true;
                            bondPriority = 1.0;
                        }
                        
                        if (canBond) {
                            let sameRole = this.role === other.role;
                            let bondChance = sameRole ? 0.005 : 0.05; 
                            bondChance *= bondPriority; // Apply priority multiplier
                            
                            let dnaDiff = Math.abs(this.dna.aggression - other.dna.aggression) + Math.abs(this.dna.speed - other.dna.speed);
                            if (dnaDiff > 0.5) bondChance *= 2.0; 
                            
                            // Rigid bond gene bonus: additive effect makes bonds form easier
                            let avgRigidPref = (this.dna.rigid_bond_preference + other.dna.rigid_bond_preference) / 2;
                            let rigidBonus = 1.0 + (avgRigidPref * CONFIG.rigidBondFormationBonus);
                            bondChance *= rigidBonus;
                            
                            // Apply nest-tethered penalty
                            bondChance *= nestBondPenalty;
                            
                            if (Math.random() < bondChance * CONFIG.bondingRate) {
                                this.addPartner(other);
                                other.addPartner(this);
                                // Visual effect: different color for rigid bonds
                                let willBeRigid = this.rigidBonds[other.id];
                                let color = willBeRigid ? '#ff6b6b' : '#ffffff';
                                sim.particles.push(new Particle(this.pos.x, this.pos.y, color, 'spark'));
                                // Bonding sound - keep this one as it's not high-intensity mating (just bond formation)
                            }
                        }
                    }

                    if (d < 20) {
                        if (this.disease > 0 && other.disease === 0 && other.immunity === 0) {
                            if (Math.random() < CONFIG.diseaseSpreadProb) other.disease = 500; 
                        }
                    }

                    if (isHater) {
                        for (let friend of localAgents) {
                            if (this.getNetLoyalty(friend) > 50 && friend !== other) friend.adjustLoyalty(other.id, -0.5);
                        }
                    }

                    // War (Only different tribes, not in bonded group)
                    let isEnemy = isHater;
                    let sizeAdvantage = this.dna.size > other.dna.size;
                    let huntScore = (this.dna.aggression * this.prefs.hunt);
                    if (this.dna.defending > 0.5 && myNest && Vector.dist(this.pos, myNest.pos) < 100) huntScore += 2.0; 
                    if (this.role === 'Soldier') huntScore += 0.5;
                    if (isHater) huntScore += 3.0; 

                    if (!amPredator && !amPrey && isEnemy && huntScore > 1.0 && sizeAdvantage && other.role !== 'Monster' && !isSameTribe && !isInBondedGroup) {
                         forces.hunt.add(this.seek(other.pos).mult(huntScore));
                         active = true; this.state = "War";
                         this.targetId = other.id;
                         if (d < this.radius + other.radius + 5) {
                             let myGroupBenefits = this.getGroupBenefits();
                             let otherGroupBenefits = other.getGroupBenefits();
                             let shield = other.skills.SHIELD || 0;
                             let dmg = (CONFIG.damageRate * 100) * myGroupBenefits.damageBonus / otherGroupBenefits.defenseBonus;
                             // Apply hunt bonus and shield bonus
                             dmg *= this.huntBonus;
                             dmg *= (1 - other.shieldBonus);
                             dmg = Math.max(1, dmg - shield); 
                             other.health -= dmg;
                             
                             // BLOODY PARTICLE SCATTER EFFECTS - Local bloody particles during combat
                             for (let i = 0; i < 3 + Math.floor(dmg / 5); i++) {
                                 let angle = Math.random() * Math.PI * 2;
                                 let dist = Math.random() * 15;
                                 let particleX = other.pos.x + Math.cos(angle) * dist;
                                 let particleY = other.pos.y + Math.sin(angle) * dist;
                                 // Blood particles - red variations with slight scatter
                                 let bloodColors = ['#dc2626', '#b91c1c', '#991b1b', '#ef4444'];
                                 let bloodColor = bloodColors[Math.floor(Math.random() * bloodColors.length)];
                                 sim.particles.push(new Particle(particleX, particleY, bloodColor, 'spark'));
                             }
                             sim.particles.push(new Particle(other.pos.x, other.pos.y, '#ef4444', 'spark'));
                             
                             // BATTLE SOUND - Track combat state and play every 10 frames during combat
                             this.inCombat = true;
                             this.lastCombatFrame = (typeof sim !== 'undefined' && sim.frame) ? sim.frame : 0;
                             
                             this.adjustLoyalty(other.id, -50);
                             if(!isKin && this.tribeId!==-1 && other.tribeId!==-1) {
                                 sim.tribes.updateOpinion(other.tribeId, this.tribeId, -1.0);
                             }
                             if(other.health<=0) { 
                                 this.kills++; 
                                 this.energy += 50; 
                                 this.wealth += other.wealth; // Loot
                                 other.wealth = 0;
                             }
                         }
                    } else if (this.role === 'Diplomat' && this.energy > 50 && !isSameTribe) {
                        // Diplomat Pacification and Diplomacy
                        forces.social = this.seek(other.pos).mult(1.5);
                        
                        if (isEnemy) {
                        this.state = "Pacifying";
                        } else if (other.tribeId !== -1) {
                            this.state = "Diplomacy";
                        }
                        
                        if (d < 30 && Math.random() < 0.05) {
                            this.energy -= 10;
                            other.adjustLoyalty(this.id, 10);
                            
                            if (other.tribeId !== -1) {
                                // Diplomats strengthen relations faster than decay (even with non-enemies)
                                sim.tribes.updateOpinion(other.tribeId, this.tribeId, 5.0);
                                sim.tribes.updateOpinion(this.tribeId, other.tribeId, 5.0);
                                
                                // Also strengthen diplomatic bonds
                                let myTribe = sim.tribes.tribes[this.tribeId];
                                let theirTribe = sim.tribes.tribes[other.tribeId];
                                if (myTribe && theirTribe) {
                                    myTribe.diplomaticBonds[other.tribeId] = Math.min(100, (myTribe.diplomaticBonds[other.tribeId] || 0) + 3);
                                    theirTribe.diplomaticBonds[this.tribeId] = Math.min(100, (theirTribe.diplomaticBonds[this.tribeId] || 0) + 3);
                                }
                            }
                            
                            sim.particles.push(new Particle(other.pos.x, other.pos.y, '#fde047', 'spark'));
                            sfx.play('diplomacy', 500 + Math.random() * 80, 0.15);
                            
                            // Recruit Unaffiliated
                            if (other.tribeId === -1 && Math.random() < 0.1) {
                                // Check for safety
                                if (sim.tribes.tribes[this.tribeId]) {
                                    other.tribeId = this.tribeId;
                                    other.color = sim.tribes.tribes[this.tribeId].color;
                                }
                            }
                        }
                    }

                    if (loyalty > 20 || isKin) {
                        alignment.add(other.vel);
                        cohesion.add(other.pos);
                        socialCount++;
                        let socialWeight = 0.5;
                        if (isLover) socialWeight = 2.0; 
                        if (isKin) socialWeight += CONFIG.kinAttractionStrength; // Configurable kin attraction
                        if (isSameTribe && !isKin) socialWeight += CONFIG.tribeAttractionStrength; // Configurable tribe attraction
                        forces.social.add(this.seek(other.pos).mult(socialWeight)); 
                    }
                }
                
                if (socialCount > 0) {
                    alignment.div(socialCount).normalize().mult(this.maxSpeed).sub(this.vel).limit(this.maxForce);
                    cohesion.div(socialCount).sub(this.pos).normalize().mult(this.maxSpeed).sub(this.vel).limit(this.maxForce);
                    forces.social.add(alignment).add(cohesion).mult(this.dna.social);
                    if(!active) this.state = "Flocking";
                }

                if (!active) {
                    forces.wander = this.wander().mult(0.8);
                }

                if (this.stuckCounter > 20) {
                    forces.wander = Vector.random2D().mult(this.maxForce * 5);
                    this.state = "Unsticking";
                }

                const agentForceList = [
                    forces.base, forces.food, forces.mine,
                    forces.raid, forces.trade, forces.hunt,
                    forces.flee, forces.social, forces.wander,
                    forces.bond
                ];
                let movementForce = new Vector(0, 0);
                let contributionCount = 0;
                agentForceList.forEach(f => {
                    if (!f) return;
                    if (f.mag() < 0.001) return;
                    movementForce.add(f);
                    contributionCount++;
                });
                if (contributionCount > 0) {
                    movementForce.div(contributionCount);
                    this.applyForce(movementForce);
                }
            }

            converterInteract(resources) {
                if (!resources || resources.length === 0) return;
                let target = null;
                let range = Math.min(this.senseRad, 80);
                resources.forEach(r => {
                    if (!r.active || r.type !== this.converterSource) return;
                    let d = Vector.dist(this.pos, r.pos);
                    if (d < range) {
                        if (!target || d < Vector.dist(this.pos, target.pos)) {
                            target = r;
                        }
                    }
                });
                if (target) {
                    target.active = false;
                    let energyGain = (target.config.val || 10) * 0.8 + 15;
                    this.applyGroupEnergyGain(energyGain);
                    this.convertResourceResidue(target.type, target.pos);
                    sim.particles.push(new Particle(this.pos.x, this.pos.y, '#f97316', 'spark'));
                }
            }

            runConverterBonding(sim, agents) {
                if (!this.ownerGroupAgent || !agents || !sim) return;
                let now = sim.frame || 0;
                if (!this.lastBondAttempt) this.lastBondAttempt = -Infinity;
                if (now - this.lastBondAttempt < 220) return;
                let range = 90;
                let converters = agents.filter(a => 
                    a.isConverterUnit && !a.dead && 
                    a.converterOwner === this.ownerGroupAgent &&
                    Vector.dist(this.pos, a.pos) < range
                );
                if (converters.length >= 2) {
                    this.ownerGroupAgent.formConverterBondGroup(converters.slice(0, Math.min(converters.length, 3)), sim);
                    this.lastBondAttempt = now;
                }
            }

            // MATING CHECK
            checkMating(localAgents) {
                if (this.mateCooldown > 0 || !this.isAdult()) return;
                // Reduced energy threshold for mating - small agents need less energy to mate
                let energyThreshold = this.isGroupEntity ? 0.6 : 0.4; // Group agents need more energy
                if (this.energy < this.maxEnergy * energyThreshold) return; 
                if (this.role === 'Monster') return; // Monsters don't breed
                
                // PERFORMANCE: Self-limiting - check local density and recent births
                if (typeof sim !== 'undefined' && sim.frame) {
                    // Count nearby agents (local density check)
                    let nearbyCount = 0;
                    let densityCheckRadius = 100; // Check within 100px
                    for (let agent of localAgents) {
                        if (agent !== this && !agent.dead) {
                            let d = Vector.dist(this.pos, agent.pos);
                            if (d < densityCheckRadius) {
                                nearbyCount++;
                            }
                        }
                    }
                    
                    // If too many agents nearby, reduce mating chance significantly
                    if (nearbyCount > 15) {
                        // Very dense area - 80% reduction in mating chance
                        if (Math.random() > 0.2) return; // 80% chance to skip mating
                    } else if (nearbyCount > 10) {
                        // Dense area - 50% reduction
                        if (Math.random() > 0.5) return;
                    }
                    
                    // Check for recent births in this area (prevent sustained explosions)
                    let gridCellSize = 150; // Match spatial grid cell size
                    let cellX = Math.floor(this.pos.x / gridCellSize);
                    let cellY = Math.floor(this.pos.y / gridCellSize);
                    let cellKey = `${cellX},${cellY}`;
                    
                    // Count recent births in this cell (last 180 frames = 3 seconds)
                    let recentBirthCount = 0;
                    if (sim.recentBirths) {
                        for (let birth of sim.recentBirths) {
                            if (sim.frame - birth.frame < 180) {
                                let birthCellX = Math.floor(birth.x / gridCellSize);
                                let birthCellY = Math.floor(birth.y / gridCellSize);
                                if (birthCellX === cellX && birthCellY === cellY) {
                                    recentBirthCount++;
                                }
                            }
                        }
                    }
                    
                    // If too many recent births in this area, apply cooldown
                    if (recentBirthCount > 20) {
                        // Very high recent birth rate - 90% reduction
                        if (Math.random() > 0.1) return;
                    } else if (recentBirthCount > 10) {
                        // High recent birth rate - 70% reduction
                        if (Math.random() > 0.3) return;
                    }
                    
                    // Check cell cooldown (temporary block after explosion)
                    if (sim.matingExplosionCooldown && sim.matingExplosionCooldown[cellKey]) {
                        if (sim.matingExplosionCooldown[cellKey] > sim.frame) {
                            return; // Cell is in cooldown, skip mating
                        } else {
                            // Cooldown expired, remove it
                            delete sim.matingExplosionCooldown[cellKey];
                        }
                    }
                }

                for(let other of localAgents) {
                    if (other !== this && other.isAdult() && other.mateCooldown === 0) {
                        // Match energy threshold
                        let otherEnergyThreshold = other.isGroupEntity ? 0.6 : 0.4;
                        if (other.energy <= other.maxEnergy * otherEnergyThreshold) continue;
                        let d = Vector.dist(this.pos, other.pos);
                        if (d < this.radius + other.radius) {
                            // GARBAGE COLLECTOR MATING RESTRICTIONS
                            if (this.role === 'Garbage Collector' || other.role === 'Garbage Collector') {
                                let gcAllowedMates = ['Garbage Collector', 'Leader', 'Miner', 'Builder', 'Botanist'];
                                let canMate = gcAllowedMates.includes(this.role) && gcAllowedMates.includes(other.role);
                                if (!canMate) continue; // Skip this pairing
                            }
                            
                            let isKin = this.tribeId === other.tribeId;
                            let isSimilar = isKin || this.role === other.role;
                            let mateChance = isSimilar ? 1.0 : 0.3; 
                            
                            // GROUP SIZE AMPLIFICATION - Larger groups have higher mating rates
                            let myGroup = this.getCachedBondedGroup();
                            let otherGroup = other.getCachedBondedGroup();
                            let myGroupSize = myGroup.length;
                            let otherGroupSize = otherGroup.length;
                            let maxGroupSize = Math.max(myGroupSize, otherGroupSize);
                            
                            // Amplify mating rate based on group size
                            // Group size 2-3: 1.2x, 4-6: 1.5x, 7-10: 2.0x, 11+: 2.5x
                            let groupSizeMultiplier = 1.0;
                            if (maxGroupSize >= 11) {
                                groupSizeMultiplier = 2.5; // Very large groups: 2.5x mating rate
                            } else if (maxGroupSize >= 7) {
                                groupSizeMultiplier = 2.0; // Large groups: 2.0x mating rate
                            } else if (maxGroupSize >= 4) {
                                groupSizeMultiplier = 1.5; // Medium groups: 1.5x mating rate
                            } else if (maxGroupSize >= 2) {
                                groupSizeMultiplier = 1.2; // Small groups: 1.2x mating rate
                            }
                            // Solo agents (groupSize = 1) keep 1.0x multiplier
                            
                            // Apply group size amplification to mate chance (up to 1.0 cap)
                            mateChance *= groupSizeMultiplier;
                            mateChance = Math.min(1.0, mateChance); // Cap at 1.0
                            
                            // NEW NEST FERTILITY BOOST - 10% higher mate chance for new nests (first 1000 frames)
                            if (typeof sim !== 'undefined' && sim.tribes) {
                                let myNest = sim.tribes.nests.find(n => n.tribeId === this.tribeId);
                                let otherNest = sim.tribes.nests.find(n => n.tribeId === other.tribeId);
                                let myNestAge = myNest ? (sim.frame - myNest.creationFrame) : Infinity;
                                let otherNestAge = otherNest ? (sim.frame - otherNest.creationFrame) : Infinity;
                                // If either nest is new (< 1000 frames), boost mate chance by 10%
                                if (myNestAge < 1000 || otherNestAge < 1000) {
                                    mateChance *= 1.1;
                                    mateChance = Math.min(1.0, mateChance); // Cap at 1.0
                                }
                            }
                            
                            if (Math.random() < mateChance) {
                                // NEW NEST FERTILITY BOOST - 10% higher birth/mating rates for new nests (first 1000 frames)
                                let newNestBonus = 1.0;
                                if (typeof sim !== 'undefined' && sim.tribes) {
                                    let myNest = sim.tribes.nests.find(n => n.tribeId === this.tribeId);
                                    let otherNest = sim.tribes.nests.find(n => n.tribeId === other.tribeId);
                                    let myNestAge = myNest ? (sim.frame - myNest.creationFrame) : Infinity;
                                    let otherNestAge = otherNest ? (sim.frame - otherNest.creationFrame) : Infinity;
                                    // If either nest is new (< 1000 frames), apply 10% boost
                                    if (myNestAge < 1000 || otherNestAge < 1000) {
                                        newNestBonus = 1.1;
                                    }
                                }
                                
                                // WEALTH EFFECT ON REPRODUCTION
                                let familyWealth = this.wealth + other.wealth;
                                let wealthBonus = Math.min(0.8, familyWealth / 2000); // Up to 80% cooldown reduction
                                
                                // SIGNIFICANTLY INCREASED OFFSPRING - helps tribes grow populations and progress tech faster
                                let r = Math.random();
                                let numChildren = 5; // Base increased from 2 to 5 (2.5x increase)
                                if (r < 0.15) numChildren = 10; // Very large families
                                else if (r < 0.35) numChildren = 9;
                                else if (r < 0.55) numChildren = 8;
                                else if (r < 0.75) numChildren = 7;
                                else if (r < 0.85) numChildren = 6;

                                // Track birth location for self-limiting
                                let birthX = (this.pos.x + other.pos.x) / 2;
                                let birthY = (this.pos.y + other.pos.y) / 2;

                                for(let i=0; i<numChildren; i++) {
                                    sim.spawnChild(this, other);
                                    // Track each birth for self-limiting
                                    if (typeof sim !== 'undefined' && sim.frame && sim.recentBirths) {
                                        sim.recentBirths.push({x: birthX, y: birthY, frame: sim.frame});
                                    }
                                }
                                
                                // PERFORMANCE: If too many births, trigger cell cooldown (self-limiting)
                                if (typeof sim !== 'undefined' && sim.frame) {
                                    let gridCellSize = 150;
                                    let cellX = Math.floor(birthX / gridCellSize);
                                    let cellY = Math.floor(birthY / gridCellSize);
                                    let cellKey = `${cellX},${cellY}`;
                                    
                                    // Count recent births in this cell
                                    let recentBirthCount = 0;
                                    if (sim.recentBirths) {
                                        for (let birth of sim.recentBirths) {
                                            if (sim.frame - birth.frame < 180) {
                                                let birthCellX = Math.floor(birth.x / gridCellSize);
                                                let birthCellY = Math.floor(birth.y / gridCellSize);
                                                if (birthCellX === cellX && birthCellY === cellY) {
                                                    recentBirthCount++;
                                                }
                                            }
                                        }
                                    }
                                    
                                    // If explosion detected (>30 births in 3 seconds), add cooldown
                                    if (recentBirthCount > 30) {
                                        if (!sim.matingExplosionCooldown) sim.matingExplosionCooldown = {};
                                        sim.matingExplosionCooldown[cellKey] = sim.frame + 180; // 3 second cooldown
                                    }
                                }
                                
                                // Apply group size amplification to birth rate as well (for cooldown reduction)
                                let effectiveBirthRate = CONFIG.birthRate * sim.dynamicBirthRateMult * newNestBonus * groupSizeMultiplier;
                                
                                // GROUP SIZE ENERGY COST REDUCTION - Larger groups have lower mating energy costs
                                // Energy cost reduction based on group size:
                                // Solo (1): 0% reduction (full cost)
                                // Small groups (2-3): 20% reduction
                                // Medium groups (4-6): 40% reduction
                                // Large groups (7-10): 60% reduction
                                // Very large groups (11+): 75% reduction
                                let energyCostReduction = 0.0;
                                if (maxGroupSize >= 11) {
                                    energyCostReduction = 0.75; // 75% cost reduction for very large groups
                                } else if (maxGroupSize >= 7) {
                                    energyCostReduction = 0.60; // 60% cost reduction for large groups
                                } else if (maxGroupSize >= 4) {
                                    energyCostReduction = 0.40; // 40% cost reduction for medium groups
                                } else if (maxGroupSize >= 2) {
                                    energyCostReduction = 0.20; // 20% cost reduction for small groups
                                }
                                // Solo agents (maxGroupSize = 1) have 0% reduction (full cost)
                                
                                let mateCost = CONFIG.mateCost * (1.0 - energyCostReduction);
                                let cd = (300 / effectiveBirthRate) * (1.0 - wealthBonus); // Wealthy breed faster, groups breed faster

                                this.energy -= mateCost; 
                                this.mateCooldown = cd; 
                                other.mateCooldown = cd;
                                other.energy -= mateCost; 
                                
                                this.adjustLoyalty(other.id, 50);
                                other.adjustLoyalty(this.id, 50);
                                
                                // LOVE PLAY - Track mating state and play sounds every 10 frames during mating
                                this.isMating = true;
                                this.lastMatingFrame = (typeof sim !== 'undefined' && sim.frame) ? sim.frame : 0;
                                
                                // VFX - Heart particles
                                sim.particles.push(new Particle(this.pos.x, this.pos.y, '#ec4899', 'heart')); 
                                sim.particles.push(new Particle(other.pos.x, other.pos.y, '#ec4899', 'heart')); 
                                
                                // Additional romantic sparkles
                                for (let i = 0; i < 3; i++) {
                                    let angle = (i / 3) * Math.PI * 2;
                                    let dist = 10 + Math.random() * 10;
                                    let sparkleX = (this.pos.x + other.pos.x) / 2 + Math.cos(angle) * dist;
                                    let sparkleY = (this.pos.y + other.pos.y) / 2 + Math.sin(angle) * dist;
                                    sim.particles.push(new Particle(sparkleX, sparkleY, '#f472b6', 'star')); // Pink sparkles
                                }
                                
                                return; 
                            }
                        }
                    }
                }
            }

            addPartner(p, bondType) {
                if (this.isNestTool || (p && p.isNestTool)) return;
                if (!p || this.partners.includes(p)) return;
                
                // PREVENT ENEMY BONDS - Check if agents are enemies
                if (this.tribeId !== -1 && p.tribeId !== -1 && typeof sim !== 'undefined' && sim.tribes) {
                    let tribe1 = sim.tribes.tribes[this.tribeId];
                    let tribe2 = sim.tribes.tribes[p.tribeId];
                    if (tribe1 && tribe2) {
                        // Check if tribes are at war
                        if (tribe1.atWarWith && tribe1.atWarWith[p.tribeId] === true) {
                            return; // Cannot bond with enemies
                        }
                        if (tribe2.atWarWith && tribe2.atWarWith[this.tribeId] === true) {
                            return; // Cannot bond with enemies
                        }
                        // Check if opinion is below hate threshold
                        let opinion = sim.tribes.getOpinion(this.tribeId, p.tribeId);
                        if (opinion < (CONFIG.hateThreshold || -40)) {
                            return; // Cannot bond if opinion is too low
                        }
                    }
                }
                
                let groupSize = this.getBondedGroup().length;
                let withinBand = groupSize >= CONFIG.stableGroupMinMembers && groupSize <= CONFIG.stableGroupMaxMembers;
                let stabilityFraction = ((this.structureStability + (p.structureStability || 0)) / 2) / CONFIG.structureStabilityCap;
                let bandFactor = withinBand ? CONFIG.structureStabilityBandBonus : 0.65;
                let blockChance = Math.min(0.95, stabilityFraction * bandFactor);
                if (Math.random() < blockChance) return;
                    // FOOD CHAIN BONDING RESTRICTIONS
                    // Predators can only bond with predators
                    if (this.isPredator && !p.isPredator) return;
                    if (p.isPredator && !this.isPredator) return;
                    
                    // Prey can only bond with prey or farmers
                    if (this.isPrey && !(p.isPrey || p.role === 'Farmer')) return;
                    if (p.isPrey && !(this.isPrey || this.role === 'Farmer')) return;
                    
                    // Garbage Collectors can only bond with other GCs
                    if (this.role === 'Garbage Collector' && p.role !== 'Garbage Collector') return;
                    if (p.role === 'Garbage Collector' && this.role !== 'Garbage Collector') return;
                    
                    // SOLDIER BONDING RULES
                    // Soldiers bond ONLY with soldiers from same or allied tribes, and with diplomats/merchants from same tribe
                    if (this.role === 'Soldier') {
                        if (p.role === 'Soldier') {
                            // Can bond with soldiers from same or allied tribes
                            let relation = this.tribeId === p.tribeId ? 100 : (typeof sim !== 'undefined' ? sim.tribes.getOpinion(this.tribeId, p.tribeId) : 0);
                            if (relation < 20) return; // Only bond if allied (relation >= 20)
                        } else if (p.role === 'Diplomat' || p.role === 'Merchant') {
                            // Can bond with diplomats/merchants from SAME TRIBE ONLY (to protect them)
                            if (this.tribeId !== p.tribeId) return;
                        } else {
                            // Don't bond with other roles from other tribes
                            if (this.tribeId !== p.tribeId) return;
                        }
                    }
                    
                    // Mirror for partner being soldier
                    if (p.role === 'Soldier') {
                        if (this.role === 'Soldier') {
                            let relation = this.tribeId === p.tribeId ? 100 : (typeof sim !== 'undefined' ? sim.tribes.getOpinion(this.tribeId, p.tribeId) : 0);
                            if (relation < 20) return;
                        } else if (this.role === 'Diplomat' || this.role === 'Merchant') {
                            if (this.tribeId !== p.tribeId) return;
                        } else {
                            if (this.tribeId !== p.tribeId) return;
                        }
                    }
                    
                    // MERCHANT/DIPLOMAT BONDING RULES
                    // Merchants prefer bonding with merchants (especially same tribe)
                    if (this.role === 'Merchant') {
                        // Can bond with merchants from non-enemy tribes
                        if (p.role === 'Merchant') {
                            let relation = this.tribeId === p.tribeId ? 100 : (typeof sim !== 'undefined' ? sim.tribes.getOpinion(this.tribeId, p.tribeId) : 0);
                            if (relation < -20) return; // Don't bond with enemy merchants
                            // Otherwise allow (for cross-tribe trade networks)
                        } else if (p.role !== 'Diplomat' && this.tribeId !== p.tribeId) {
                            // Merchants don't bond with non-merchants from other tribes (except diplomats)
                            return;
                        }
                    }
                    
                    // Diplomats prefer bonding with diplomats/merchants (especially same tribe)
                    if (this.role === 'Diplomat') {
                        // Can bond with diplomats/merchants from non-enemy tribes
                        if (p.role === 'Diplomat' || p.role === 'Merchant') {
                            let relation = this.tribeId === p.tribeId ? 100 : (typeof sim !== 'undefined' ? sim.tribes.getOpinion(this.tribeId, p.tribeId) : 0);
                            if (relation < -10) return; // Don't bond with enemy diplomats
                        } else if (this.tribeId !== p.tribeId) {
                            // Diplomats don't bond with non-diplomatic roles from other tribes
                            return;
                        }
                    }
                    
                    // Mirror rules for partner
                    if (p.role === 'Merchant' || p.role === 'Diplomat') {
                        if (this.role !== 'Merchant' && this.role !== 'Diplomat' && this.tribeId !== p.tribeId) {
                            return;
                        }
                    }
                    
                    this.partners.push(p);
                    // PERFORMANCE OPTIMIZATION: Invalidate cache when bonds change
                    this._invalidateGroupBenefitsCache();
                    if (p && typeof p._invalidateGroupBenefitsCache === 'function') p._invalidateGroupBenefitsCache();
                    // Invalidate cache when partner is added (but throttled during high activity)
                    this.invalidateGroupCache();
                    if (p && typeof p.invalidateGroupCache === 'function') p.invalidateGroupCache();
                this.invalidateGroupCache();
                if (typeof p.invalidateGroupCache === 'function') p.invalidateGroupCache();
                // Update group formation frame when a new partner is added (only if this is the first partner or group is newly forming)
                if (this.partners.length === 1 || !this.groupFormationFrame) {
                    this.groupFormationFrame = typeof sim !== 'undefined' ? sim.frame : 0;
                }
                if (p && (!p.groupFormationFrame || p.partners.length === 1)) {
                    p.groupFormationFrame = typeof sim !== 'undefined' ? sim.frame : 0;
                }
                    
                    // Determine if bond should be rigid and what type based on both partners' genes
                    let avgRigidPref = (this.dna.rigid_bond_preference + p.dna.rigid_bond_preference) / 2;
                    let isRigid = Math.random() < avgRigidPref; // Additive effect
                    
                    if (isRigid) {
                        // Determine rigid bond type based on combined traits
                        let rigidTypes = {
                            shield: (this.dna.defense + p.dna.defense) / 2, // Defensive pair
                            hunt: (this.dna.aggression + p.dna.aggression) / 2, // Hunting pair
                            gather: (this.dna.botany + this.dna.manufacturing + p.dna.botany + p.dna.manufacturing) / 4, // Resource pair
                            swift: (this.dna.speed + p.dna.speed) / 2 // Movement pair
                        };
                        
                        // Find strongest rigid bond type
                        let maxVal = -1;
                        let rigidType = 'shield';
                        for (let type in rigidTypes) {
                            if (rigidTypes[type] > maxVal) {
                                maxVal = rigidTypes[type];
                                rigidType = type;
                            }
                        }
                        this.rigidBonds[p.id] = rigidType;
                    } else {
                        this.rigidBonds[p.id] = null; // Elastic bond
                    }
                    
                    // Assign bond type based on genes if not specified
                    if (!bondType) {
                        // Calculate weighted preferences
                        let prefs = {
                            family: this.dna.family_bond_pref * (this.kin.includes(p.id) ? 2.0 : 0.5),
                            romantic: this.dna.romantic_bond_pref * (this.getNetLoyalty(p) > 80 ? 1.5 : 0.8),
                            mentor: this.dna.mentor_bond_pref * (Math.abs(this.generation - p.generation) > 3 ? 2.0 : 0.3),
                            alliance: this.dna.alliance_bond_pref * (this.tribeId === p.tribeId && this.tribeId !== -1 ? 1.5 : 0.5),
                            friendship: this.dna.friendship_bond_pref
                        };
                        
                        // Find bond type with highest weighted preference
                        let maxPref = -1;
                        let chosenType = 'friendship';
                        for (let type in prefs) {
                            if (prefs[type] > maxPref) {
                                maxPref = prefs[type];
                                chosenType = type;
                            }
                        }
                        bondType = chosenType;
                    }
                    this.bondTypes[p.id] = bondType;
            }
            
            removePartner(p) {
                this.partners = this.partners.filter(partner => partner !== p);
                if (p && p.id) {
                    delete this.bondTypes[p.id];
                    delete this.rigidBonds[p.id];
                }
                this.invalidateGroupCache();
                if (p && typeof p.invalidateGroupCache === 'function') p.invalidateGroupCache();
                // PERFORMANCE OPTIMIZATION: Invalidate cache when bonds change
                this._invalidateGroupBenefitsCache();
                if (p && typeof p._invalidateGroupBenefitsCache === 'function') p._invalidateGroupBenefitsCache();
            }

            breakAllBonds() {
                this.partners.forEach(p => p.removePartner(this));
                this.partners = [];
                this.bondTypes = {};
                this.rigidBonds = {};
                this.invalidateGroupCache();
                // PERFORMANCE OPTIMIZATION: Invalidate cache when bonds change
                this._invalidateGroupBenefitsCache();
            }
            
            getGroupSize() {
                return this.getBondedGroup().length;
            }

            getRigidBondCount() {
                return Object.values(this.rigidBonds).filter(Boolean).length;
            }

            getGroupSynergies(group) {
                let synergy = {
                    propulsion: 1,
                    gatherRange: 1,
                    sensing: 1,
                    conversion: 1,
                    combatFocus: 1,
                    defenseFocus: 1
                };
                group.forEach(member => {
                    if (!member || member.dead) return;
                    switch(member.role) {
                        case 'Scout':
                        case 'Raider':
                            synergy.propulsion += 0.08;
                            break;
                        case 'Miner':
                        case 'Artisan':
                            synergy.conversion += 0.12;
                            synergy.gatherRange += 0.05;
                            break;
                        case 'Farmer':
                        case 'Botanist':
                            synergy.gatherRange += 0.1;
                            break;
                        case 'Guardian':
                            synergy.defenseFocus += 0.12;
                            break;
                        case 'Soldier':
                            synergy.combatFocus += 0.15;
                            break;
                        case 'Teacher':
                        case 'Scientist':
                            synergy.sensing += 0.1;
                            break;
                        case 'Diplomat':
                        case 'Merchant':
                            synergy.conversion += 0.08;
                            synergy.sensing += 0.05;
                            break;
                    }
                });
                return synergy;
            }
            
            getGroupStrength(group) {
                group = group || this.getCachedBondedGroup();
                let strength = 0;
                for (let member of group) {
                    if (!member || member.dead) continue;
                    strength += member.health + member.energy + (member.structureStability || 0) * 0.6 + member.radius * 2;
                }
                return strength + group.length * 25;
            }
            
            getGroupBenefits() {
                // PERFORMANCE OPTIMIZATION: Cache group benefits for 3-5 frames to reduce expensive calculations
                if (typeof sim !== 'undefined') {
                    let cacheInterval = 3; // Cache for 3 frames
                    if (this._groupBenefitsCache && this._groupBenefitsCacheFrame !== undefined) {
                        let framesSinceCache = sim.frame - this._groupBenefitsCacheFrame;
                        if (framesSinceCache < cacheInterval) {
                            return this._groupBenefitsCache;
                        }
                    }
                }
                
                let group = this.getCachedBondedGroup();
                let groupSize = group.length;
                let synergies = this.getGroupSynergies(group);
                let rigidBonus = 1 + (this.getRigidBondCount() * 0.2);
                let benefits = {
                    rangeBonus: (1 + (groupSize * CONFIG.groupRangeBonus)) * synergies.sensing,
                    damageBonus: (1 + (groupSize * CONFIG.groupDamageBonus)) * synergies.combatFocus * rigidBonus,
                    defenseBonus: (1 + (groupSize * CONFIG.groupDefenseBonus)) * synergies.defenseFocus * rigidBonus,
                    healingBonus: 1 + (groupSize * CONFIG.groupHealingBonus),
                    energyMultiplier: 1 + (groupSize * CONFIG.groupEnergyCost),
                    propulsionBoost: 1 + synergies.propulsion,
                    gatherRangeBonus: 1 + synergies.gatherRange,
                    conversionBonus: synergies.conversion
                };
                
                // Cache the result
                if (typeof sim !== 'undefined') {
                    this._groupBenefitsCache = benefits;
                    this._groupBenefitsCacheFrame = sim.frame;
                }
                
                return benefits;
            }
            
            // PERFORMANCE OPTIMIZATION: Invalidate group benefits cache when bonds change
            _invalidateGroupBenefitsCache() {
                this._groupBenefitsCache = null;
                this._groupBenefitsCacheFrame = undefined;
            }

            attemptGroupAscension() {
                if (typeof sim === 'undefined') return;
                if (this.dead || this.isGroupEntity) return;
                if (!this.structureBandActive) return;
                let group = this.getCachedBondedGroup().filter(member => member && !member.dead);
                if (group.length < CONFIG.groupAgentMinMembers || group.length > CONFIG.groupAgentMaxMembers) return;
                if (group.some(member => member.isGroupEntity)) return;
                let avgStability = group.reduce((sum, member) => sum + member.structureStability, 0) / group.length;
                if (avgStability < CONFIG.groupAgentStabilityThreshold) return;
                // Check minimum group age - group must have existed for at least groupAgentMinAge frames
                let minFormationFrame = Math.min(...group.map(m => m.groupFormationFrame || sim.frame));
                let groupAge = sim.frame - minFormationFrame;
                if (groupAge < (CONFIG.groupAgentMinAge || 2000)) return;
                if (sim.frame - this.groupAscendedFrame < CONFIG.groupAgentAscensionCooldown) return;
                if (Math.random() > CONFIG.groupAgentAscensionChance) return;
                this.promoteGroupAgent(group, sim);
            }

            promoteGroupAgent(group, sim) {
                if (!sim || group.length === 0) return;
                let center = new Vector(0, 0);
                group.forEach(member => center.add(member.pos));
                center.div(group.length);
                let aggregatedDna = this.aggregateGroupDNA(group);
                let groupAgent = new Agent(center.x, center.y, aggregatedDna, null, this.tribeId);
                groupAgent.isGroupEntity = true;
                groupAgent.groupEntityMembers = group.map(member => member.id);
                groupAgent.groupEntityLevel = group.length;
                // PERFORMANCE OPTIMIZATION: Initialize polygon cache
                groupAgent._cachedSides = undefined;
                groupAgent._cachedSidesLevel = undefined;
                let rawRadius = Math.min(CONFIG.groupAgentBaseRadius + group.length * 3, 60);
                groupAgent.baseRadius = rawRadius * 0.3;
                groupAgent.radius = groupAgent.baseRadius;
                groupAgent.maxHealth = Math.min(groupAgent.maxHealth + group.length * 12, 1400);
                groupAgent.health = groupAgent.maxHealth;
                groupAgent.baseSpeed = Math.max(0.25, groupAgent.baseSpeed * 0.9);
                groupAgent.maxSpeed = groupAgent.baseSpeed;
                groupAgent.structureStability = CONFIG.structureStabilityCap;
                groupAgent.structureBandActive = true;
                groupAgent.groupAscendedFrame = sim.frame;
                groupAgent.groupAscended = true;
                let color = sim.tribes && sim.tribes.tribes[this.tribeId] ? sim.tribes.tribes[this.tribeId].color : '#fff';
                groupAgent.color = color;
                groupAgent.converterBondGroups = [];
                groupAgent.groupEntityParent = this;
                group.forEach(member => {
                    member.dead = true;
                    member.breakAllBonds();
                    member.groupEntityParent = groupAgent;
                    member.groupAscended = true;
                    member.groupEntityLevel = group.length;
                    // PERFORMANCE OPTIMIZATION: Invalidate polygon cache when level changes
                    member._cachedSides = undefined;
                    member._cachedSidesLevel = undefined;
                    member._cachedPolygonVertices = null;
                    member._cachedInnerVertices = null;
                });
                sim.agents.push(groupAgent);
                sim.particles.push(new Particle(center.x, center.y, '#f472b6', 'star'));
                
                // GROUP AGENT BIRTH SOUND - Play special positive ascending harmonic chord when group agent is formed
                // Use beautiful ascending major chord progression
                if (typeof sfx !== 'undefined' && sfx.enabled) {
                    // Play a pleasant ascending chord: A4 -> C5 -> E5 (A major chord)
                    setTimeout(() => sfx.play('bond', HARMONICS.A4, 0.15), 0);
                    setTimeout(() => sfx.play('bond', HARMONICS.C5, 0.15), 50);
                    setTimeout(() => sfx.play('bond', HARMONICS.E5, 0.15), 100);
                    setTimeout(() => sfx.play('bond', HARMONICS.G5, 0.12), 150);
                }
                
                this.groupAscendedFrame = sim.frame;
                this.groupAscended = true;
            }

            aggregateGroupDNA(group) {
                if (!group.length) return {};
                let sample = group[0].dna;
                let aggregated = {};
                for (let gene in sample) {
                    let value = sample[gene];
                    if (typeof value === 'number') {
                        let total = group.reduce((sum, member) => sum + (member.dna[gene] || 0), 0);
                        let avg = total / group.length;
                        avg += (Math.random() * 0.04 - 0.02);
                        aggregated[gene] = Math.max(0, Math.min(1, avg));
                    } else if (Array.isArray(value)) {
                        let source = group[Math.floor(Math.random() * group.length)].dna[gene];
                        aggregated[gene] = Array.isArray(source) ? [...source] : [...value];
                    } else {
                        aggregated[gene] = value;
                    }
                }
                return aggregated;
            }

            formConverterBondGroup(converters, sim) {
                if (!sim || !converters || converters.length < 2) return;
                converters = converters.filter(c => c && !c.dead);
                if (converters.length < 2) return;
                for (let i = 0; i < converters.length; i++) {
                    for (let j = i + 1; j < converters.length; j++) {
                        converters[i].addPartner(converters[j]);
                        converters[j].addPartner(converters[i]);
                        converters[i].rigidBonds[converters[j].id] = 'convert';
                        converters[j].rigidBonds[converters[i].id] = 'convert';
                    }
                }
                this.converterBondGroups = this.converterBondGroups.filter(g => g && g.converters && !g.converters.every(c => c.dead));
                this.converterBondGroups.push({
                    converters: converters,
                    expiry: sim.frame + 360
                });
            }

            cleanupConverterBonds(sim) {
                if (!sim || !this.converterBondGroups) return;
                let now = sim.frame || 0;
                this.converterBondGroups = this.converterBondGroups.filter(group => {
                    if (now > group.expiry) {
                        group.converters.forEach(c => {
                            if (c && !c.dead) {
                                c.breakAllBonds();
                            }
                        });
                        return false;
                    }
                    return true;
                });
            }

            attemptSpawnConverterBonder(sim) {
                if (!this.isGroupEntity || !sim) return;
                let now = sim.frame || 0;
                if (now - this.lastBonderSpawnFrame < 600) return;
                if (Math.random() < 0.3) {
                    sim.spawnConverterBonder(this);
                    this.lastBonderSpawnFrame = now;
                }
            }

            huntNearbyGroupResources(resources) {
                if (!this.isGroupEntity || !resources || resources.length === 0) return;
                let range = Math.min(CONFIG.groupCombatRange || 230, Math.max(this.radius * 1.2, 40));
                let best = null;
                let bestScore = -Infinity;
                
                // PERFORMANCE OPTIMIZATION: Use spatial grid for group entity resource hunting
                let nearbyResources = [];
                if (typeof sim !== 'undefined' && sim.spatialGrid && sim.gridCols > 0) {
                    let nearby = sim.getNearbyEntities(this.pos.x, this.pos.y, range);
                    nearbyResources = nearby.resources;
                } else {
                    // Fallback to brute force
                    nearbyResources = resources.filter(r => r.active && Vector.dist(this.pos, r.pos) < range);
                }
                
                nearbyResources.forEach(r => {
                    if (!r.active) return;
                    let d = Vector.dist(this.pos, r.pos);
                    if (d > range) return;
                    let weight = 3.0;
                    switch (r.type) {
                        // Resource gathering weights - scaled to match value scale (higher value = higher priority)
                        case 'FOOD': weight = 2.0; break;      // Lowest priority - least valuable
                        case 'SEED': weight = 2.5; break;
                        case 'MAT': weight = 3.5; break;
                        case 'STIM': weight = 4.0; break;
                        case 'HERB': weight = 4.5; break;
                        case 'ORE': weight = 5.5; break;       // High priority - valuable
                        case 'RELIC': weight = 7.0; break;     // Very high priority
                        case 'UNIQUE': weight = 8.0; break;    // Extremely high priority
                        case 'TREASURE': weight = 10.0; break; // Highest priority - super valuable
                    }
                    let score = weight - d * 0.02;
                    if (score > bestScore) {
                        bestScore = score;
                        best = r;
                    }
                });
                if (best) {
                    best.active = false;
                    this.applyGroupEnergyGain(weightedResourceEnergy(best.type));
                    sim.tribes && giveNestWealth(this.tribeId, best.type, best);
                    this.convertResourceResidue(best.type, best.pos);
                    sim.particles.push(new Particle(best.pos.x, best.pos.y, '#f59e0b', 'spark'));
                }
            }

            consumeNearbyEnemiesForEnergy(agents) {
                // DISABLED: Group agents no longer automatically eat other agents on collision
                // They must fight, bond, or ignore through normal interactions instead
                // Group agents can still gain energy/resources when enemies die through normal combat
                // but they don't automatically consume on collision
                return;
            }

            excreteResourcesOnKill(enemy) {
                if (!enemy || !sim) return;
                let dropTypes = ['FOOD', 'MAT', 'ORE'];
                if (enemy.isPredator) dropTypes.push('TREASURE');
                let type = dropTypes[Math.floor(Math.random() * dropTypes.length)];
                let value = Math.random();
                sim.spawnResource(null, enemy.pos.x + (Math.random()*20-10), enemy.pos.y + (Math.random()*20-10), type, false, this.tribeId);
            }

            applyGroupEnergyGain(amount) {
                if (!amount) return;
                this.energy = Math.min(this.maxEnergy, this.energy + amount);
                let nest = sim.tribes && sim.tribes.nests.find(n => n.tribeId === this.tribeId);
                if (nest) {
                    nest.wealth += amount * 0.25;
                }
                let tribe = sim.tribes && sim.tribes.tribes[this.tribeId];
                if (tribe) {
                    tribe.wealth = (tribe.wealth || 0) + amount * 0.15;
                }
            }

            convertResourceResidue(originalType, pos) {
                if (!originalType || typeof sim === 'undefined') return;
                if (Math.random() > 0.5) return; // only drop 50% of what consumed
                const pool = ['FOOD','MAT','ORE','HERB','TREASURE'];
                let idx = Math.floor((this.dna.resource_conversion_preference || 0) * pool.length);
                idx = idx % pool.length;
                let target = pool[idx];
                if (target === originalType) target = pool[(idx + 1) % pool.length];
                let dropPos = new Vector(pos.x + (Math.random()*6-3), pos.y + (Math.random()*6-3));
                sim.spawnResource(null, dropPos.x, dropPos.y, target, false, this.tribeId);
            }

            spawnDeathResource() {
                if (typeof sim === 'undefined') return;
                const deathDrops = [
                    { type: 'FOOD', weight: 3 },
                    { type: 'MAT', weight: 2 },
                    { type: 'ORE', weight: 1 },
                    { type: 'HERB', weight: 1 }
                ];
                let totalWeight = deathDrops.reduce((sum, drop) => sum + drop.weight, 0);
                let pick = Math.random() * totalWeight;
                let chosen = deathDrops[0];
                for (let drop of deathDrops) {
                    if (pick < drop.weight) {
                        chosen = drop;
                        break;
                    }
                    pick -= drop.weight;
                }
                let x = this.pos.x + (Math.random() * 12 - 6);
                let y = this.pos.y + (Math.random() * 12 - 6);
                sim.spawnResource(null, x, y, chosen.type, false, this.tribeId);
            }
            spawnDeathFoodBurst() {
                if (typeof sim === 'undefined') return;
                for (let i = 0; i < 4; i++) {
                    let x = this.pos.x + (Math.random() * 24 - 12);
                    let y = this.pos.y + (Math.random() * 24 - 12);
                    sim.spawnResource(null, x, y, 'FOOD', false, this.tribeId);
                }
            }

            spawnGroupAgentBabies(sim) {
                if (!this.isGroupEntity || typeof sim === 'undefined') return;
                let count = 1 + Math.floor(Math.random() * 3);
                for (let i = 0; i < count; i++) {
                    let dx = (Math.random() * 20 - 10);
                    let dy = (Math.random() * 20 - 10);
                    let dna = { ...this.dna };
                    for (let gene in dna) {
                        if (typeof dna[gene] === 'number') {
                            dna[gene] += (Math.random() * 0.2 - 0.1) * 0.3;
                            dna[gene] = Math.max(0, Math.min(1, dna[gene]));
                        }
                    }
                    let baby = new Agent(this.pos.x + dx, this.pos.y + dy, dna, null, this.tribeId);
                    baby.age = Math.random() * (CONFIG.adultAge * 0.5);
                    baby.health *= 0.5;
                    baby.maxHealth *= 0.7;
                    baby.energy = Math.min(baby.maxEnergy, baby.maxEnergy * 0.6);
                    baby.isGroupEntity = false;
                    baby.color = sim.tribes && sim.tribes.tribes[this.tribeId] ? sim.tribes.tribes[this.tribeId].color : baby.color;
                    sim.agents.push(baby);
                }
            }

            getGroupShapeSides() {
                // PERFORMANCE OPTIMIZATION: Cache sides calculation (only changes when groupEntityLevel changes)
                if (this._cachedSides !== undefined && this._cachedSidesLevel === this.groupEntityLevel) {
                    return this._cachedSides;
                }
                this._cachedSides = 6 + Math.min(4, Math.floor((this.groupEntityLevel || 1) / 2));
                this._cachedSidesLevel = this.groupEntityLevel;
                return this._cachedSides;
            }
            
            checkMating(allAgents) {
                if (this.dead || !this.isAdult()) return;
                if (typeof sim === 'undefined') return;
                
                // PERFORMANCE OPTIMIZATION: Use spatial grid to only check nearby agents
                let nearbyAgents = [];
                let matingRange = 120; // Max distance for mating
                if (typeof sim !== 'undefined' && sim.spatialGrid && sim.gridCols > 0) {
                    let nearby = sim.getNearbyEntities(this.pos.x, this.pos.y, matingRange);
                    nearbyAgents = nearby.agents;
                } else {
                    // Fallback to brute force if spatial grid not available
                    nearbyAgents = allAgents.filter(a => 
                        a !== this && !a.dead && Vector.dist(this.pos, a.pos) < matingRange
                    );
                }
                
                // PREY REPRODUCTION - Linked to food consumption!
                if (this.isPrey) {
                    // Initialize mate cooldown
                    if (!this.mateCooldown) this.mateCooldown = 0;
                    if (this.mateCooldown > 0) {
                        this.mateCooldown--;
                        return;
                    }
                    
                    // Reproduction rate INCREASES with food eaten
                    let foodEaten = this.foodEaten || 0;
                    let baseReproRate = 0.001; // Base 0.1% per frame
                    let foodBonus = Math.min(2.0, foodEaten / 10); // Up to 2x bonus if eaten 10+ food
                    let reproRate = baseReproRate * (1 + foodBonus) * (sim.dynamicBirthRateMult || 1.0);
                    
                    if (Math.random() < reproRate) {
                        // Find nearby prey to mate with (already filtered by spatial grid)
                        let nearbyPrey = nearbyAgents.filter(a => 
                            a.isPrey && a.isAdult() &&
                            Vector.dist(this.pos, a.pos) < 100 &&
                            (!a.mateCooldown || a.mateCooldown <= 0)
                        );
                        
                        if (nearbyPrey.length > 0) {
                            let mate = nearbyPrey[Math.floor(Math.random() * nearbyPrey.length)];
                            
                            // Spawn offspring
                            let childX = (this.pos.x + mate.pos.x) / 2 + (Math.random() * 40 - 20);
                            let childY = (this.pos.y + mate.pos.y) / 2 + (Math.random() * 40 - 20);
                            
                            let childDna = this.mixDNA(this.dna, mate.dna);
                            // Calculate parent generation safely
                            let p1Gen = (typeof this.generation === 'number' && !isNaN(this.generation)) ? this.generation : 1;
                            let p2Gen = (typeof mate.generation === 'number' && !isNaN(mate.generation)) ? mate.generation : 1;
                            let child = new Agent(childX, childY, childDna, { gen: Math.max(p1Gen, p2Gen), p1: this, p2: mate }, -1);
                            child.isPrey = true;
                            child.role = 'Prey';
                            child.color = '#fde047';
                            
                            sim.agents.push(child);
                            
                            // Set cooldowns
                            this.mateCooldown = 200; // 200 frames cooldown
                            mate.mateCooldown = 200;
                            
                            // Reset food eaten counter
                            this.foodEaten = 0;
                            
                            // VFX & SFX
                            sim.particles.push(new Particle(childX, childY, '#fde047', 'star'));
                            sfx.play('birth', 480, 0.08); // Softer birth tone
                        }
                    }
                    return;
                }
                
                // PREDATOR REPRODUCTION
                if (this.isPredator) {
                    if (!this.mateCooldown) this.mateCooldown = 0;
                    if (this.mateCooldown > 0) {
                        this.mateCooldown--;
                        return;
                    }
                    
                    // Predators need high energy to reproduce
                    if (this.energy < 80) return;
                    
                    let reproRate = 0.002 * (sim.dynamicBirthRateMult || 1.0); // 0.2% per frame (4√ó increase!)
                    
                    if (Math.random() < reproRate) {
                        // Find nearby predators (already filtered by spatial grid)
                        let nearbyPredators = nearbyAgents.filter(a => 
                            a.isPredator && a.isAdult() &&
                            Vector.dist(this.pos, a.pos) < 120 &&
                            a.energy > 80 &&
                            (!a.mateCooldown || a.mateCooldown <= 0)
                        );
                        
                        if (nearbyPredators.length > 0) {
                            let mate = nearbyPredators[Math.floor(Math.random() * nearbyPredators.length)];
                            
                            let childX = (this.pos.x + mate.pos.x) / 2 + (Math.random() * 40 - 20);
                            let childY = (this.pos.y + mate.pos.y) / 2 + (Math.random() * 40 - 20);
                            
                            let childDna = this.mixDNA(this.dna, mate.dna);
                            // Calculate parent generation safely
                            let p1Gen = (typeof this.generation === 'number' && !isNaN(this.generation)) ? this.generation : 1;
                            let p2Gen = (typeof mate.generation === 'number' && !isNaN(mate.generation)) ? mate.generation : 1;
                            let child = new Agent(childX, childY, childDna, { gen: Math.max(p1Gen, p2Gen), p1: this, p2: mate }, -1);
                            child.isPredator = true;
                            child.role = 'Predator';
                            child.color = '#dc2626';
                            
                            sim.agents.push(child);
                            
                            this.mateCooldown = 300;
                            mate.mateCooldown = 300;
                            this.energy -= 30;
                            mate.energy -= 30;
                            
                            sim.particles.push(new Particle(childX, childY, '#dc2626', 'star'));
                            sfx.play('birth', HARMONICS.G5, 0.08); // Harmonic birth tone
                        }
                    }
                    return;
                }
                
                // TRIBAL AGENT REPRODUCTION
                if (this.tribeId === -1) return; // Only tribal agents reproduce
                if (this.energy < 60 || this.health < 50) return; // Need health/energy
                
                // Base reproduction rate (INCREASED 5√ó for stronger tribes!)
                let baseReproRate = 0.0015 * (sim.dynamicBirthRateMult || 1.0);
                let reproductionBoost = (this.isGroupEntity) ? 1.6 : 1.0;
                let reproRate = baseReproRate * reproductionBoost;
                
                // LINKED TRIBE MATING PREFERENCE
                let linkedTribeMateBonus = 1.0;
                if (typeof sim !== 'undefined' && sim.tribes && sim.tribes.tribes[this.tribeId]) {
                    let myTribe = sim.tribes.tribes[this.tribeId];
                    // Check if any linked tribes exist
                    for (let otherId in myTribe.diplomaticBonds) {
                        if (myTribe.diplomaticBonds[otherId] > 40 || myTribe.commercialBonds[otherId] > 40) {
                            linkedTribeMateBonus = 1.5; // 50% bonus if linked tribes exist
                            break;
                        }
                    }
                }
                
                reproRate *= linkedTribeMateBonus;
                
                if (Math.random() < reproRate) {
                    // Find nearby mates (already filtered by spatial grid)
                    let potentialMates = nearbyAgents.filter(a => 
                        a.isAdult() &&
                        a.tribeId !== -1 && // Must be tribal
                        !a.isPrey && !a.isPredator && // Not food chain
                        Vector.dist(this.pos, a.pos) < 100 &&
                        a.energy > 60 && a.health > 50
                    );
                    
                    // PREFER LINKED TRIBE MATES
                    if (linkedTribeMateBonus > 1.0 && potentialMates.length > 0) {
                        let linkedMates = potentialMates.filter(a => {
                            if (a.tribeId === this.tribeId) return true; // Same tribe always OK
                            
                            let myTribe = sim.tribes.tribes[this.tribeId];
                            let dipBond = myTribe.diplomaticBonds[a.tribeId] || 0;
                            let comBond = myTribe.commercialBonds[a.tribeId] || 0;
                            
                            return dipBond > 40 || comBond > 40; // Linked tribes
                        });
                        
                        if (linkedMates.length > 0) {
                            potentialMates = linkedMates; // Prefer linked mates
                        }
                    }
                    
                    if (potentialMates.length > 0) {
                        let mate = potentialMates[Math.floor(Math.random() * potentialMates.length)];
                        
                        let childX = (this.pos.x + mate.pos.x) / 2 + (Math.random() * 40 - 20);
                        let childY = (this.pos.y + mate.pos.y) / 2 + (Math.random() * 40 - 20);
                        
                        let childDna = this.mixDNA(this.dna, mate.dna);
                        // Calculate parent generation safely
                        let p1Gen = (typeof this.generation === 'number' && !isNaN(this.generation)) ? this.generation : 1;
                        let p2Gen = (typeof mate.generation === 'number' && !isNaN(mate.generation)) ? mate.generation : 1;
                        let child = new Agent(childX, childY, childDna, { gen: Math.max(p1Gen, p2Gen), p1: this, p2: mate }, this.tribeId);
                        
                        sim.agents.push(child);
                        
                        this.energy -= 20;
                        mate.energy -= 20;
                        
                        sim.particles.push(new Particle(childX, childY, child.color, 'star'));
                        sfx.play('birth', getHarmonicFreq([HARMONICS.C5, HARMONICS.E5, HARMONICS.G5], 5), 0.08); // Harmonic birth tone

                    if (this.isGroupEntity || mate.isGroupEntity) {
                        let owner = this.isGroupEntity ? this : mate;
                        sim.spawnConverterAgent(owner);
                        owner.mateCooldown = Math.max(80, owner.mateCooldown * 0.4);
                        mate.mateCooldown = Math.max(80, mate.mateCooldown * 0.4);
                        owner.energy = Math.min(owner.maxEnergy, owner.energy + 20);
                    }
                    }
                }
            }
            
            mixDNA(dna1, dna2) {
                // Mix two DNA profiles with mutations
                let mixed = {};
                for (let gene in dna1) {
                    if (typeof dna1[gene] === 'number') {
                        // Average with small mutation
                        mixed[gene] = (dna1[gene] + dna2[gene]) / 2 + (Math.random() * 0.1 - 0.05);
                        mixed[gene] = Math.max(0, Math.min(1, mixed[gene])); // Clamp 0-1
                    } else if (Array.isArray(dna1[gene])) {
                        // Mix arrays (oscillation patterns)
                        mixed[gene] = dna1[gene].map((val, i) => {
                            let avg = (val + dna2[gene][i]) / 2;
                            // Mutation chance
                            if (Math.random() < 0.1) {
                                avg = Math.floor(Math.random() * 8); // Random new direction
                            }
                            return avg;
                        });
                    } else {
                        mixed[gene] = Math.random() < 0.5 ? dna1[gene] : dna2[gene];
                    }
                }
                return mixed;
            }

            applyForce(f) { this.acc.add(f); }
            seek(target) {
                let desired = Vector.sub(target, this.pos).normalize().mult(this.maxSpeed);
                return Vector.sub(desired, this.vel).limit(this.maxForce);
            }
            flee(target) {
                let desired = Vector.sub(target, this.pos).normalize().mult(this.maxSpeed * -1);
                return Vector.sub(desired, this.vel).limit(this.maxForce);
            }
            
            getMovementPatternBias(steer) {
                if (!steer || steer.mag() < 0.1 || typeof sim === 'undefined') return new Vector(0,0);
                let pattern = Math.floor(this.dna.movement_pattern || 0) % 6;
                let dir = steer.copy().normalize();
                let perp = new Vector(-dir.y, dir.x);
                let frame = sim.frame || 0;

                switch(pattern) {
                    case 0: // Wiggly favors quick perpendicular jucture
                        return perp.copy().mult(Math.sin(frame * 0.3) * 0.4);
                    case 1: // Straight
                        return new Vector(0,0);
                    case 2: // Spiral right
                        return dir.copy().rotate(0.25).sub(dir).mult(0.6);
                    case 3: // Spiral left
                        return dir.copy().rotate(-0.25).sub(dir).mult(0.6);
                    case 4: // Jagged - random direction per frame
                        return Vector.random2D().mult(0.45);
                    case 5: // Wavy - gentle curve
                        return perp.copy().mult(Math.sin(frame * 0.15) * 0.3);
                    default:
                        return new Vector(0,0);
                }
            }

            getPartnerHash() {
                let ids = this.partners
                    .filter(p => p && !p.dead)
                    .map(p => p.id);
                ids.push(this.id);
                ids.sort((a, b) => a - b);
                return ids.join(',');
            }

            updateStructureStability() {
                let hash = this.getPartnerHash();
                let group = this.getBondedGroup();
                let groupSize = group.length;
                let withinPreferredBand = groupSize >= CONFIG.stableGroupMinMembers && groupSize <= CONFIG.stableGroupMaxMembers;
                let sameHash = hash && hash === this.lastPartnerHash;
                if (sameHash) {
                    let gain = withinPreferredBand ? CONFIG.structureStabilityInsideGain : CONFIG.structureStabilityOutsideGain;
                    this.structureStability = Math.min(CONFIG.structureStabilityCap, this.structureStability + gain);
                } else {
                    let decay = withinPreferredBand ? CONFIG.structureStabilityInsideDecay : CONFIG.structureStabilityOutsideDecay;
                    this.structureStability = Math.max(0, this.structureStability - decay);
                }
                this.structureBandActive = withinPreferredBand && groupSize > 1;
                this.structureStabilityGroupSize = groupSize;
                this.lastPartnerHash = hash;
            }
            
            boundaries() {
                // TORUS MODE: No bouncing - wrapping handles boundaries
                // Position wrapping is handled in update() method before this is called
                // So we don't need to apply bounce forces here
                return;
            }

            draw(ctx, isSelected) {
                ctx.save();
                ctx.translate(this.pos.x, this.pos.y);

                // Draw Bond Line - different styles for rigid vs elastic bonds
                // Handle torus wrapping for bonds that cross screen edges
                this.partners.forEach(p => {
                    ctx.save();
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    
                    // Use toroidal shortest path for bond drawing (handles wrapping)
                    // subTorus(v1, v2) returns direction FROM v1 TO v2, which is what we need
                    let torusDir = Vector.subTorus(this.pos, p.pos, sim.width, sim.height);
                    ctx.lineTo(torusDir.x, torusDir.y);
                    
                    // Visual distinction: rigid bonds are red/orange and thicker
                    let isRigid = this.rigidBonds[p.id];
                    if (isRigid) {
                        ctx.strokeStyle = 'rgba(255, 107, 107, 0.8)'; // Red-orange for rigid
                        ctx.lineWidth = 3;
                    } else {
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)'; // White for elastic
                    ctx.lineWidth = 2;
                    }
                    ctx.stroke();
                    ctx.restore();
                });

                // Leader Crown
                if (this.tribeId !== -1 && sim.tribes.tribes[this.tribeId].leaderId === this.id) {
                    ctx.fillStyle = '#facc15'; 
                    ctx.beginPath();
                    ctx.moveTo(-5, -this.radius - 2);
                    ctx.lineTo(0, -this.radius - 10);
                    ctx.lineTo(5, -this.radius - 2);
                    ctx.fill();
                }

                // Draw Tribe Halo
                if (this.tribeId !== -1 && sim.tribes.tribes[this.tribeId]) {
                    ctx.strokeStyle = sim.tribes.tribes[this.tribeId].color;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(0, 0, this.radius + 3, 0, Math.PI*2);
                    ctx.stroke();
                }

                // Draw Tether (if Leader/Guardian) - SPRING LINE
                // Handle torus wrapping for tether lines that cross screen edges
                if (this.role === 'Guardian' || (this.tribeId !== -1 && sim.tribes.tribes[this.tribeId].leaderId === this.id)) {
                    let myNest = sim.tribes.nests.find(n => n.tribeId === this.tribeId);
                    if (myNest && Vector.distTorus(this.pos, myNest.pos, sim.width, sim.height) > 50) {
                        ctx.save();
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        // Use toroidal shortest path for tether drawing (handles wrapping)
                        // subTorus(v1, v2) returns direction FROM v1 TO v2, which is what we need
                        let torusDir = Vector.subTorus(this.pos, myNest.pos, sim.width, sim.height);
                        ctx.lineTo(torusDir.x, torusDir.y);
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
                        ctx.setLineDash([3, 3]); // Dashed spring line
                        ctx.lineWidth = 1;
                        ctx.stroke();
                        ctx.restore();
                    }
                }

                // Draw Selection Halo
                if (isSelected) {
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(0, 0, this.radius + 6, 0, Math.PI*2);
                    ctx.stroke();
                }

                if (this.isGroupEntity) {
                    // PERFORMANCE OPTIMIZATION: Always draw polygon groups, but use simplified version when population is high
                    // This prevents visual jitter from skipping frames while maintaining performance
                    let totalAgents = (typeof sim !== 'undefined' && sim.agents) ? sim.agents.length : 0;
                    let groupEntityCount = (typeof sim !== 'undefined' && sim.agents) ? 
                        sim.agents.filter(a => a.isGroupEntity).length : 0;
                    
                    // Use simplified circles when population is high OR when there are many group entities
                    // This prevents jitter by always drawing but using faster rendering
                    if (totalAgents > 100 || groupEntityCount > 10) {
                        // Draw simplified version (just circles) - much faster, no jitter
                        ctx.strokeStyle = `rgba(255,255,255,0.6)`;
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
                        ctx.stroke();
                        // Inner circle for visual distinction
                        ctx.strokeStyle = `rgba(255,255,255,0.3)`;
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.arc(0, 0, this.radius * 0.6, 0, Math.PI * 2);
                        ctx.stroke();
                    } else {
                        // Draw full polygon when population is low
                        this.drawGroupPolygon(ctx);
                    }
                } else if (this.isConverterUnit) {
                    this.drawConverterShape(ctx);
                } else if (this.isConverterBonder) {
                    this.drawConverterBonderShape(ctx);
                } else {
                // Draw Body
                ctx.fillStyle = this.color;
                ctx.beginPath();
                if (this.role === 'Monster') {
                     ctx.rect(-this.radius, -this.radius, this.radius*2, this.radius*2);
                } else {
                     ctx.arc(0, 0, this.radius, 0, Math.PI*2);
                }
                ctx.fill();
                }
                
                // Disease Indicator
                if (this.disease > 0) {
                    ctx.fillStyle = '#22c55e';
                    ctx.beginPath();
                    ctx.arc(0, 0, 3, 0, Math.PI*2);
                    ctx.fill();
                }

                // Draw Carrying Item
                if (this.carrying) {
                     ctx.fillStyle = this.carrying.config.color;
                     ctx.beginPath();
                     ctx.arc(0, -this.radius, 3, 0, Math.PI*2);
                     ctx.fill();
                }

                ctx.restore();
            }

            drawGroupPolygon(ctx) {
                // PERFORMANCE OPTIMIZATION: Cache polygon vertices to avoid recalculating every frame
                let sides = this.getGroupShapeSides();
                let radius = this.radius;
                let innerRadius = Math.max(radius * 0.6, radius - 6);
                
                // Cache vertices if radius or sides changed
                if (!this._cachedPolygonVertices || 
                    this._cachedPolygonRadius !== radius || 
                    this._cachedPolygonSides !== sides) {
                    // Calculate and cache outer polygon vertices
                    this._cachedPolygonVertices = [];
                    for (let i = 0; i < sides; i++) {
                        let theta = (i / sides) * Math.PI * 2;
                        this._cachedPolygonVertices.push({
                            x: Math.cos(theta) * radius,
                            y: Math.sin(theta) * radius
                        });
                    }
                    
                    // Calculate and cache inner polygon vertices
                    this._cachedInnerVertices = [];
                    for (let i = 0; i < sides; i++) {
                        let theta = ((i + 0.5) / sides) * Math.PI * 2;
                        this._cachedInnerVertices.push({
                            x: Math.cos(theta) * innerRadius,
                            y: Math.sin(theta) * innerRadius
                        });
                    }
                    
                    this._cachedPolygonRadius = radius;
                    this._cachedPolygonSides = sides;
                }
                
                // Draw outer polygon using cached vertices
                ctx.strokeStyle = `rgba(255,255,255,0.8)`;
                ctx.lineWidth = 3;
                ctx.beginPath();
                for (let i = 0; i < this._cachedPolygonVertices.length; i++) {
                    let v = this._cachedPolygonVertices[i];
                    if (i === 0) ctx.moveTo(v.x, v.y);
                    else ctx.lineTo(v.x, v.y);
                }
                ctx.closePath();
                ctx.stroke();

                // Draw inner polygon using cached vertices
                ctx.lineWidth = 2;
                ctx.beginPath();
                for (let i = 0; i < this._cachedInnerVertices.length; i++) {
                    let v = this._cachedInnerVertices[i];
                    if (i === 0) ctx.moveTo(v.x, v.y);
                    else ctx.lineTo(v.x, v.y);
                }
                ctx.closePath();
                ctx.stroke();
            }

            drawConverterShape(ctx) {
                ctx.strokeStyle = '#f97316';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(0, -this.radius);
                ctx.lineTo(this.radius * 0.8, 0);
                ctx.lineTo(0, this.radius);
                ctx.lineTo(-this.radius * 0.8, 0);
                ctx.closePath();
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(-this.radius * 0.5, 0);
                ctx.lineTo(this.radius * 0.5, 0);
                ctx.stroke();
            }

            drawConverterBonderShape(ctx) {
                ctx.strokeStyle = '#22d3ee';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(0, 0, this.radius * 0.9, 0, Math.PI * 2);
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(0, 0, this.radius * 0.5, 0, Math.PI * 2);
                ctx.stroke();
            }
        }

        /* --- SIMULATION ENGINE --- */
        class Simulation {
            constructor() {
                this.canvas = document.getElementById('simCanvas');
                this.ctx = this.canvas.getContext('2d');
                
                // PERFORMANCE OPTIMIZATION: Spatial grid for O(n) distance checks
                this.spatialGrid = null;
                this.gridCellSize = 150; // Size of each grid cell (adjust based on typical sensing range)
                this.gridCols = 0;
                this.gridRows = 0;
                
                // PERFORMANCE OPTIMIZATION: Frame time tracking for adaptive quality
                this.lastFrameTime = performance.now();
                this.frameTimeHistory = [];
                this.lastAgentCount = 0; // Track agent count for adaptive quality
                
                // Status message system for HUD updates
                this.statusMessage = null;
                this.statusMessageExpiry = 0; // Frame when status message expires
                this.avgFrameTime = 16.67; // Target: 60fps = 16.67ms
                
                // PERFORMANCE OPTIMIZATION: Staggered update configuration
                this.updateStaggerSize = 4; // Update 1/4 of agents per frame (4-frame cycle)
                this.tribes = new TribeManager(); 
                this.agents = [];
                this.resources = [];
                this.walls = [];
                this.particles = [];
                this.projectiles = [];
                this.plagues = []; // Plagues
                this.frame = 0;
                this.running = true;
                this.selected = null;
                this.dynamicBirthRateMult = 1.0; // Crisis Multiplier
                this.actionMode = null; // 'infect', etc.
                
                // PERFORMANCE: Track recent births by location to prevent mating explosions
                this.recentBirths = []; // Array of {x, y, frame} for births in last 180 frames (3 seconds)
                this.matingExplosionCooldown = {}; // Map of grid cell indices to cooldown frames

                // Initialize settings sliders with current config
                this.initSettings();

                this.resize();
                window.addEventListener('resize', () => this.resize());
                this.canvas.addEventListener('mousedown', (e) => this.input(e));
                
                this.init();
            }

            initSettings() {
                for(let key in CONFIG) {
                    let el = document.getElementById(`in-${key}`);
                    if (el) el.value = CONFIG[key];
                    let valEl = document.getElementById(`val-${key}`);
                    if (valEl) valEl.textContent = CONFIG[key];
                }
            }

            updateConfig(key, value) {
                CONFIG[key] = parseFloat(value);
                let valEl = document.getElementById(`val-${key}`);
                if (valEl) valEl.textContent = CONFIG[key];
            }

            restoreDefaults() {
                CONFIG = { ...DEFAULT_CONFIG };
                this.initSettings();
            }

            copySettingsToClipboard() {
                const settingsText = Object.entries(CONFIG).map(([key, value]) => `${key}: ${value}`).join('\n');
                navigator.clipboard.writeText(settingsText).then(() => {
                    alert('Settings copied to clipboard!');
                }).catch(err => {
                    console.error('Failed to copy settings:', err);
                    // Fallback: create a temporary textarea
                    const textarea = document.createElement('textarea');
                    textarea.value = settingsText;
                    document.body.appendChild(textarea);
                    textarea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textarea);
                    alert('Settings copied to clipboard!');
                });
            }

            toggleSettings() {
                let modal = document.getElementById('settings-modal');
                if (modal.classList.contains('hidden')) modal.classList.remove('hidden');
                else modal.classList.add('hidden');
            }

            toggleAbout() {
                let modal = document.getElementById('about-modal');
                if (modal.classList.contains('hidden')) modal.classList.remove('hidden');
                else modal.classList.add('hidden');
            }

            resize() {
                this.width = window.innerWidth;
                this.height = window.innerHeight;
                this.canvas.width = this.width;
                this.canvas.height = this.height;
                
                // Rebuild spatial grid when canvas resizes
                this._rebuildSpatialGrid();
            }
            
            // PERFORMANCE OPTIMIZATION: Build spatial grid for efficient distance checks
            _rebuildSpatialGrid() {
                this.gridCols = Math.ceil(this.width / this.gridCellSize);
                this.gridRows = Math.ceil(this.height / this.gridCellSize);
                this.spatialGrid = {
                    agents: Array(this.gridCols * this.gridRows).fill(null).map(() => []),
                    resources: Array(this.gridCols * this.gridRows).fill(null).map(() => [])
                };
            }
            
            // PERFORMANCE OPTIMIZATION: Get grid cell index from position
            _getGridIndex(x, y) {
                let col = Math.floor(x / this.gridCellSize);
                let row = Math.floor(y / this.gridCellSize);
                col = Math.max(0, Math.min(col, this.gridCols - 1));
                row = Math.max(0, Math.min(row, this.gridRows - 1));
                return row * this.gridCols + col;
            }
            
            // PERFORMANCE OPTIMIZATION: Get nearby cells (including adjacent cells for edge cases)
            _getNearbyCellIndices(x, y, radius) {
                let indices = new Set();
                let centerCol = Math.floor(x / this.gridCellSize);
                let centerRow = Math.floor(y / this.gridCellSize);
                let cellRadius = Math.ceil(radius / this.gridCellSize) + 1; // +1 for safety
                
                for (let dr = -cellRadius; dr <= cellRadius; dr++) {
                    for (let dc = -cellRadius; dc <= cellRadius; dc++) {
                        let col = centerCol + dc;
                        let row = centerRow + dr;
                        if (col >= 0 && col < this.gridCols && row >= 0 && row < this.gridRows) {
                            indices.add(row * this.gridCols + col);
                        }
                    }
                }
                return Array.from(indices);
            }
            
            // PERFORMANCE OPTIMIZATION: Build spatial grid from current agents/resources
            // PERFORMANCE: Cleanup after war ends to recover performance
            _cleanupAfterWar() {
                // Reset frame history to allow performance recovery
                if (this.frameTimeHistory.length > 5) {
                    this.frameTimeHistory = this.frameTimeHistory.slice(-3); // Keep only last 3 frames
                }
                // Reset stagger size if it got too high during war
                if (this.updateStaggerSize > 8) {
                    this.updateStaggerSize = Math.max(4, this.updateStaggerSize - 2);
                }
            }
            
            _cleanupAfterLargeDieOff() {
                // Aggressive cleanup after large die-offs (similar to war cleanup)
                // Reset frame history to allow performance recovery
                if (this.frameTimeHistory.length > 5) {
                    this.frameTimeHistory = this.frameTimeHistory.slice(-3); // Keep only last 3 frames
                }
                // Reset stagger size if it got too high
                if (this.updateStaggerSize > 8) {
                    this.updateStaggerSize = Math.max(4, this.updateStaggerSize - 2);
                }
                // Force aggressive cleanup of dead agents and other entities
                this.agents = this.agents.filter(a => !a.dead);
                this.resources = this.resources.filter(r => r.active);
                this.particles = this.particles.filter(p => p.life > 0);
                this.projectiles = this.projectiles.filter(p => p.active && p.life > 0);
                this.plagues = this.plagues.filter(p => p.life > 0);
                
                // Cap arrays if they're still too large
                if (this.particles.length > 300) this.particles = this.particles.slice(-300);
                if (this.projectiles.length > 100) this.projectiles = this.projectiles.slice(-100);
                if (this.plagues.length > 20) this.plagues = this.plagues.slice(-20);
                if (this.resources.length > CONFIG.maxRes * 1.5) {
                    this.resources = this.resources.slice(-CONFIG.maxRes);
                }
            }
            
            _updateSpatialGrid() {
                if (!this.spatialGrid || this.gridCols === 0 || this.gridRows === 0) {
                    this._rebuildSpatialGrid();
                }
                
                // Clear grid
                this.spatialGrid.agents.forEach(cell => cell.length = 0);
                this.spatialGrid.resources.forEach(cell => cell.length = 0);
                
                // Populate grid with agents
                for (let agent of this.agents) {
                    if (agent.dead) continue;
                    let idx = this._getGridIndex(agent.pos.x, agent.pos.y);
                    this.spatialGrid.agents[idx].push(agent);
                }
                
                // Populate grid with resources
                for (let resource of this.resources) {
                    if (!resource.active) continue;
                    let idx = this._getGridIndex(resource.pos.x, resource.pos.y);
                    this.spatialGrid.resources[idx].push(resource);
                }
            }
            
            // PERFORMANCE OPTIMIZATION: Get nearby agents/resources using spatial grid
            getNearbyEntities(x, y, radius) {
                if (!this.spatialGrid || this.gridCols === 0) {
                    // Fallback to brute force if grid not initialized
                    return {
                        agents: this.agents.filter(a => !a.dead && Vector.dist({x, y}, a.pos) < radius),
                        resources: this.resources.filter(r => r.active && Vector.dist({x, y}, r.pos) < radius)
                    };
                }
                
                let nearbyAgents = [];
                let nearbyResources = [];
                let cellIndices = this._getNearbyCellIndices(x, y, radius);
                
                for (let idx of cellIndices) {
                    // Check agents in this cell
                    for (let agent of this.spatialGrid.agents[idx]) {
                        if (agent.dead) continue;
                        let dist = Vector.dist({x, y}, agent.pos);
                        if (dist < radius) {
                            nearbyAgents.push(agent);
                        }
                    }
                    
                    // Check resources in this cell
                    for (let resource of this.spatialGrid.resources[idx]) {
                        if (!resource.active) continue;
                        let dist = Vector.dist({x, y}, resource.pos);
                        if (dist < radius) {
                            nearbyResources.push(resource);
                        }
                    }
                }
                
                return { agents: nearbyAgents, resources: nearbyResources };
            }

            init() {
                this.agents = [];
                this.resources = [];
                this.walls = [];
                this.particles = [];
                this.projectiles = [];
                this.plagues = [];
                this.frame = 0;
                this.tribes = new TribeManager(); 
                
                // Initialize spatial grid
                this._rebuildSpatialGrid(); 
                
                // Initialize Nests with starting crews (MORE DIVERSE!)
                this.tribes.nests.forEach(n => {
                    // Builders (essential)
                    for(let i=0; i<3; i++) {
                        let a = new Agent(n.pos.x + (Math.random()*20-10), n.pos.y + (Math.random()*20-10), null, null, n.tribeId);
                        a.role = 'Builder'; a.assignColor(); a.age = 200;
                        this.agents.push(a);
                    }
                    // Guardians (essential)
                    for(let i=0; i<3; i++) {
                        let a = new Agent(n.pos.x + (Math.random()*20-10), n.pos.y + (Math.random()*20-10), null, null, n.tribeId);
                        a.role = 'Guardian'; a.assignColor(); a.age = 200;
                        this.agents.push(a);
                    }
                    // Miners (resource gatherers)
                    for(let i=0; i<2; i++) {
                        let a = new Agent(n.pos.x + (Math.random()*30-15), n.pos.y + (Math.random()*30-15), null, null, n.tribeId);
                        a.role = 'Miner'; a.assignColor(); a.age = 200;
                        this.agents.push(a);
                    }
                    // Botanists (food production)
                    for(let i=0; i<2; i++) {
                        let a = new Agent(n.pos.x + (Math.random()*30-15), n.pos.y + (Math.random()*30-15), null, null, n.tribeId);
                        a.role = 'Botanist'; a.assignColor(); a.age = 200;
                        this.agents.push(a);
                    }
                    // Garbage Collectors (recycling)
                    for(let i=0; i<1; i++) {
                        let a = new Agent(n.pos.x + (Math.random()*30-15), n.pos.y + (Math.random()*30-15), null, null, n.tribeId);
                        a.role = 'Garbage Collector'; a.assignColor(); a.age = 200;
                        this.agents.push(a);
                    }
                    // Scouts (exploration)
                    for(let i=0; i<1; i++) {
                        let a = new Agent(n.pos.x + (Math.random()*30-15), n.pos.y + (Math.random()*30-15), null, null, n.tribeId);
                        a.role = 'Scout'; a.assignColor(); a.age = 200;
                        this.agents.push(a);
                    }
                    // Random others to fill pop (will naturally diversify)
                    for(let i=0; i<6; i++) {
                        let a = new Agent(n.pos.x + (Math.random()*100-50), n.pos.y + (Math.random()*100-50), null, null, n.tribeId);
                        a.age = 200; 
                        this.agents.push(a);
                    }
                });

                for(let i=0; i<50; i++) this.spawnResource(null, null, null, 'FOOD');
                for(let i=0; i<30; i++) this.spawnResource(null, null, null, 'MAT');
                for(let i=0; i<5; i++) this.spawnResource(null, null, null, 'STIM');
                for(let i=0; i<10; i++) this.spawnResource(null, null, null, 'HERB');
                for(let i=0; i<10; i++) this.spawnResource(null, null, null, 'ORE');
                for(let i=0; i<3; i++) this.spawnResource(null, null, null, 'RELIC');
            }

            spawnResource(event, x, y, specificType, isNestSpawned = false, creatorTribeId = -1) {
                let type = 'FOOD';
                if (specificType) type = specificType;
                else {
                    let r = Math.random();
                    if (r < 0.5) type = 'FOOD';
                    else if (r < 0.7) type = 'MAT';
                    else if (r < 0.75) type = 'STIM';
                    else if (r < 0.85) type = 'HERB';
                    else if (r < 0.95) type = 'ORE';
                    else type = 'RELIC';
                }
                
                if (!specificType && Math.random() < CONFIG.treasureSpawnRate) type = 'TREASURE';

                let spawnX = x !== null && x !== undefined ? x : Math.random() * this.width;
                let spawnY = y !== null && y !== undefined ? y : Math.random() * this.height;
                this.resources.push(new Resource(spawnX, spawnY, type, isNestSpawned, creatorTribeId));
            }

            spawnMonster() {
                let m = new Agent(this.width/2, this.height/2, { monster: true });
                this.agents.push(m);
                sim.particles.push(new Particle(m.pos.x, m.pos.y, '#ffffff', 'lightning'));
            }

            spawnMonsterAt(x, y) {
                let m = new Agent(x, y, { monster: true });
                this.agents.push(m);
                sim.particles.push(new Particle(x, y, '#ffffff', 'lightning'));
            }
            
            setTool(tool) {
                let btnNest = document.getElementById('btn-nest');
                let btnBoon = document.getElementById('btn-boon');
                let btnInfect = document.getElementById('btn-infect');
                let btnMonster = document.getElementById('btn-monster');
                let agentSelect = document.getElementById('agent-type-select');
                let alertBox = document.getElementById('tool-alert');
                
                // Toggle behavior: if clicking the same tool that's already active, deactivate it
                if (tool === this.actionMode) {
                    this.actionMode = null;
                    tool = null;
                    if (agentSelect) agentSelect.value = '';
                } else {
                    this.actionMode = tool;
                }
                
                // Clear classes
                if(btnNest) btnNest.classList.remove('active-tool');
                if(btnBoon) btnBoon.classList.remove('active-tool');
                btnInfect.classList.remove('active-tool');
                if(btnMonster) btnMonster.classList.remove('active-tool-monster');
                alertBox.classList.add('hidden');

                if (this.actionMode === 'nest') {
                    if(btnNest) btnNest.classList.add('active-tool');
                    if (agentSelect) agentSelect.value = '';
                    alertBox.textContent = "‚ö†Ô∏è PLACE NEST MODE - CLICK ON CANVAS TO PLACE ‚ö†Ô∏è";
                    alertBox.classList.remove('hidden');
                } else if (this.actionMode === 'boon') {
                    if(btnBoon) btnBoon.classList.add('active-tool');
                    if (agentSelect) agentSelect.value = '';
                    alertBox.textContent = "‚ö†Ô∏è PLACE BOON MODE - CLICK ON CANVAS TO PLACE 50 RESOURCES ‚ö†Ô∏è";
                    alertBox.classList.remove('hidden');
                } else if (this.actionMode === 'infect') {
                    btnInfect.classList.add('active-tool');
                    if (agentSelect) agentSelect.value = '';
                    alertBox.textContent = "‚ö†Ô∏è PLACE GERMS MODE - CLICK ON CANVAS TO PLACE ‚ö†Ô∏è";
                    alertBox.classList.remove('hidden');
                } else if (this.actionMode === 'monster') {
                    if(btnMonster) btnMonster.classList.add('active-tool-monster');
                    if (agentSelect) agentSelect.value = '';
                    alertBox.textContent = "‚ö†Ô∏è PLACE MONSTER MODE - CLICK ON CANVAS TO PLACE ‚ö†Ô∏è";
                    alertBox.classList.remove('hidden');
                } else if (this.actionMode && this.actionMode.startsWith('agent-')) {
                    let agentType = this.actionMode.replace('agent-', '');
                    if (agentSelect) agentSelect.value = agentType;
                    alertBox.textContent = `‚ö†Ô∏è PLACE ${agentType.toUpperCase()}S MODE - CLICK ON CANVAS TO PLACE 15 AGENTS ‚ö†Ô∏è`;
                    alertBox.classList.remove('hidden');
                } else {
                    if (agentSelect) agentSelect.value = '';
                }
            }

            triggerOutbreak() {
                // Fallback for automated outbreak logic if needed, but now we use tool
                if (this.agents.length > 0) {
                    let targets = this.agents.filter(a => a.role !== 'Monster');
                    if(targets.length > 0) {
                        let patientZero = targets[Math.floor(Math.random() * targets.length)];
                        patientZero.disease = 1000;
                        sim.particles.push(new Particle(patientZero.pos.x, patientZero.pos.y, '#22c55e'));
                    }
                }
            }

            spawnChild(p1, p2) {
                let newDna = {};
                for(let k in p1.dna) {
                    // Handle array genes (oscillate_pattern, oscillate_weights)
                    if (Array.isArray(p1.dna[k])) {
                        // Inherit pattern from one parent
                        newDna[k] = (Math.random() < 0.5 ? [...p1.dna[k]] : [...p2.dna[k]]);
                        // Mutate each element in the pattern array
                        if (Math.random() < CONFIG.mutationRate) {
                            let mutIdx = Math.floor(Math.random() * newDna[k].length);
                            if (k === 'oscillate_pattern') {
                                newDna[k][mutIdx] = Math.floor(Math.random() * 8); // New random direction
                            } else if (k === 'oscillate_weights') {
                                newDna[k][mutIdx] = 0.5 + Math.random() * 0.5; // New random weight (0.5-1.0)
                            } else {
                                newDna[k][mutIdx] = Math.floor(Math.random() * 8); // Default for other arrays
                            }
                        }
                    } else {
                        // Handle scalar genes normally
                    if (Math.random() < 0.5) newDna[k] = p1.dna[k];
                    else newDna[k] = p2.dna[k];
                    if (Math.random() < CONFIG.mutationRate) {
                        newDna[k] += (Math.random() * 0.2) - 0.1;
                        newDna[k] = Math.max(0, Math.min(1, newDna[k]));
                        }
                    }
                }
                let x = (p1.pos.x + p2.pos.x) / 2;
                let y = (p1.pos.y + p2.pos.y) / 2;
                // Calculate parent generation safely (handle undefined values)
                let p1Gen = (typeof p1.generation === 'number' && !isNaN(p1.generation)) ? p1.generation : 1;
                let p2Gen = (typeof p2.generation === 'number' && !isNaN(p2.generation)) ? p2.generation : 1;
                let child = new Agent(x, y, newDna, {
                    gen: Math.max(p1Gen, p2Gen),
                    tribeId: p1.tribeId, 
                    skills: p1.skills,
                    p1: p1, // Bond to parents
                    p2: p2
                }, p1.tribeId);
                
                child.loyalty[p1.id] = 80;
                child.loyalty[p2.id] = 80;
                this.agents.push(child);
            }

            spawnConverterAgent(owner, sourceType) {
                if (!owner) return null;
                const pool = ['FOOD','MAT','ORE','HERB','STIM'];
                let source = sourceType || pool[Math.floor(Math.random() * pool.length)];
                let target = pool[(pool.indexOf(source) + 1) % pool.length];
                let x = owner.pos.x + (Math.random() * 30 - 15);
                let y = owner.pos.y + (Math.random() * 30 - 15);
                let dna = { ...owner.dna };
                let converter = new Agent(x, y, dna, null, owner.tribeId);
                converter.isConverterUnit = true;
                converter.converterSource = source;
                converter.converterTarget = target;
                converter.converterOwner = owner;
                converter.color = '#f97316';
                converter.maxHealth += 20;
                converter.health = converter.maxHealth;
                converter.maxEnergy *= 1.2;
                converter.energy = converter.maxEnergy * 0.7;
                converter.groupEntityParent = owner;
                this.agents.push(converter);
                return converter;
            }

            spawnConverterBonder(owner) {
                if (!owner) return null;
                let x = owner.pos.x + (Math.random() * 30 - 15);
                let y = owner.pos.y + (Math.random() * 30 - 15);
                let bonder = new Agent(x, y, { ...owner.dna }, null, owner.tribeId);
                bonder.isConverterBonder = true;
                bonder.ownerGroupAgent = owner;
                bonder.color = '#22d3ee';
                bonder.maxHealth *= 0.8;
                bonder.health = bonder.maxHealth;
                bonder.maxEnergy *= 0.8;
                bonder.energy = bonder.maxEnergy * 0.6;
                bonder.lastBondAttempt = -Infinity;
                bonder.groupEntityParent = owner;
                this.agents.push(bonder);
                return bonder;
            }

            spawnAgent(type, nest) {
                if (!nest) return null;
                let spawnX = nest.pos.x + (Math.random() * 40 - 20);
                let spawnY = nest.pos.y + (Math.random() * 40 - 20);
                let agent = new Agent(spawnX, spawnY, null, null, nest.tribeId);
                switch (type) {
                    case 'Soldier':
                        agent.role = 'Soldier';
                        agent.assignColor();
                        agent.health += 30;
                        agent.maxHealth += 30;
                        agent.canShootRanged = true;
                        break;
                    case 'Predator':
                        agent.role = 'Raider';
                        agent.assignColor();
                        agent.isPredator = true;
                        agent.health += 25;
                        agent.maxHealth += 25;
                        agent.color = '#dc2626';
                        break;
                    case 'Prey':
                        agent.role = 'Farmer';
                        agent.assignColor();
                        agent.isPrey = true;
                        agent.isGrazer = true;
                        agent.health += 10;
                        agent.maxHealth += 10;
                        agent.color = '#fde047';
                        break;
                    default:
                        agent.assignColor();
                        break;
                }
                this.agents.push(agent);
                return agent;
            }

            buildWall(x, y, tribeId) {
                // No longer physical wall objects, upgrade nest instead
                // handled in Agent interact
            }

            input(e) {
                // Don't trigger canvas click if clicking on UI panels or controls
                if (e.target.closest('.panel') || e.target.closest('.ui-control')) return;
                
                // Try to start audio on first user interaction (browser autoplay policy)
                if (typeof sfx !== 'undefined' && sfx.enabled) {
                    sfx.ensureAudioPlaying();
                }

                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                const m = new Vector(x, y);

                // NEST TOOL
                if (this.actionMode === 'nest') {
                    // Create a new tribe
                    const colors = ['#ef4444', '#3b82f6', '#10b981', '#eab308', '#d946ef', '#f97316', '#06b6d4', '#8b5cf6'];
                    const bases = ['Red', 'Blue', 'Green', 'Gold', 'Void', 'Orange', 'Cyan', 'Purple'];
                    const suffixes = ['Claw', 'Fin', 'Leaf', 'Spear', 'Walkers', 'Fang', 'Wing', 'Shield'];
                    const colorIndex = this.tribes.nextId % colors.length;
                    const nameIndex = this.tribes.nextId % bases.length;
                    const tribeName = bases[nameIndex] + ' ' + suffixes[this.tribes.nextId % suffixes.length];
                    const tribeId = this.tribes.createTribe(tribeName, colors[colorIndex]);
                    
                    // Create nest at click location
                    const newNest = new Nest(x, y, tribeId);
                    this.tribes.nests.push(newNest);
                    
                    // Initialize nest with starting agents (similar to init)
                    for(let i=0; i<3; i++) {
                        let a = new Agent(x + (Math.random()*20-10), y + (Math.random()*20-10), null, null, tribeId);
                        a.role = 'Builder'; a.assignColor(); a.age = 200;
                        this.agents.push(a);
                    }
                    for(let i=0; i<3; i++) {
                        let a = new Agent(x + (Math.random()*20-10), y + (Math.random()*20-10), null, null, tribeId);
                        a.role = 'Guardian'; a.assignColor(); a.age = 200;
                        this.agents.push(a);
                    }
                    for(let i=0; i<2; i++) {
                        let a = new Agent(x + (Math.random()*30-15), y + (Math.random()*30-15), null, null, tribeId);
                        a.role = 'Miner'; a.assignColor(); a.age = 200;
                        this.agents.push(a);
                    }
                    for(let i=0; i<2; i++) {
                        let a = new Agent(x + (Math.random()*30-15), y + (Math.random()*30-15), null, null, tribeId);
                        a.role = 'Botanist'; a.assignColor(); a.age = 200;
                        this.agents.push(a);
                    }
                    
                    // NEST BIRTH SOUND
                    if (typeof sfx !== 'undefined' && sfx.enabled) {
                        sfx.play('birth', getHarmonicFreq([HARMONICS.C5, HARMONICS.E5, HARMONICS.G5, HARMONICS.A5], 10), 0.1);
                    }
                    this.particles.push(new Particle(x, y, '#ffffff', 'spark'));
                    this.setStatusMessage(`üè† NEST PLACED: ${tribeName} at (${Math.floor(x)}, ${Math.floor(y)})`, 300);
                    this.setTool(null);
                    return;
                }

                // BOON TOOL - Place 50 random resources (not food)
                if (this.actionMode === 'boon') {
                    const resourceTypes = ['MAT', 'STIM', 'SEED', 'TREASURE', 'HERB', 'ORE', 'RELIC'];
                    for (let i = 0; i < 50; i++) {
                        let angle = (i / 50) * Math.PI * 2;
                        let offset = 30 + Math.random() * 40;
                        let spawnX = x + Math.cos(angle) * offset;
                        let spawnY = y + Math.sin(angle) * offset;
                        let resourceType = resourceTypes[Math.floor(Math.random() * resourceTypes.length)];
                        this.spawnResource(null, spawnX, spawnY, resourceType);
                    }
                    this.particles.push(new Particle(x, y, '#fbbf24', 'star'));
                    this.setStatusMessage(`üí∞ BOON PLACED: 50 resources scattered at (${Math.floor(x)}, ${Math.floor(y)})`, 300);
                    this.setTool(null);
                    return;
                }

                // INFECTION TOOL
                if (this.actionMode === 'infect') {
                    this.plagues.push(new Plague(x, y));
                    this.setStatusMessage(`üåã CATACLYSM: Plague unleashed at (${Math.floor(x)}, ${Math.floor(y)})`, 300); // Show for 300 frames
                    this.setTool(null); // Reset tool
                    return;
                }

                // MONSTER TOOL
                if (this.actionMode === 'monster') {
                    this.spawnMonsterAt(x, y);
                    this.setTool(null);
                    return;
                }

                // AGENT PLACEMENT TOOL
                if (this.actionMode && this.actionMode.startsWith('agent-')) {
                    let agentType = this.actionMode.replace('agent-', '');
                    
                    // Check if click is on a nest - if so, use that nest's tribe
                    let clickedNest = null;
                    for (let nest of this.tribes.nests) {
                        let dist = Vector.dist(new Vector(x, y), nest.pos);
                        if (dist < nest.radius) {
                            clickedNest = nest;
                            break;
                        }
                    }
                    
                    let targetTribeId;
                    if (clickedNest) {
                        // Use the nest's tribe
                        targetTribeId = clickedNest.tribeId;
                    } else {
                        // Randomly choose a tribe
                        let existingTribes = Object.keys(this.tribes.tribes).map(id => parseInt(id)).filter(id => id !== -1);
                        if (existingTribes.length === 0) {
                            this.setStatusMessage(`‚ö†Ô∏è No existing tribes to join!`, 300);
                            this.setTool(null);
                            return;
                        }
                        targetTribeId = existingTribes[Math.floor(Math.random() * existingTribes.length)];
                    }
                    
                    // Spawn 15 agents of the specified type
                    for (let i = 0; i < 15; i++) {
                        let angle = (i / 15) * Math.PI * 2;
                        let offset = 20 + Math.random() * 15;
                        let spawnX = x + Math.cos(angle) * offset;
                        let spawnY = y + Math.sin(angle) * offset;
                        let agent = new Agent(spawnX, spawnY, null, null, targetTribeId);
                        agent.role = agentType;
                        agent.assignColor();
                        agent.age = Math.random() * CONFIG.adultAge;
                        
                        // Apply role-specific bonuses (similar to spawnAgent)
                        if (agentType === 'Soldier') {
                            agent.health += 30;
                            agent.maxHealth += 30;
                            agent.canShootRanged = true;
                        } else if (agentType === 'Raider') {
                            agent.isPredator = true;
                            agent.health += 25;
                            agent.maxHealth += 25;
                            agent.color = '#dc2626';
                        } else if (agentType === 'Farmer') {
                            agent.isPrey = true;
                            agent.isGrazer = true;
                            agent.health += 10;
                            agent.maxHealth += 10;
                            agent.color = '#fde047';
                        }
                        
                        // Call determineRole if it exists (sets up role-specific properties)
                        if (typeof agent.determineRole === 'function') {
                            agent.determineRole();
                        }
                        this.agents.push(agent);
                    }
                    
                    let tribeName = this.tribes.tribes[targetTribeId]?.name || `Tribe ${targetTribeId}`;
                    let placementMsg = clickedNest ? 
                        `üë• PLACED 15 ${agentType}s joining ${tribeName} (nest) at (${Math.floor(x)}, ${Math.floor(y)})` :
                        `üë• PLACED 15 ${agentType}s joining ${tribeName} (random) at (${Math.floor(x)}, ${Math.floor(y)})`;
                    this.setStatusMessage(placementMsg, 300);
                    this.setTool(null);
                    return;
                }

                let clicked = this.agents.find(a => Vector.dist(m, a.pos) < a.radius + 5);
                
                if (clicked) {
                    this.selected = clicked;
                    document.getElementById('inspector').classList.remove('hidden');
                } else {
                    this.selected = null;
                    document.getElementById('inspector').classList.add('hidden');
                    // Spawn 16 random agents at click location
                    for (let i = 0; i < 16; i++) {
                        let angle = (i / 16) * Math.PI * 2;
                        let offset = 20 + Math.random() * 15;
                        let spawnX = x + Math.cos(angle) * offset;
                        let spawnY = y + Math.sin(angle) * offset;
                        let agent = new Agent(spawnX, spawnY, null, null, -1);
                        agent.age = Math.random() * CONFIG.adultAge;
                        this.agents.push(agent);
                    }
                }
                this.updateUI();
            }
            
            setStatusMessage(message, durationFrames = 300) {
                // Set a status message to display in the HUD
                this.statusMessage = message;
                this.statusMessageExpiry = this.frame + durationFrames;
            }

            updateUI() {
                if (this.frame % 5 === 0) {
                    if (document.getElementById('pop-count')) document.getElementById('pop-count').textContent = this.agents.length;
                    // Calculate max generation, handling undefined values and empty arrays
                    if (document.getElementById('gen-count')) {
                        if (this.agents.length === 0) {
                            document.getElementById('gen-count').textContent = 0;
                        } else {
                            // Filter out undefined/null generations and find max
                            let generations = this.agents
                                .map(a => a.generation)
                                .filter(gen => typeof gen === 'number' && !isNaN(gen));
                            if (generations.length > 0) {
                                document.getElementById('gen-count').textContent = Math.max(...generations);
                            } else {
                                document.getElementById('gen-count').textContent = 0;
                            }
                        }
                    }
                    if (document.getElementById('time-count')) document.getElementById('time-count').textContent = this.frame;
                    
                    // Crisis Alert - always show status message when not in crisis and no tool active
                    let crisisAlertBox = document.getElementById('crisis-alert');
                    let statusAlertBox = document.getElementById('status-alert');
                    let toolAlertBox = document.getElementById('tool-alert');
                    if (this.dynamicBirthRateMult > 1.5) {
                        crisisAlertBox.classList.remove('hidden');
                        statusAlertBox.classList.add('hidden');
                    } else {
                        crisisAlertBox.classList.add('hidden');
                        // Only show status alert if tool alert is also hidden
                        if (!toolAlertBox || toolAlertBox.classList.contains('hidden')) {
                            statusAlertBox.classList.remove('hidden');
                            
                            // Check if there's a status message to display
                            if (this.statusMessage && this.frame < this.statusMessageExpiry) {
                                statusAlertBox.textContent = this.statusMessage;
                                // Use different color for different message types
                                if (this.statusMessage.includes('WAR DECLARED')) {
                                    statusAlertBox.className = 'text-[10px] text-red-400 font-bold';
                                } else if (this.statusMessage.includes('WAR ENDED')) {
                                    statusAlertBox.className = 'text-[10px] text-green-300 font-bold';
                                } else if (this.statusMessage.includes('CATACLYSM')) {
                                    statusAlertBox.className = 'text-[10px] text-orange-400 font-bold';
                                } else {
                                    statusAlertBox.className = 'text-[10px] text-yellow-300 font-bold';
                                }
                            } else {
                                // Clear expired status message and return to normal
                                if (this.statusMessage && this.frame >= this.statusMessageExpiry) {
                                    this.statusMessage = null;
                                }
                                statusAlertBox.textContent = "‚ú® Life Signs Healthy ‚ú®";
                                statusAlertBox.className = 'text-[10px] text-green-300 font-bold';
                            }
                        }
                    }

                    let counts = { FOOD: 0, MAT: 0, STIM: 0, SEED: 0, TREASURE: 0 };
                    this.resources.forEach(r => { if(counts[r.type] !== undefined) counts[r.type]++; });
                    
                    if (document.getElementById('res-green')) document.getElementById('res-green').textContent = counts.FOOD;
                    if (document.getElementById('res-gold')) document.getElementById('res-gold').textContent = counts.MAT;
                    if (document.getElementById('res-treasure')) document.getElementById('res-treasure').textContent = counts.TREASURE;

                    let infected = this.agents.filter(a => a.disease > 0).length;
                    let immune = this.agents.filter(a => a.immunity > 0).length;
                    if (document.getElementById('stat-infected')) document.getElementById('stat-infected').textContent = infected;
                    if (document.getElementById('stat-immune')) document.getElementById('stat-immune').textContent = immune;

                    let list = document.getElementById('tribe-list');
                    if (list) {
                        list.innerHTML = '';
                        // Collect all active tribes and sort by population
                        let activeTribes = [];
                        for(let tid in this.tribes.tribes) {
                            let t = this.tribes.tribes[tid];
                            let members = this.agents.filter(a => a.tribeId == tid);
                            let count = members.length;
                            let nest = this.tribes.nests.find(n => n.tribeId == tid);
                            let nestWealth = nest ? Math.floor(nest.wealth) : 0;

                            if(count > 0 || nestWealth > 0) {
                                activeTribes.push({ t, count, nestWealth, tid });
                            }
                        }
                        
                        // Sort by population (largest first) and limit to top 20
                        activeTribes.sort((a, b) => b.count - a.count);
                        activeTribes.slice(0, 20).forEach(({ t, count, nestWealth }) => {
                                let div = document.createElement('div');
                                div.style.color = t.color;
                                div.textContent = `${t.name} [T${t.techTier}]: ${count} | Nest: $${nestWealth} | Lead: ${t.leaderId || 'None'}`;
                                list.appendChild(div);
                        });
                    }
                }

                if (this.selected && !this.selected.dead) {
                    let a = this.selected;
                    if (document.getElementById('ins-id')) document.getElementById('ins-id').textContent = `${a.id} (Gen ${a.generation})`;
                    if (document.getElementById('ins-role-tag')) {
                        document.getElementById('ins-role-tag').textContent = a.role.toUpperCase();
                        document.getElementById('ins-role-tag').style.color = a.color;
                    }
                    if (document.getElementById('ins-wealth')) {
                        document.getElementById('ins-wealth').textContent = `Wealth: $${Math.floor(a.wealth)}`;
                    }
                    
                    let heroEl = document.getElementById('ins-hero');
                    if (heroEl) {
                        heroEl.style.display = a.isHero ? 'block' : 'none';
                    }

                    if (document.getElementById('ins-age')) {
                        let lifeStage = a.isAdult() ? "Adult" : "Child";
                        document.getElementById('ins-age').textContent = `${a.age} (${lifeStage})`;
                    }
                    
                    if (document.getElementById('ins-tribe-tag')) {
                        let tName = a.tribeId === -1 ? "None" : (this.tribes.tribes[a.tribeId]?.name || "Unknown");
                        let tColor = a.tribeId === -1 ? "#fff" : this.tribes.tribes[a.tribeId].color;
                        let tribeEl = document.getElementById('ins-tribe-tag');
                        tribeEl.textContent = tName;
                        tribeEl.style.color = tColor;
                        tribeEl.style.borderColor = tColor;
                    }

                    if (document.getElementById('ins-state')) {
                        document.getElementById('ins-state').textContent = a.state;
                        document.getElementById('ins-state').className = `text-xs font-bold uppercase tracking-wider ${a.state === 'Hunting' ? 'text-red-500' : 'text-yellow-400'}`;
                    }
                    
                    if(document.getElementById('ins-health-status')) {
                        let status = "Healthy";
                        let color = "text-green-400";
                        if(a.disease > 0) { status = "INFECTED"; color = "text-red-500"; }
                        else if(a.immunity > 0) { status = "IMMUNE"; color = "text-blue-400"; }
                        
                        let el = document.getElementById('ins-health-status');
                        el.textContent = status;
                        el.className = `text-[10px] font-bold mt-1 ${color}`;
                    }

                    // NEW: Bond Status in Inspector
                    if(document.getElementById('ins-bond-status')) {
                        let count = a.partners.length;
                        let txt = count > 0 ? `Bonded (${count})` : "Single";
                        if (count >= a.maxBonds) txt += " [MAX]";
                        document.getElementById('ins-bond-status').textContent = txt;
                    }

                    if (document.getElementById('ins-energy')) document.getElementById('ins-energy').style.width = `${(a.energy/a.maxEnergy)*100}%`;
                    if (document.getElementById('ins-health')) document.getElementById('ins-health').style.width = `${(a.health/(a.role==='Monster'?500:100))*100}%`;
                    if (document.getElementById('ins-life')) document.getElementById('ins-life').style.width = `${(a.lifespan/a.maxLifespan)*100}%`;
                    
                    if (document.getElementById('ins-inv')) document.getElementById('ins-inv').textContent = a.carrying ? a.carrying.type : "Empty";
                    if (document.getElementById('ins-home')) document.getElementById('ins-home').textContent = a.home ? "Yes" : "No";
                    if (document.getElementById('ins-charisma')) document.getElementById('ins-charisma').textContent = a.charisma;
                    
                    let loverCount = Object.values(a.loyalty).filter(l => l > CONFIG.loveThreshold).length;
                    if (document.getElementById('ins-lovers')) document.getElementById('ins-lovers').textContent = loverCount;

                    if (document.getElementById('ins-dna-aggro')) document.getElementById('ins-dna-aggro').style.width = `${a.dna.aggression*100}%`;
                    if (document.getElementById('ins-dna-raid')) document.getElementById('ins-dna-raid').style.width = `${a.dna.raiding*100}%`;
                    if (document.getElementById('ins-dna-def')) document.getElementById('ins-dna-def').style.width = `${a.dna.defense*100}%`;
                    if (document.getElementById('ins-dna-botany')) document.getElementById('ins-dna-botany').style.width = `${a.dna.botany*100}%`;
                    if (document.getElementById('ins-dna-build')) document.getElementById('ins-dna-build').style.width = `${a.dna.builder*100}%`;
                    if (document.getElementById('ins-dna-manu')) document.getElementById('ins-dna-manu').style.width = `${a.dna.manufacturing*100}%`;
                    if (document.getElementById('ins-dna-intel')) document.getElementById('ins-dna-intel').style.width = `${a.dna.intelligence*100}%`;
                    if (document.getElementById('ins-dna-comm')) document.getElementById('ins-dna-comm').style.width = `${a.dna.commerce*100}%`;
                    if (document.getElementById('ins-dna-altruism')) document.getElementById('ins-dna-altruism').style.width = `${a.dna.altruism*100}%`;
                    if (document.getElementById('ins-dna-curiosity')) document.getElementById('ins-dna-curiosity').style.width = `${a.dna.curiosity*100}%`;
                    
                    if (document.getElementById('ins-skills')) {
                        let skillsHtml = '';
                        for(let s in a.skills) {
                            if(a.skills[s] > 0) skillsHtml += `<div class="bg-gray-700 rounded p-1">${s}: ${a.skills[s]}</div>`;
                        }
                        document.getElementById('ins-skills').innerHTML = skillsHtml || '<div class="col-span-4 italic text-gray-600">No Skills</div>';
                    }

                    let elHunt = document.getElementById('learn-hunt');
                    if (elHunt) elHunt.textContent = a.prefs.hunt.toFixed(2);
                    let elBuild = document.getElementById('learn-build');
                    if (elBuild) elBuild.textContent = a.prefs.build.toFixed(2);
                    let elSocial = document.getElementById('learn-social');
                    if (elSocial) elSocial.textContent = a.prefs.social.toFixed(2);

                } else if (this.selected && this.selected.dead) {
                    document.getElementById('inspector').classList.add('hidden');
                    this.selected = null;
                }
            }

            reset() {
                this.init();
            }
            
            togglePause() {
                this.running = !this.running;
                document.getElementById('pause-btn').textContent = this.running ? "Pause" : "Resume";
                if (this.running) this.loop();
            }
            
            toggleSound(enabled) {
                if (enabled) {
                    sfx.enable();
                    // Ensure audio context is resumed and audio plays after user interaction
                    if (sfx.audioContext && sfx.audioContext.state === 'suspended') {
                        sfx.audioContext.resume().then(() => {
                            console.log('Audio context resumed via sound toggle');
                            // Try to play background audio if it exists
                            if (sfx.backgroundAudio && sfx.backgroundAudio.paused) {
                                sfx.backgroundAudio.play().catch(e => {
                                    console.error('Error playing background audio after toggle:', e);
                                });
                            }
                        });
                    } else if (sfx.backgroundAudio && sfx.backgroundAudio.paused) {
                        // Audio context is running, try to play directly
                        sfx.backgroundAudio.play().catch(e => {
                            console.error('Error playing background audio:', e);
                        });
                    }
                } else {
                    sfx.disable();
                }
            }
            
            updateVolume(value) {
                CONFIG.sfxVolume = parseFloat(value);
                document.getElementById('volume-display').textContent = Math.round(value * 100) + '%';
                
                // Update background music volume if it's playing
                if (sfx && sfx.backgroundGain && sfx.audioContext) {
                    const mainVolume = Math.max(0.4, CONFIG.sfxVolume) * 0.6;
                    sfx.backgroundGain.gain.setValueAtTime(mainVolume, sfx.audioContext.currentTime);
                }
            }

            loop() {
                if (!this.running) return;
                
                // Reset per-frame sound throttle flags at start of each frame
                soundThrottle.loveSoundPlayedThisFrame = false;
                soundThrottle.battleSoundPlayedThisFrame = false;

                // Resource spawning with separate food spawn rate
                if (this.resources.length < CONFIG.maxRes) {
                    if (Math.random() < CONFIG.foodSpawnRate) {
                        this.spawnResource(null, null, null, 'FOOD');
                    }
                    if (Math.random() < CONFIG.resSpawnRate) {
                    this.spawnResource(null, null, null);
                }
                }
                
                // Food spawn near nests (reduced rate and shorter lifespan)
                if (Math.random() < CONFIG.foodSpawnNearNestsRate && this.tribes.nests.length > 0) {
                    let nest = this.tribes.nests[Math.floor(Math.random() * this.tribes.nests.length)];
                    let angle = Math.random() * Math.PI * 2;
                    let dist = nest.radius + 20 + Math.random() * 40; // Spawn 20-60 pixels from nest edge (closer)
                    let nx = nest.pos.x + Math.cos(angle) * dist;
                    let ny = nest.pos.y + Math.sin(angle) * dist;
                    if (nx > 0 && nx < this.width && ny > 0 && ny < this.height) {
                        this.spawnResource(null, nx, ny, 'FOOD', true); // Mark as nest-spawned for shorter life
                    }
                }
                
                // RESOURCE MANUFACTURING TECH - Nests spawn raw materials based on tech level
                if (this.frame % 50 === 0) { // Check every 50 frames
                    this.tribes.nests.forEach(nest => {
                        let tribe = this.tribes.tribes[nest.tribeId];
                        if (!tribe) return;
                        
                        let resourceMfgLevel = tribe.techTree.resource_manufacturing.level;
                        if (resourceMfgLevel > 0) {
                            // Spawn rate increases with tech level
                            let spawnChance = resourceMfgLevel * 0.05; // 5% chance per level
                            
                            if (Math.random() < spawnChance) {
                                // Spawn raw materials (MAT, ORE) near nest
                                let angle = Math.random() * Math.PI * 2;
                                let dist = nest.radius + 30 + Math.random() * 80;
                                let nx = nest.pos.x + Math.cos(angle) * dist;
                                let ny = nest.pos.y + Math.sin(angle) * dist;
                                
                                if (nx > 0 && nx < this.width && ny > 0 && ny < this.height) {
                                    let resourceType = Math.random() < 0.5 ? 'MAT' : 'ORE';
                                    this.spawnResource(null, nx, ny, resourceType);
                                    this.particles.push(new Particle(nx, ny, '#eab308', 'spark'));
                                }
                            }
                        }
                    });
                }
                
                // Unaffiliated agents forming new tribes
                let unaffiliated = this.agents.filter(a => a.tribeId === -1 && a.isAdult() && a.role !== 'Monster');
                if (unaffiliated.length >= 5 && Math.random() < 0.01) {
                    // Find a cluster of unaffiliated agents
                    let leader = unaffiliated[Math.floor(Math.random() * unaffiliated.length)];
                    let nearby = unaffiliated.filter(a => Vector.dist(a.pos, leader.pos) < 150);
                    if (nearby.length >= 3) {
                        // Form new tribe
                        let newTribeId = this.tribes.createTribe(`New Tribe ${this.tribes.nextId}`, null);
                        nearby.forEach(a => {
                            a.tribeId = newTribeId;
                            a.color = this.tribes.tribes[newTribeId].color;
                        });
                        // Create nest at valid position (not too close to other nests)
                        let pos = this.tribes.findValidNestPosition(leader.pos.x, leader.pos.y);
                        let newNest3 = new Nest(pos.x, pos.y, newTribeId);
                        this.tribes.nests.push(newNest3);
                        
                        // NEST BIRTH SOUND - Play birth-like tone when nest is created
                        if (typeof sfx !== 'undefined' && sfx.enabled) {
                            sfx.play('birth', getHarmonicFreq([HARMONICS.C5, HARMONICS.E5, HARMONICS.G5, HARMONICS.A5], 10), 0.1); // Harmonic birth tone
                        }
                        this.particles.push(new Particle(pos.x, pos.y, '#ffffff', 'spark'));
                    }
                }
                
                // PREY ASEXUAL REPRODUCTION NEAR FOOD SOURCES
                let preyAgents = this.agents.filter(a => a.isPrey && a.isAdult() && !a.dead);
                preyAgents.forEach(prey => {
                    // Find nearby food
                    let nearbyFood = this.resources.filter(r => 
                        r.type === 'FOOD' && 
                        r.active && 
                        Vector.dist(prey.pos, r.pos) < CONFIG.preyAsexualReproductionRadius
                    );
                    
                    if (nearbyFood.length > 0 && Math.random() < CONFIG.preyAsexualReproductionRate && prey.energy > 60) {
                        // Asexual reproduction - clone self with slight mutation
                        let cloneDna = {...prey.dna};
                        // Small mutations
                        for (let gene in cloneDna) {
                            if (typeof cloneDna[gene] === 'number' && Math.random() < 0.1) {
                                cloneDna[gene] += (Math.random() - 0.5) * 0.1;
                                cloneDna[gene] = Math.max(0, Math.min(1, cloneDna[gene]));
                            }
                        }
                        
                        let offspring = new Agent(
                            prey.pos.x + (Math.random() * 30 - 15), 
                            prey.pos.y + (Math.random() * 30 - 15), 
                            cloneDna, 
                            null, 
                            -1
                        );
                        offspring.role = 'Prey';
                        offspring.isPrey = true;
                        this.agents.push(offspring);
                        
                        prey.energy -= 40;
                        this.particles.push(new Particle(prey.pos.x, prey.pos.y, '#facc15', 'heart'));
                        sfx.play('birth', HARMONICS.C5, 0.1); // Harmonic birth tone
                    }
                });
                
                // PREY SEXUAL REPRODUCTION (controlled)
                preyAgents.forEach(prey => {
                    if (!prey.mateCooldown) prey.mateCooldown = 0; // Initialize if needed
                    if (prey.mateCooldown > 0) {
                        prey.mateCooldown--;
                        return;
                    }
                    if (prey.energy < CONFIG.preyMateEnergyThreshold) return;
                    
                    // Find nearby prey mate
                    let nearbyMates = preyAgents.filter(p => 
                        p !== prey && 
                        p.mateCooldown === 0 && 
                        p.energy >= CONFIG.preyMateEnergyThreshold &&
                        Vector.dist(prey.pos, p.pos) < 50
                    );
                    
                    if (nearbyMates.length > 0 && Math.random() < CONFIG.preyMateRate) {
                        let mate = nearbyMates[0];
                        
                        // Create offspring with mixed DNA
                        let childDna = {};
                        for (let gene in prey.dna) {
                            childDna[gene] = Math.random() < 0.5 ? prey.dna[gene] : mate.dna[gene];
                            if (Math.random() < 0.1) { // Mutation
                                if (typeof childDna[gene] === 'number') {
                                    childDna[gene] += (Math.random() - 0.5) * 0.15;
                                    childDna[gene] = Math.max(0, Math.min(1, childDna[gene]));
                                }
                            }
                        }
                        
                        let offspring = new Agent(
                            (prey.pos.x + mate.pos.x) / 2, 
                            (prey.pos.y + mate.pos.y) / 2, 
                            childDna, 
                            null, 
                            -1
                        );
                        offspring.role = 'Prey';
                        offspring.isPrey = true;
                        this.agents.push(offspring);
                        
                        prey.energy -= 30;
                        mate.energy -= 30;
                        prey.mateCooldown = CONFIG.preyMateCooldown;
                        mate.mateCooldown = CONFIG.preyMateCooldown;
                        
                        this.particles.push(new Particle(offspring.pos.x, offspring.pos.y, '#facc15', 'heart'));
                        sfx.play('birth', HARMONICS.C5_SHARP, 0.1); // Harmonic birth tone
                    }
                });
                
                // PREDATOR SEXUAL REPRODUCTION (controlled, slow)
                let predatorAgents = this.agents.filter(a => a.isPredator && a.isAdult() && !a.dead);
                if (!predatorAgents.mateCooldown) {
                    predatorAgents.forEach(p => { if (!p.mateCooldown) p.mateCooldown = 0; });
                }
                predatorAgents.forEach(predator => {
                    if (predator.mateCooldown > 0) {
                        predator.mateCooldown--;
                        return;
                    }
                    if (predator.energy < CONFIG.predatorMateEnergyThreshold) return;
                    
                    // Find nearby predator mate
                    let nearbyMates = predatorAgents.filter(p => 
                        p !== predator && 
                        p.mateCooldown === 0 && 
                        p.energy >= CONFIG.predatorMateEnergyThreshold &&
                        Vector.dist(predator.pos, p.pos) < 60
                    );
                    
                    if (nearbyMates.length > 0 && Math.random() < CONFIG.predatorMateRate) {
                        let mate = nearbyMates[0];
                        
                        // Create offspring with mixed DNA
                        let childDna = {};
                        for (let gene in predator.dna) {
                            childDna[gene] = Math.random() < 0.5 ? predator.dna[gene] : mate.dna[gene];
                            if (Math.random() < 0.08) { // Slight mutation
                                if (typeof childDna[gene] === 'number') {
                                    childDna[gene] += (Math.random() - 0.5) * 0.1;
                                    childDna[gene] = Math.max(0, Math.min(1, childDna[gene]));
                                }
                            }
                        }
                        
                        let offspring = new Agent(
                            (predator.pos.x + mate.pos.x) / 2, 
                            (predator.pos.y + mate.pos.y) / 2, 
                            childDna, 
                            null, 
                            -1
                        );
                        offspring.role = 'Predator';
                        offspring.isPredator = true;
                        this.agents.push(offspring);
                        
                        predator.energy -= 50;
                        mate.energy -= 50;
                        predator.mateCooldown = CONFIG.predatorMateCooldown;
                        mate.mateCooldown = CONFIG.predatorMateCooldown;
                        
                        this.particles.push(new Particle(offspring.pos.x, offspring.pos.y, '#dc2626', 'heart'));
                        sfx.play('birth', HARMONICS.E4, 0.1); // Harmonic birth tone
                    }
                });
                
                // PREDATOR SPAWNING IN PAIRS
                if (Math.random() < CONFIG.predatorSpawnRate) {
                    let spawnX = Math.random() * this.width;
                    let spawnY = Math.random() * this.height;
                    
                    for (let i = 0; i < 2; i++) {
                        let offsetX = (Math.random() - 0.5) * CONFIG.predatorPairSpawnRadius;
                        let offsetY = (Math.random() - 0.5) * CONFIG.predatorPairSpawnRadius;
                        
                        let predatorDna = {
                            predator_gene: 0.9,
                            aggression: 0.7 + Math.random() * 0.3,
                            speed: 0.6 + Math.random() * 0.4,
                            size: 0.5 + Math.random() * 0.3,
                            sociability: 0.6 + Math.random() * 0.4
                        };
                        
                        let predator = new Agent(
                            spawnX + offsetX, 
                            spawnY + offsetY, 
                            predatorDna, 
                            null, 
                            -1
                        );
                        predator.role = 'Predator';
                        predator.isPredator = true;
                        this.agents.push(predator);
                        this.particles.push(new Particle(predator.pos.x, predator.pos.y, '#dc2626', 'spark'));
                    }
                    sfx.play('birth', HARMONICS.E4, 0.1); // Harmonic birth tone
                }
                
                // PREY SPAWNING IN GROUPS OF 3 NEAR HIGH FOOD CONCENTRATIONS
                if (Math.random() < CONFIG.preySpawnRate) {
                    // Find areas with high food concentration
                    let foodResources = this.resources.filter(r => r.type === 'FOOD' && r.active);
                    if (foodResources.length > 5) {
                        // Pick a random food as spawn center
                        let centerFood = foodResources[Math.floor(Math.random() * foodResources.length)];
                        
                        // Count nearby food
                        let nearbyFoodCount = foodResources.filter(r => 
                            Vector.dist(r.pos, centerFood.pos) < 150
                        ).length;
                        
                        // Only spawn if there's a concentration (3+ food items nearby)
                        if (nearbyFoodCount >= 3) {
                            for (let i = 0; i < 3; i++) {
                                let offsetX = (Math.random() - 0.5) * 80;
                                let offsetY = (Math.random() - 0.5) * 80;
                                
                                let preyDna = {
                                    prey_gene: 0.9,
                                    speed: 0.6 + Math.random() * 0.3,
                                    size: 0.4 + Math.random() * 0.2,
                                    sociability: 0.8 + Math.random() * 0.2
                                };
                                
                                let prey = new Agent(
                                    centerFood.pos.x + offsetX, 
                                    centerFood.pos.y + offsetY, 
                                    preyDna, 
                                    null, 
                                    -1
                                );
                                prey.role = 'Prey';
                                prey.isPrey = true;
                                this.agents.push(prey);
                                this.particles.push(new Particle(prey.pos.x, prey.pos.y, '#facc15', 'spark'));
                            }
                            sfx.play('birth', HARMONICS.C5, 0.1); // Harmonic birth tone
                        }
                    }
                }
                
                // AUTO-SPAWN DIPLOMATS & MERCHANTS BASED ON LINK STRENGTH
                if (this.frame % 300 === 0) { // Check every 300 frames
                    this.tribes.nests.forEach(nest => {
                        let tribeMembers = this.agents.filter(a => a.tribeId === nest.tribeId && a.isAdult() && !a.dead);
                        let diplomats = tribeMembers.filter(a => a.role === 'Diplomat').length;
                        let merchants = tribeMembers.filter(a => a.role === 'Merchant').length;
                        
                        let tribe = this.tribes.tribes[nest.tribeId];
                        if (!tribe) return;
                        
                        // Count diplomatic link strength (including to enemies for peace negotiations)
                        let totalDiplomaticStrength = 0;
                        let needsDiplomats = 0;
                        
                        for (let otherId in this.tribes.tribes) {
                            if (otherId == nest.tribeId) continue;
                            let otherNest = this.tribes.nests.find(n => n.tribeId == otherId);
                            if (!otherNest) continue;
                            
                            let distance = Vector.distTorus(nest.pos, otherNest.pos, sim.width, sim.height);
                            if (distance > CONFIG.diplomatSpawnDistance) continue;
                            
                            // Diplomatic bonds create demand for diplomats
                            let dipBond = tribe.diplomaticBonds[otherId] || 0;
                            totalDiplomaticStrength += dipBond;
                            
                            // Wars ALSO create demand for diplomats (to negotiate peace!)
                            if (tribe.atWarWith[otherId]) {
                                needsDiplomats += 2; // Wars demand diplomats
                                totalDiplomaticStrength += 50; // Treat as strong link
                            } else if (dipBond > 20) {
                                needsDiplomats += 1;
                            }
                        }
                        
                        // Count commercial link strength
                        let totalCommercialStrength = 0;
                        let needsMerchants = 0;
                        
                        for (let otherId in this.tribes.tribes) {
                            if (otherId == nest.tribeId) continue;
                            let otherNest = this.tribes.nests.find(n => n.tribeId == otherId);
                            if (!otherNest) continue;
                            
                            let distance = Vector.distTorus(nest.pos, otherNest.pos, sim.width, sim.height);
                            if (distance > CONFIG.merchantSpawnDistance) continue;
                            
                            // Skip if at war - no trade
                            if (tribe.atWarWith[otherId]) continue;
                            
                            let comBond = tribe.commercialBonds[otherId] || 0;
                            totalCommercialStrength += comBond;
                            
                            if (comBond > 20) {
                                needsMerchants += 1;
                            }
                        }
                        
                        // ALWAYS maintain minimum diplomats/merchants per tribe (FIX: chicken-egg problem)
                        let diplomatNeed = Math.max(3, Math.ceil(needsDiplomats * (1 + totalDiplomaticStrength / 200))); // Min 3 (was 2)
                        let merchantNeed = Math.max(3, Math.ceil(needsMerchants * (1 + totalCommercialStrength / 200))); // Min 3 (was 2)
                        
                        // ALWAYS spawn diplomat if tribe has < minimum (even without existing bonds!)
                        if (diplomats < diplomatNeed && tribeMembers.length >= 3) { // Lowered from 5 to 3
                            let candidates = tribeMembers.filter(a => 
                                a.role !== 'Diplomat' && 
                                a.role !== 'Merchant' && // Don't convert merchants
                                a.role !== 'Leader' && 
                                a.role !== 'Guardian'
                            );
                            if (candidates.length > 0) {
                                let newDiplomat = candidates[Math.floor(Math.random() * candidates.length)];
                                newDiplomat.role = 'Diplomat';
                                newDiplomat.isSustainedByTribe = true; // Don't seek food/resources
                                newDiplomat.canDefendSelf = false; // Cannot attack
                                newDiplomat.maxHealth = 150; // Higher health (harder to kill)
                                newDiplomat.health = 150;
                                newDiplomat.assignColor();
                                this.particles.push(new Particle(newDiplomat.pos.x, newDiplomat.pos.y, '#fde047', 'star'));
                                sfx.play('diplomacy', 540, 0.12);
                            }
                        }
                        
                        // ALWAYS spawn merchant if tribe has < minimum and enough wealth
                        if (merchants < merchantNeed && nest.wealth > 30 && tribeMembers.length >= 3) { // Reduced from 50 to 30, members from 5 to 3
                            let candidates = tribeMembers.filter(a => 
                                a.role !== 'Merchant' && 
                                a.role !== 'Diplomat' && // Don't convert diplomats
                                a.role !== 'Leader' && 
                                a.role !== 'Guardian'
                            );
                            if (candidates.length > 0) {
                                let newMerchant = candidates[Math.floor(Math.random() * candidates.length)];
                                newMerchant.role = 'Merchant';
                                newMerchant.isSustainedByTribe = true; // Tribe-sustained, but CAN harvest resources for trade
                                newMerchant.canDefendSelf = false; // Cannot attack
                                newMerchant.maxHealth = 150; // Higher health (harder to kill)
                                newMerchant.health = 150;
                                newMerchant.assignColor();
                                this.particles.push(new Particle(newMerchant.pos.x, newMerchant.pos.y, '#be123c', 'coin'));
                                sfx.play('trade', 460, 0.15);
                            }
                        }
                    });
                }
                
                // TECH TREE PROGRESSION & DECAY
                if (this.frame % 200 === 0) { // Check every 200 frames
                    for (let tid in this.tribes.tribes) {
                        // Tech decay over time (must maintain through activity)
                        this.tribes.decayTech(tid);
                        
                        // Passive tech gains based on tribe activities
                        let tribe = this.tribes.tribes[tid];
                        let tribeMembers = this.agents.filter(a => a.tribeId == tid && !a.dead);
                        
                        // Agriculture tech from farmers and botanists (100x faster!)
                        let farmers = tribeMembers.filter(a => a.role === 'Farmer' || a.role === 'Botanist').length;
                        if (farmers > 0) this.tribes.progressTech(tid, 'agriculture', farmers * 20);
                        
                        // Construction tech from builders (200x faster!)
                        let builders = tribeMembers.filter(a => a.role === 'Builder').length;
                        if (builders > 0) this.tribes.progressTech(tid, 'construction', builders * 20);
                        
                        // Manufacturing tech from artisans (200x faster!)
                        let artisans = tribeMembers.filter(a => a.role === 'Artisan').length;
                        if (artisans > 0) this.tribes.progressTech(tid, 'manufacturing', artisans * 20);
                        
                        // Medicine tech from healers (200x faster!)
                        let healers = tribeMembers.filter(a => a.role === 'Healer').length;
                        if (healers > 0) this.tribes.progressTech(tid, 'medicine', healers * 20);
                        
                        // Science tech from scientists (300x faster!)
                        let scientists = tribeMembers.filter(a => a.role === 'Scientist').length;
                        if (scientists > 0) this.tribes.progressTech(tid, 'science', scientists * 30);
                        
                        // Education tech from teachers (200x faster!)
                        let teachers = tribeMembers.filter(a => a.role === 'Teacher').length;
                        if (teachers > 0) this.tribes.progressTech(tid, 'education', teachers * 20);
                        
                        // Combat tech from soldiers and guardians (150x faster!)
                        let combatants = tribeMembers.filter(a => a.role === 'Soldier' || a.role === 'Guardian').length;
                        if (combatants > 0) this.tribes.progressTech(tid, 'combat', combatants * 15);
                        
                        // Warfare tech from raiders (200x faster!)
                        let raiders = tribeMembers.filter(a => a.role === 'Raider').length;
                        if (raiders > 0) this.tribes.progressTech(tid, 'warfare', raiders * 20);
                        
                        // Diplomacy tech from diplomats (passive gain, 160x faster!)
                        let diplomats = tribeMembers.filter(a => a.role === 'Diplomat').length;
                        if (diplomats > 0) this.tribes.progressTech(tid, 'diplomacy', diplomats * 16);
                        
                        // Commerce tech from merchants (passive gain, 160x faster!)
                        let merchants = tribeMembers.filter(a => a.role === 'Merchant').length;
                        if (merchants > 0) this.tribes.progressTech(tid, 'commerce', merchants * 16);
                    }
                }
                
                // DENSITY-DEPENDENT REPRODUCTION (S-CURVE OSCILLATION)
                // Population density relative to cap
                let density = this.agents.length / CONFIG.popCap;
                
                // S-curve reproduction rate based on density
                // Low density (<0.2): low birth rate (sparse population)
                // Optimal density (~0.5): peak birth rate (healthy population)
                // High density (>0.9): reduced birth rate (crowding/resource competition)
                if (density < CONFIG.reproductionDensityMin) {
                    // Too sparse - low reproduction
                    let sparsityFactor = density / CONFIG.reproductionDensityMin;
                    this.dynamicBirthRateMult = CONFIG.reproductionMinMultiplier + 
                        (1.0 - CONFIG.reproductionMinMultiplier) * sparsityFactor;
                } else if (density < CONFIG.reproductionDensityOptimal) {
                    // Growing towards optimal - increasing reproduction
                    let growthFactor = (density - CONFIG.reproductionDensityMin) / 
                        (CONFIG.reproductionDensityOptimal - CONFIG.reproductionDensityMin);
                    this.dynamicBirthRateMult = 1.0 + 
                        (CONFIG.reproductionMaxMultiplier - 1.0) * growthFactor;
                } else if (density < CONFIG.reproductionDensityMax) {
                    // Optimal to crowded - decreasing reproduction
                    let crowdingFactor = (density - CONFIG.reproductionDensityOptimal) / 
                        (CONFIG.reproductionDensityMax - CONFIG.reproductionDensityOptimal);
                    this.dynamicBirthRateMult = CONFIG.reproductionMaxMultiplier - 
                        (CONFIG.reproductionMaxMultiplier - 1.0) * crowdingFactor;
                } else {
                    // Overcrowded - minimal reproduction
                    let overCrowdFactor = Math.min(1.0, (density - CONFIG.reproductionDensityMax) / 0.1);
                    this.dynamicBirthRateMult = 1.0 - (1.0 - CONFIG.reproductionMinMultiplier) * overCrowdFactor;
                }

                // CRITICAL FIX: Update ALL agents every frame to prevent jitter from staggered updates
                // Staggered updates cause agents to move at different rates, creating visual jitter
                // Instead, update all agents every frame but skip expensive operations for some
                let totalAgents = this.agents.length;
                let groupEntityCount = this.agents.filter(a => a.isGroupEntity).length;
                let useLightweightUpdates = totalAgents > 120 || groupEntityCount > 15;
                
                if (useLightweightUpdates) {
                    // Update all agents every frame, but stagger expensive operations
                    let expensiveOpStagger = totalAgents > 150 ? 4 : 3; // Skip expensive ops for some agents
                    for (let i = 0; i < this.agents.length; i++) {
                        let agent = this.agents[i];
                        // Always do basic position/movement updates
                        let doExpensiveOps = (i % expensiveOpStagger) === (this.frame % expensiveOpStagger);
                        // Pass flag to skip expensive operations
                        agent.update(this.resources, this.agents, doExpensiveOps);
                        // Mating check less frequently
                        if (doExpensiveOps && sim.agents.length < CONFIG.popCap) {
                            agent.checkMating(this.agents);
                        }
                    }
                } else {
                    // Normal update for small populations
                this.agents.forEach(a => {
                        a.update(this.resources, this.agents, true);
                        if (sim.agents.length < CONFIG.popCap) a.checkMating(this.agents);
                    });
                }
                
                // PERFORMANCE OPTIMIZATION: Update spatial grid much less frequently when population is high
                // This reduces expensive grid rebuilds that cause jitter
                // Reuse totalAgents from staggered updates section above
                let gridUpdateInterval = 2; // Default: every 2 frames
                if (totalAgents > 120) {
                    gridUpdateInterval = 8; // Every 8 frames when population is high - much less frequent
                } else if (totalAgents > 100) {
                    gridUpdateInterval = 6; // Every 6 frames
                } else if (totalAgents > 100) {
                    gridUpdateInterval = 4; // Every 4 frames when population is moderate
                }
                if (this.frame % gridUpdateInterval === 0) {
                    this._updateSpatialGrid();
                }
                
                // PERFORMANCE OPTIMIZATION: Update particles less frequently when population is high
                let particleUpdateInterval = 1; // Default: every frame
                if (totalAgents > 120) {
                    particleUpdateInterval = 2; // Every 2 frames when population is high
                }
                if (this.frame % particleUpdateInterval === 0) {
                this.particles.forEach(p => p.update());
                }
                // CRITICAL: Always clean up particles every frame, even if not updated
                // This prevents accumulation when update interval is > 1
                if (this.particles.length > 500) {
                    // If too many particles, aggressively clean up and cap at 300
                    this.particles = this.particles.filter(p => p.life > 0.1);
                    if (this.particles.length > 300) {
                        // Keep only the newest particles (last 300)
                        this.particles = this.particles.slice(-300);
                    }
                } else {
                    this.particles = this.particles.filter(p => p.life > 0);
                }
                
                // PERFORMANCE: Clean up old birth records (keep only last 180 frames = 3 seconds)
                if (this.recentBirths) {
                    this.recentBirths = this.recentBirths.filter(birth => this.frame - birth.frame < 180);
                }
                
                this.plagues.forEach(p => p.update());
                this.plagues = this.plagues.filter(p => p.life > 0);
                // Cap plagues if too many
                if (this.plagues.length > 20) {
                    this.plagues = this.plagues.slice(-20);
                }
                this.projectiles = this.projectiles.filter(p => p.life > 0);
                // Cap projectiles if too many
                if (this.projectiles.length > 100) {
                    this.projectiles = this.projectiles.slice(-100);
                }

                // Plague infection logic - reduced damage
                this.plagues.forEach(p => {
                    // Damage agents in plague radius
                    this.agents.forEach(a => {
                        if (Vector.dist(a.pos, p.pos) < p.radius) {
                            // Highly damaging plague - severe disease and direct health damage
                            a.disease = Math.max(a.disease, 800); // Severe disease (was 200)
                            // Direct health damage - quite damaging
                            a.health -= 3; // Direct damage per frame while in plague
                            // Also damage energy
                            a.energy -= 1.5; // More energy drain
                            // Visual feedback
                            if (this.frame % 5 === 0) {
                                this.particles.push(new Particle(a.pos.x, a.pos.y, '#22c55e', 'spark')); // Green particles for plague damage
                            }
                        }
                    });
                    
                    // Damage nests in plague radius
                    this.tribes.nests.forEach(nest => {
                        if (Vector.dist(nest.pos, p.pos) < p.radius + nest.radius) {
                            // Plague damages nest health and wealth
                            nest.hp -= 2; // Direct HP damage per frame
                            nest.health = Math.min(nest.maxHealth, nest.hp);
                            nest.wealth -= 1; // Also damages wealth
                            // Visual feedback for nest damage
                            if (this.frame % 10 === 0) {
                                this.particles.push(new Particle(nest.pos.x, nest.pos.y, '#22c55e', 'spark')); // Green particles for nest plague damage
                            }
                        }
                    });
                });
                this.plagues = this.plagues.filter(p => p.life > 0);
                
                // NEST UPDATE
                this.tribes.nests.forEach(n => n.update());
                
                // Track nest count before filtering to detect nest deaths
                let nestsBefore = this.tribes.nests.length;
                
                // Remove dead nests (HP <= 0)
                this.tribes.nests = this.tribes.nests.filter(n => n.hp > 0);
                
                // Track agent count before filtering to detect large die-offs
                let agentsBefore = this.agents.length;
                this.agents = this.agents.filter(a => !a.dead);
                let agentsAfter = this.agents.length;
                
                // Aggressive cleanup after nest death
                if (nestsBefore > this.tribes.nests.length) {
                    console.log(`Nest(s) died: ${nestsBefore} -> ${this.tribes.nests.length}, triggering cleanup`);
                    this._cleanupAfterLargeDieOff();
                }
                
                // Aggressive cleanup after large die-off (more than 30% of agents died)
                if (agentsBefore > 0 && (agentsBefore - agentsAfter) > agentsBefore * 0.3) {
                    console.log(`Large die-off detected: ${agentsBefore} -> ${agentsAfter} (${Math.round((agentsBefore - agentsAfter) / agentsBefore * 100)}% died), triggering cleanup`);
                    this._cleanupAfterLargeDieOff();
                }

                // TRIBE BENEFITS FROM SPECIALISTS & LINKED NEST RESOURCE SHARING
                if (this.frame % 100 === 0) { // Check every 100 frames
                    this.tribes.nests.forEach(nest => {
                        let tribeMembers = this.agents.filter(a => a.tribeId === nest.tribeId && !a.dead);
                        
                        // Get tribe object for this nest
                        let myTribe = this.tribes.tribes[nest.tribeId];
                        
                        // Check for COMMERCIAL BONDS - Economic benefits multiplier
                        let myTribeForEconomics = myTribe;
                        let hasCommercialBonds = false;
                        let commercialBondCount = 0;
                        if (myTribeForEconomics && myTribeForEconomics.commercialBonds) {
                            for (let otherId in myTribeForEconomics.commercialBonds) {
                                if (myTribeForEconomics.commercialBonds[otherId] > 10) {
                                    hasCommercialBonds = true;
                                    commercialBondCount++;
                                }
                            }
                        }
                        let economicBonus = hasCommercialBonds ? (1.0 + (commercialBondCount * 0.25)) : 1.0; // 25% per bond (increased from 12%)
                        
                        // ARTISAN BENEFITS - increase tribe wealth, health, healing (MASSIVELY INCREASED!)
                        let artisansList = tribeMembers.filter(a => a.role === 'Artisan');
                        if (artisansList.length > 0) {
                            let baseWealth = artisansList.length * 15; // +15 wealth per artisan
                            nest.wealth += baseWealth * economicBonus; // Boosted by economic bonds
                            nest.health = Math.min(nest.maxHealth, (nest.health || nest.maxHealth) + artisansList.length * 0.5); // Healing
                            
                            // Heal nearby tribe members
                            let nearbyMembers = tribeMembers.filter(a => Vector.dist(a.pos, nest.pos) < 150);
                            nearbyMembers.forEach(member => {
                                member.health = Math.min(member.maxHealth, member.health + artisansList.length * 0.2);
                            });
                            
                            // ECONOMIC BOND: Increased treasure production from Artisans
                            if (hasCommercialBonds && Math.random() < 0.15) { // 15% chance per cycle
                                sim.spawnResource(null, nest.pos.x + (Math.random() * 40 - 20), nest.pos.y + (Math.random() * 40 - 20), 'TREASURE', false, nest.tribeId);
                                this.particles.push(new Particle(nest.pos.x, nest.pos.y, '#fbbf24', 'coin'));
                            }
                            
                            // ARTISANS MAKE MUSICAL TONES (pleasant, brief)
                            if (Math.random() < 0.3) { // 30% chance per cycle
                                let artisan = artisansList[Math.floor(Math.random() * artisansList.length)];
                                // Musical scale frequencies: C, D, E, G, A (pentatonic - harmonic)
                                let musicalNotes = [HARMONICS.C5, HARMONICS.D5, HARMONICS.E5, HARMONICS.G5, HARMONICS.A5];
                                let note = musicalNotes[Math.floor(Math.random() * musicalNotes.length)];
                                sfx.play('artisan_tone', note, 0.15);
                                this.particles.push(new Particle(artisan.pos.x, artisan.pos.y, '#a5f3fc', 'star'));
                            }
                        }
                        
                        // ECONOMIC BOND: Increased agriculture production (Farmers/Botanists)
                        let farmersList = tribeMembers.filter(a => a.role === 'Farmer' || a.role === 'Botanist');
                        if (farmersList.length > 0 && hasCommercialBonds) {
                            // Increased food production during economic bonds (INCREASED BENEFITS)
                            if (Math.random() < 0.20 * commercialBondCount) { // 20% per bond (increased from 12%)
                                sim.spawnResource(null, nest.pos.x + (Math.random() * 50 - 25), nest.pos.y + (Math.random() * 50 - 25), 'FOOD', false, nest.tribeId);
                                this.particles.push(new Particle(nest.pos.x, nest.pos.y, '#4ade80', 'leaf'));
                            }
                        }
                        
                        // ECONOMIC BOND: Increased raw materials production (Miners/Gatherers)
                        let minersList = tribeMembers.filter(a => a.role === 'Miner' || a.role === 'Gatherer');
                        if (minersList.length > 0 && hasCommercialBonds) {
                            // Increased raw materials production during economic bonds (INCREASED BENEFITS)
                            if (Math.random() < 0.18 * commercialBondCount) { // 18% per bond (increased from 10%)
                                let materialType = Math.random() < 0.5 ? 'MAT' : 'ORE';
                                sim.spawnResource(null, nest.pos.x + (Math.random() * 50 - 25), nest.pos.y + (Math.random() * 50 - 25), materialType, false, nest.tribeId);
                                this.particles.push(new Particle(nest.pos.x, nest.pos.y, '#94a3b8', 'spark'));
                            }
                        }
                        
                        // SUSTAIN SPECIALISTS (Artisan, Scientist, Teacher)
                        let specialists = tribeMembers.filter(a => 
                            a.isSustainedByTribe && 
                            (a.role === 'Artisan' || a.role === 'Scientist' || a.role === 'Teacher')
                        );
                        
                        specialists.forEach(spec => {
                            if (spec.energy < 50 && nest.wealth > 5) {
                                spec.energy += 2;
                                nest.wealth -= 0.1; // Reduced from 0.8 to 0.1 (87% cost reduction!)
                            }
                            if (nest.wealth < 20) { // Lowered from 50 to 20
                                spec.health -= 0.5; // Starve if tribe poor
                            }
                        });
                        
                        // POPULATION-BASED WEALTH GENERATION - Fine balance
                        // Nests generate wealth based on their population (economic activity)
                        // This must be finely balanced to support nests without breaking economy
                        if (tribeMembers.length > 0) {
                            // Base generation per agent: very small (0.05 wealth per agent per cycle)
                            // This scales slowly with population - too high and it breaks economy
                            let basePerAgent = 0.05; // Very small base rate
                            
                            // Diminishing returns: more agents = less per-agent efficiency
                            // Prevents large nests from generating excessive wealth
                            let populationEfficiency = Math.min(1.0, 15 / Math.max(tribeMembers.length, 1)); // Diminishing returns after 15 agents
                            
                            // Calculate wealth generation
                            let populationWealth = tribeMembers.length * basePerAgent * populationEfficiency;
                            
                            // Bonus for productive roles (they contribute more to economy)
                            let productiveRoles = tribeMembers.filter(a => 
                                ['Merchant', 'Artisan', 'Miner', 'Farmer', 'Builder', 'Gatherer'].includes(a.role)
                            ).length;
                            let productivityBonus = productiveRoles * 0.03; // Small bonus per productive agent
                            
                            // Total wealth generation (finely balanced)
                            let totalWealthGeneration = populationWealth + productivityBonus;
                            
                            // Cap generation to prevent excessive wealth (max 5 per cycle)
                            totalWealthGeneration = Math.min(5.0, totalWealthGeneration);
                            
                            nest.wealth += totalWealthGeneration;
                        }
                        
                        // ECONOMIC BOND MUTUAL BENEFIT - Bidirectional wealth flow for both parties
                        // Commercial bonds create mutual prosperity: both parties generate wealth from the relationship
                        // Diplomatic bonds have their own humanitarian aid system (see below)
                        if (myTribe) {
                            // Find nests with commercial bonds (economic relationships only)
                            for (let otherNestId in myTribe.commercialBonds) {
                                let commBond = myTribe.commercialBonds[otherNestId] || 0;
                                
                                // Only process meaningful commercial bonds
                                if (commBond > 10) {
                                    let otherNest = this.tribes.nests.find(n => n.tribeId == otherNestId && n !== nest);
                                    if (!otherNest || otherNest.hp <= 0) continue;
                                    
                                    // MUTUAL ECONOMIC BENEFIT: Both parties generate wealth from trade
                                    // The stronger party generates more, but both benefit to keep the relationship profitable
                                    let bondStrength = Math.min(commBond / 100, 1.0); // 0.1 to 1.0
                                    
                                    // Calculate trade value based on both parties' economic activity
                                    // Base trade value increases with bond strength (INCREASED BENEFITS)
                                    let baseTradeValue = 5 + (bondStrength * 12); // 5-17 wealth per cycle (increased from 3-10)
                                    
                                    // Both parties receive trade benefits (mutual prosperity)
                                    // Wealthier party gets slightly more (better trading position), but both gain
                                    let thisWealthRatio = Math.min(nest.wealth / 500, 1.0); // Normalize to 500
                                    let otherWealthRatio = Math.min(otherNest.wealth / 500, 1.0);
                                    
                                    // Calculate benefits for each party
                                    // Minimum benefit ensures both parties stay profitable
                                    let thisBenefit = baseTradeValue * (0.6 + (thisWealthRatio * 0.4)); // 60-100% of base
                                    let otherBenefit = baseTradeValue * (0.6 + (otherWealthRatio * 0.4)); // 60-100% of base
                                    
                                    // Add wealth to both parties (mutual benefit from trade)
                                    nest.wealth += thisBenefit;
                                    otherNest.wealth += otherBenefit;
                                    
                                    // BALANCED WEALTH REDISTRIBUTION: If one party is much weaker, additional support
                                    // This prevents weaker parties from dying while still benefiting both
                                    let wealthDifference = Math.abs(nest.wealth - otherNest.wealth);
                                    let weakerNest = (nest.wealth < otherNest.wealth) ? nest : otherNest;
                                    let strongerNest = (nest.wealth < otherNest.wealth) ? otherNest : nest;
                                    
                                    // If wealth difference is large and weaker nest is struggling, provide support
                                    if (wealthDifference > 100 && weakerNest.wealth < 150) {
                                        let supportAmount = Math.min(
                                            (wealthDifference - 100) * 0.15, // 15% of excess difference
                                            strongerNest.wealth * 0.05, // Max 5% of stronger party's wealth
                                            30 // Cap at 30 to prevent abuse
                                        );
                                        
                                        // Only provide support if stronger party can afford it
                                        if (strongerNest.wealth > supportAmount * 3 && supportAmount > 2) {
                                            strongerNest.wealth -= supportAmount;
                                            weakerNest.wealth += supportAmount;
                                        }
                                    }
                                    
                                    // Occasional VFX for trade activity (not too spammy)
                                    if (Math.random() < 0.05) {
                                        this.particles.push(new Particle(
                                            (nest.pos.x + otherNest.pos.x) / 2,
                                            (nest.pos.y + otherNest.pos.y) / 2,
                                            '#10b981', 'coin'
                                        ));
                                        sfx.play('water_drop', BATTLE_TONES[Math.floor(Math.random() * BATTLE_TONES.length)], 0.008); // 80% quieter: 0.04 * 0.2 = 0.008
                                    }
                                }
                            }
                            
                            // DIPLOMATIC HUMANITARIAN AID - Allies help struggling nests
                            // Nests with diplomatic bonds receive aid from their allies
                            // But allies only help if it doesn't put their own nest/tribe at risk
                            // INCREASED: Diplomatic allies also help war winners during baby boom reconstruction
                            let isInBabyBoom = nest.babyBoom > 0;
                            let diplomaticAllies = [];
                            for (let otherNestId in myTribe.diplomaticBonds) {
                                let diploBond = myTribe.diplomaticBonds[otherNestId] || 0;
                                if (diploBond > 30) { // Strong diplomatic bond
                                    let allyNest = this.tribes.nests.find(n => n.tribeId == otherNestId && n !== nest);
                                    if (allyNest) {
                                        let allyTribe = this.tribes.tribes[otherNestId];
                                        // Check if nest needs aid:
                                        // 1. In distress (low HP or low wealth)
                                        // 2. OR in baby boom (post-war reconstruction - priority aid!)
                                        let nestHpRatio = nest.hp / nest.maxHealth;
                                        let nestWealthRatio = nest.wealth / 1000; // Normalize to 1000
                                        let isInDistress = nestHpRatio < 0.5 || nest.wealth < 300;
                                        let needsReconstructionAid = isInBabyBoom && (nestHpRatio < 0.8 || nest.wealth < nest.maxHealth * 0.6);
                                        
                                        if (isInDistress || needsReconstructionAid) {
                                            // Ally calculates cost and risk
                                            let allyHpRatio = allyNest.hp / allyNest.maxHealth;
                                            let allyWealthRatio = allyNest.wealth / 1000;
                                            let allyWarCount = 0;
                                            if (allyTribe && allyTribe.atWarWith) {
                                                for (let warId in allyTribe.atWarWith) {
                                                    if (allyTribe.atWarWith[warId] === true) allyWarCount++;
                                                }
                                            }
                                            
                                            // Ally helps ONLY if:
                                            // 1. Ally is healthy (HP > 60%) AND wealthy (wealth > 200)
                                            // 2. Ally is not in too many wars (max 2 wars)
                                            // 3. Aid cost won't drop ally below safety threshold
                                            // SPECIAL: War winners in baby boom get more lenient requirements (allies help more generously)
                                            let canHelp = (allyHpRatio > 0.6 && allyNest.wealth > 200 && allyWarCount <= 2);
                                            let canHelpReconstruction = needsReconstructionAid && (allyHpRatio > 0.5 && allyNest.wealth > 150 && allyWarCount <= 3); // More lenient for reconstruction
                                            
                                            if (canHelp || canHelpReconstruction) {
                                                // Calculate aid amount (proportional to bond strength)
                                                // INCREASED: War winners in baby boom get more aid (reconstruction priority)
                                                let bondStrength = diploBond / 100; // 0.3 to 1.0
                                                let aidMultiplier = needsReconstructionAid ? 2.0 : 1.0; // 2x aid for war winners
                                                let aidWealth = Math.min(needsReconstructionAid ? 60 : 30, allyNest.wealth * (needsReconstructionAid ? 0.15 : 0.08) * bondStrength * aidMultiplier); // More generous for reconstruction
                                                let aidHp = Math.min(needsReconstructionAid ? 30 : 15, Math.floor(allyNest.hp * (needsReconstructionAid ? 0.1 : 0.05) * bondStrength * aidMultiplier)); // More HP aid for reconstruction
                                                
                                                // Safety check: Don't give aid if it would drop ally below safety threshold
                                                let allyWealthAfterAid = allyNest.wealth - aidWealth;
                                                let allyHpAfterAid = allyNest.hp - aidHp;
                                                
                                                if (allyWealthAfterAid >= 150 && allyHpAfterAid >= allyNest.maxHealth * 0.5) {
                                                    // Provide humanitarian aid
                                                    nest.wealth += aidWealth;
                                                    nest.hp = Math.min(nest.maxHealth, nest.hp + aidHp);
                                                    allyNest.wealth -= aidWealth;
                                                    allyNest.hp = Math.max(200, allyNest.hp - aidHp);
                                                    
                                                    // VFX for aid transfer
                                                    if (Math.random() < 0.3) {
                                                        this.particles.push(new Particle(nest.pos.x, nest.pos.y, '#3b82f6', 'spark')); // Blue for aid
                                                        this.particles.push(new Particle(allyNest.pos.x, allyNest.pos.y, '#60a5fa', 'star')); // Light blue for giver
                                                        sfx.play('water_drop', BATTLE_TONES[Math.floor(Math.random() * BATTLE_TONES.length)], 0.02); // 80% quieter: 0.1 * 0.2 = 0.02
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            
                            // EMERGENCY BORROWING - Only if very poor (using diplomatic/commercial bonds)
                            // This is a last resort when nest is extremely poor and existing systems haven't helped enough
                            if (nest.wealth < 50 && myTribe) {
                                // Find allies with strong bonds (diplomatic or commercial) who can afford to help
                                for (let otherNestId in myTribe.diplomaticBonds) {
                                    let diploBond = myTribe.diplomaticBonds[otherNestId] || 0;
                                    let commBond = myTribe.commercialBonds[otherNestId] || 0;
                                    let bondStrength = Math.max(diploBond, commBond);
                                    
                                    if (bondStrength > 30) { // Strong bond
                                        let allyNest = this.tribes.nests.find(n => n.tribeId == otherNestId && n !== nest && n.hp > 0);
                                        if (allyNest && allyNest.wealth > 400) {
                                        // Emergency loan
                                            let loanAmount = Math.min(80, allyNest.wealth * 0.08);
                                            allyNest.wealth -= loanAmount;
                                        nest.wealth += loanAmount;
                                        
                                        // VFX
                                            if (Math.random() < 0.5) {
                                        this.particles.push(new Particle(nest.pos.x, nest.pos.y, '#22c55e', 'spark'));
                                        sfx.play('water_drop', 500, 0.1);
                                            }
                                        
                                        // Strengthen bonds slightly
                                            if (diploBond > commBond) {
                                                myTribe.diplomaticBonds[otherNestId] = Math.min(100, diploBond + 0.5);
                                            } else {
                                                myTribe.commercialBonds[otherNestId] = Math.min(100, commBond + 0.5);
                                            }
                                        
                                        break; // Only one loan per cycle
                                        }
                                    }
                                }
                            }
                        }
                        
                        // NEST DEATH - If not profitable and can't sustain itself
                        if (nest.wealth < 10 && nest.hp < 200) {
                            // Check if nest has been unprofitable for long
                            if (!nest.unprofitableFrames) nest.unprofitableFrames = 0;
                            nest.unprofitableFrames++;
                            
                            if (nest.unprofitableFrames > 500) { // 500 frames of being unprofitable
                                // Nest collapses and dies
                                console.log(`Nest of tribe ${nest.tribeId} collapsed due to lack of resources!`);
                                
                                // Calculate total nest value: wealth + structural health (HP) + energy from agents + resources
                                let totalWealth = nest.wealth;
                                let structuralHealth = nest.maxHealth; // Structural health represented as treasure
                                let totalEnergy = 0;
                                let totalResources = [];
                                
                                // Collect energy and resources from all tribe members
                                let losingTribeMembers = this.agents.filter(a => a.tribeId === nest.tribeId && !a.dead);
                                losingTribeMembers.forEach(agent => {
                                    // Collect energy (convert to wealth/resources)
                                    if (agent.energy > 50) {
                                        totalEnergy += agent.energy * 0.3; // 30% of agent energy
                                    }
                                    // Collect resources they're carrying
                                    if (agent.carrying && agent.carrying.active) {
                                        totalResources.push(agent.carrying.type);
                                        agent.carrying.active = false;
                                        agent.carrying = null;
                                    }
                                });
                                
                                // Convert energy to wealth
                                totalWealth += totalEnergy * 0.5; // 50% efficiency
                                
                                // Nest's structural health becomes treasure (represents accumulated infrastructure)
                                let treasureFromStructure = Math.floor(structuralHealth / 10); // 1 treasure per 10 HP
                                
                                // Find all nests at war with this nest
                                let warringNests = [];
                                if (typeof this.tribes !== 'undefined' && this.tribes.tribes) {
                                    let deadTribe = this.tribes.tribes[nest.tribeId];
                                    if (deadTribe && deadTribe.atWarWith) {
                                        for (let otherId in deadTribe.atWarWith) {
                                            if (deadTribe.atWarWith[otherId] === true) {
                                                // Find nests of this enemy tribe
                                                let enemyNests = this.tribes.nests.filter(n => n.tribeId == otherId && n !== nest && n.hp > 0);
                                                warringNests.push(...enemyNests);
                                            }
                                        }
                                    }
                                    
                                    // Also check reverse - nests that are at war with this nest
                                    for (let tid in this.tribes.tribes) {
                                        let otherTribe = this.tribes.tribes[tid];
                                        if (otherTribe && otherTribe.atWarWith && otherTribe.atWarWith[nest.tribeId] === true) {
                                            let enemyNests = this.tribes.nests.filter(n => n.tribeId == tid && n !== nest && n.hp > 0);
                                            warringNests.push(...enemyNests);
                                        }
                                    }
                                }
                                
                                // DISTRIBUTE ALL VALUE TO WAR WINNERS OR SCATTER IF NO WINNERS
                                if (warringNests.length > 0) {
                                    // DISTRIBUTE TO WAR WINNERS
                                    let wealthPerNest = totalWealth > 0 ? Math.floor(totalWealth / warringNests.length) : 0;
                                    let treasurePerNest = Math.floor(treasureFromStructure / warringNests.length);
                                    let resourcesPerNest = Math.floor(totalResources.length / warringNests.length);
                                    let hpPerNest = Math.max(0, nest.hp - 200) > 0 ? Math.floor((nest.hp - 200) / warringNests.length) : 0;
                                    
                                    // CONVERT ALL LOSING TRIBE MEMBERS TO WINNERS - Divide citizens among winning nests
                                    let losingTribeMembers = tribeMembers; // Already filtered to this tribe
                                    let membersPerNest = Math.floor(losingTribeMembers.length / warringNests.length);
                                    let memberIndex = 0;
                                    
                                    warringNests.forEach((winnerNest, nestIndex) => {
                                        // POST-WAR RECONSTRUCTION: Double the winner's wealth immediately
                                        winnerNest.wealth = winnerNest.wealth * 2;
                                        
                                        // Add spoils from defeated nest (wealth, energy converted to wealth, structural treasure)
                                        if (wealthPerNest > 0) {
                                            winnerNest.wealth += wealthPerNest;
                                        }
                                        if (hpPerNest > 0) {
                                            winnerNest.hp = Math.min(winnerNest.maxHealth, winnerNest.hp + hpPerNest);
                                        }
                                        
                                        // Distribute structural treasure (represents infrastructure value)
                                        for (let i = 0; i < treasurePerNest; i++) {
                                            let angle = Math.random() * Math.PI * 2;
                                            let dist = 20 + Math.random() * 30;
                                            this.spawnResource(null,
                                                winnerNest.pos.x + Math.cos(angle) * dist,
                                                winnerNest.pos.y + Math.sin(angle) * dist,
                                                'TREASURE', false, winnerNest.tribeId
                                            );
                                        }
                                        
                                        // Distribute resources from defeated nest
                                        let resourceStart = nestIndex * resourcesPerNest;
                                        let resourceEnd = (nestIndex === warringNests.length - 1) ? totalResources.length : resourceStart + resourcesPerNest;
                                        for (let i = resourceStart; i < resourceEnd; i++) {
                                            if (totalResources[i]) {
                                                let angle = Math.random() * Math.PI * 2;
                                                let dist = 20 + Math.random() * 30;
                                                this.spawnResource(null,
                                                    winnerNest.pos.x + Math.cos(angle) * dist,
                                                    winnerNest.pos.y + Math.sin(angle) * dist,
                                                    totalResources[i], false, winnerNest.tribeId
                                                );
                                            }
                                        }
                                        
                                        // CONVERT LOSING TRIBE MEMBERS TO WINNER'S TRIBE
                                        // Assign citizens to this winning nest (divide equally)
                                        let membersToConvert = (nestIndex === warringNests.length - 1) 
                                            ? losingTribeMembers.slice(memberIndex) // Last nest gets remaining members
                                            : losingTribeMembers.slice(memberIndex, memberIndex + membersPerNest);
                                        
                                        membersToConvert.forEach(member => {
                                            let oldTribeId = member.tribeId;
                                            member.tribeId = winnerNest.tribeId;
                                            member.nest = winnerNest;
                                            
                                            // Update loyalty to new tribe
                                            member.loyalty[winnerNest.tribeId] = 50; // Initial loyalty
                                            member.loyalty[oldTribeId] = (member.loyalty[oldTribeId] || 0) * 0.5; // Reduce old loyalty
                                            
                                            // VFX for conversion
                                            this.particles.push(new Particle(member.pos.x, member.pos.y, '#10b981', 'spark'));
                                        });
                                        
                                        memberIndex += membersPerNest;
                                        
                                        // START RECONSTRUCTION FESTIVAL - 20x spawning for 100 frames
                                        winnerNest.reconstructionFestival = 100;
                                        
                                        // Massive celebration VFX
                                        for (let i = 0; i < 10; i++) {
                                            let angle = (i / 10) * Math.PI * 2;
                                            let dist = 30 + Math.random() * 20;
                                            this.particles.push(new Particle(
                                                winnerNest.pos.x + Math.cos(angle) * dist,
                                                winnerNest.pos.y + Math.sin(angle) * dist,
                                                '#fbbf24', 'star'
                                            ));
                                        }
                                        this.particles.push(new Particle(winnerNest.pos.x, winnerNest.pos.y, '#10b981', 'explosion')); // Green for victory
                                    });
                                    
                                    console.log(`Nest of tribe ${nest.tribeId} destroyed! ${losingTribeMembers.length} citizens converted to ${warringNests.length} winning tribes. Post-war reconstruction: doubled wealth + spoils + 750-frame baby boom!`);
                                } else {
                                    // NO WAR WINNERS - SCATTER ALL VALUE WIDELY AROUND NEST IN RANDOM FORMS
                                    // Scatter wealth, energy, resources, and structural treasure as random resources
                                    let totalValue = totalWealth + (totalEnergy * 0.5) + (structuralHealth / 2);
                                    let scatterCount = Math.min(50, Math.floor(totalValue / 20)); // Scatter up to 50 resources
                                    
                                    let resourceTypes = ['FOOD', 'MAT', 'ORE', 'TREASURE', 'HERB', 'STIM', 'RELIC', 'UNIQUE'];
                                    
                                    for (let i = 0; i < scatterCount; i++) {
                                        let angle = Math.random() * Math.PI * 2;
                                        let dist = 50 + Math.random() * 150; // Wide scatter (50-200 pixels from nest)
                                        let resourceType = resourceTypes[Math.floor(Math.random() * resourceTypes.length)];
                                        
                                        // Weighted random - more valuable resources are rarer
                                        let rand = Math.random();
                                        if (rand < 0.4) resourceType = 'FOOD'; // 40% food
                                        else if (rand < 0.6) resourceType = 'MAT'; // 20% materials
                                        else if (rand < 0.75) resourceType = 'ORE'; // 15% ore
                                        else if (rand < 0.85) resourceType = 'HERB'; // 10% herbs
                                        else if (rand < 0.92) resourceType = 'STIM'; // 7% stims
                                        else if (rand < 0.97) resourceType = 'TREASURE'; // 5% treasure
                                        else if (rand < 0.99) resourceType = 'RELIC'; // 2% relics
                                        else resourceType = 'UNIQUE'; // 1% unique
                                        
                                        this.spawnResource(null,
                                            nest.pos.x + Math.cos(angle) * dist,
                                            nest.pos.y + Math.sin(angle) * dist,
                                            resourceType, false, -1 // Unaffiliated resources
                                        );
                                    }
                                    
                                    // Also scatter remaining resources from agents
                                    totalResources.forEach(resourceType => {
                                        let angle = Math.random() * Math.PI * 2;
                                        let dist = 50 + Math.random() * 150;
                                        this.spawnResource(null,
                                            nest.pos.x + Math.cos(angle) * dist,
                                            nest.pos.y + Math.sin(angle) * dist,
                                            resourceType, false, -1
                                        );
                                    });
                                    
                                    console.log(`Nest of tribe ${nest.tribeId} destroyed! No war winners - ${scatterCount} resources scattered widely around nest location.`);
                                }
                                
                                // Trigger aggressive cleanup after nest death
                                this._cleanupAfterLargeDieOff();
                                
                                // Remove nest
                                let nestIndex = this.tribes.nests.indexOf(nest);
                                if (nestIndex > -1) {
                                    this.tribes.nests.splice(nestIndex, 1);
                                }
                                
                                // Members already converted above, so no need to kill/disperse them
                                
                                // VFX & SFX
                                this.particles.push(new Particle(nest.pos.x, nest.pos.y, '#dc2626', 'explosion'));
                                this.particles.push(new Particle(nest.pos.x, nest.pos.y, '#9ca3af', 'smoke'));
                                sfx.play('death', HARMONICS.E4, 0.2); // Harmonic death tone
                                
                                return; // Skip rest of update for this nest
                            }
                        } else {
                            // Reset counter if profitable again
                            nest.unprofitableFrames = 0;
                        }
                        
                        // TRIBE PROFITS FROM MEMBER ACTIVITY
                        // TRIBES TAX POPULATIONS ON ALL FORMS OF VALUE AND CONVERT TO WHAT TRIBE NEEDS
                        // Regular taxation: energy, wealth, and resources
                        let needsWealth = nest.wealth < nest.maxHealth * 0.3; // Need wealth if below 30% of max health
                        let needsHp = nest.hp < nest.maxHealth * 0.5; // Need HP if below 50%
                        let needsResources = nest.wealth < 100; // Need resources if very poor
                        
                        tribeMembers.forEach(member => {
                            // TAX WEALTH - Direct wealth transfer
                            if (member.wealth > 10 && Math.random() < 0.05) {
                                let contribution = member.wealth * CONFIG.tribalTaxRate; // Use config tax rate
                                member.wealth -= contribution;
                                
                                if (needsHp && nest.hp < nest.maxHealth) {
                                    // Convert wealth to HP (tribe needs health)
                                    let hpGain = contribution * 0.1; // 10% efficiency
                                    nest.hp = Math.min(nest.maxHealth, nest.hp + hpGain);
                                    nest.health = Math.min(nest.maxHealth, nest.hp);
                                } else {
                                    // Add wealth directly
                                nest.wealth += contribution;
                                }
                            }
                            
                            // TAX ENERGY - Convert to what tribe needs
                            if (member.energy > 50 && Math.random() < 0.03) {
                                let energyTax = member.energy * CONFIG.tribalTaxRate * 0.5; // 50% of tax rate for energy
                                member.energy -= energyTax;
                                
                                if (needsHp && nest.hp < nest.maxHealth) {
                                    // Convert energy to HP (tribe needs health)
                                    let hpGain = energyTax * 0.1; // 10% efficiency
                                    nest.hp = Math.min(nest.maxHealth, nest.hp + hpGain);
                                    nest.health = Math.min(nest.maxHealth, nest.hp);
                                } else {
                                    // Convert energy to wealth (tribe needs money)
                                    let wealthGain = energyTax * 0.5; // 50% efficiency
                                    nest.wealth += wealthGain;
                                }
                            }
                            
                            // TAX RESOURCES - Extract from agents carrying resources
                            if (member.carrying && member.carrying.active && Math.random() < 0.02) {
                                let resourceType = member.carrying.type;
                                let resourceValue = weightedResourceEnergy(resourceType) || 30;
                                
                                // Convert resource to what tribe needs
                                if (needsHp && (resourceType === 'HERB' || resourceType === 'STIM')) {
                                    // Herbs/Stims can heal nest
                                    let hpGain = resourceValue * 0.2;
                                    nest.hp = Math.min(nest.maxHealth, nest.hp + hpGain);
                                    nest.health = Math.min(nest.maxHealth, nest.hp);
                                    // Remove resource after taxing
                                    member.carrying.active = false;
                                    member.carrying = null;
                                } else {
                                    // Convert resource value to wealth
                                    let resourceTax = resourceValue * CONFIG.tribalTaxRate * 0.3; // 30% of resource value
                                    nest.wealth += resourceTax;
                                    // Optionally remove resource (or let agent keep it)
                                    if (Math.random() < 0.3) { // 30% chance to confiscate
                                        member.carrying.active = false;
                                        member.carrying = null;
                                    }
                                }
                            }
                        });
                    });
                }
                
                // WAR DECLARATION & MANAGEMENT
                if (this.frame % 200 === 0) { // Check every 200 frames
                    for (let tid1 in this.tribes.tribes) {
                        for (let tid2 in this.tribes.tribes) {
                            if (tid1 >= tid2) continue; // Check each pair once
                            
                            let relation = this.tribes.getOpinion(tid1, tid2);
                            let atWar = this.tribes.isAtWar(tid1, tid2);
                            
                            // AUTO-DECLARE WAR if relations drop below threshold
                            if (!atWar && relation < CONFIG.warDeclarationThreshold) {
                                this.tribes.declareWar(tid1, tid2);
                                
                                // SOLDIERS UNBOND IF ALLIANCE BREAKS
                                // Break soldier bonds between now-enemy tribes
                                this.agents.forEach(agent => {
                                    if (agent.dead || agent.role !== 'Soldier') return;
                                    if (agent.tribeId != tid1 && agent.tribeId != tid2) return;
                                    
                                    // Check all partners
                                    agent.partners = agent.partners.filter(partner => {
                                        if (partner.role !== 'Soldier') return true; // Keep non-soldier bonds
                                        
                                        // Break soldier-soldier bonds between enemy tribes
                                        let sameTribes = (agent.tribeId == tid1 && partner.tribeId == tid2) ||
                                                        (agent.tribeId == tid2 && partner.tribeId == tid1);
                                        if (sameTribes) {
                                            // Remove partner's reference too
                                            partner.partners = partner.partners.filter(p => p !== agent);
                                            return false; // Break bond
                                        }
                                        return true; // Keep bond
                                    });
                                });
                                
                                // VFX at both nests
                                let nest1 = this.tribes.nests.find(n => n.tribeId == tid1);
                                let nest2 = this.tribes.nests.find(n => n.tribeId == tid2);
                                if (nest1 && nest2) {
                                    this.particles.push(new Particle(nest1.pos.x, nest1.pos.y, '#dc2626', 'lightning'));
                                    this.particles.push(new Particle(nest2.pos.x, nest2.pos.y, '#dc2626', 'lightning'));
                                    sfx.play('attack', 250, 0.2);
                                }
                            }
                            
                            // Check for surrender or peace
                            if (atWar) {
                                let tribe1 = this.tribes.tribes[tid1];
                                let tribe2 = this.tribes.tribes[tid2];
                                let exhaustion1 = tribe1.warExhaustion[tid2] || 0;
                                let exhaustion2 = tribe2.warExhaustion[tid2] || 0;
                                
                                // SURRENDER if exhaustion too high
                                if (exhaustion1 > tribe1.surrenderThreshold) {
                                    this.tribes.endWar(tid1, tid2, false); // Surrender, no treaty
                                    // PERFORMANCE: Cleanup after war ends
                                    this._cleanupAfterWar();
                                    // Loser pays reparations
                                    let nest1 = this.tribes.nests.find(n => n.tribeId == tid1);
                                    let nest2 = this.tribes.nests.find(n => n.tribeId == tid2);
                                    if (nest1 && nest2 && nest1.wealth > 100) {
                                        let reparations = nest1.wealth * 0.3;
                                        nest1.wealth -= reparations;
                                        nest2.wealth += reparations;
                                    }
                                } else if (exhaustion2 > tribe2.surrenderThreshold) {
                                    this.tribes.endWar(tid1, tid2, false);
                                    // PERFORMANCE: Cleanup after war ends
                                    this._cleanupAfterWar();
                                    let nest1 = this.tribes.nests.find(n => n.tribeId == tid1);
                                    let nest2 = this.tribes.nests.find(n => n.tribeId == tid2);
                                    if (nest1 && nest2 && nest2.wealth > 100) {
                                        let reparations = nest2.wealth * 0.3;
                                        nest2.wealth -= reparations;
                                        nest1.wealth += reparations;
                                    }
                                }
                            }
                        }
                    }
                }
                
                // BOND UPDATES & REINFORCEMENT
                if (this.frame % 50 === 0) { // Check bonds frequently (every 50 frames)
                    for (let tid in this.tribes.tribes) {
                        this.tribes.updateBonds(tid);
                    }
                }
                
                // DIPLOMATIC RELATION DECAY (very slow)
                if (this.frame % 100 === 0) {
                    for (let tid1 in this.tribes.tribes) {
                        for (let tid2 in this.tribes.tribes) {
                            if (tid1 !== tid2) {
                                let currentRelation = this.tribes.getOpinion(tid1, tid2);
                                // Decay toward neutral (0) very slowly
                                if (currentRelation > 0) {
                                    this.tribes.updateOpinion(tid1, tid2, -0.1);
                                } else if (currentRelation < 0) {
                                    this.tribes.updateOpinion(tid1, tid2, 0.1);
                                }
                            }
                        }
                    }
                }
                
                // DIPLOMATIC AFFINITY BONUS
                // Agents from diplomatically linked tribes (relation > 30) have increased personal affinity
                if (this.frame % 50 === 0) {
                    for (let a of this.agents) {
                        if (a.tribeId === -1) continue;
                        for (let other of this.agents) {
                            if (other.tribeId === -1 || other.tribeId === a.tribeId || other === a) continue;
                            
                            let tribalRelation = this.tribes.getOpinion(a.tribeId, other.tribeId);
                            // If tribes have positive diplomatic relations, boost personal affinity
                            if (tribalRelation > 30) {
                                let boost = Math.min(0.5, tribalRelation / 200); // Max 0.5 boost
                                a.adjustLoyalty(other.id, boost);
                            }
                        }
                    }
                }

                // NEST SPLITTING (when too populous OR too large)
                if (this.frame % 200 === 0) {
                    this.tribes.nests.forEach(n => {
                        let tribeMembers = this.agents.filter(a => a.tribeId === n.tribeId && a.isAdult());
                        let radius = Math.sqrt(n.hp / Math.PI);
                        let isTooLarge = radius > (CONFIG.nestSplitMaxRadius || 150);
                        let isTooPopulous = tribeMembers.length > CONFIG.nestSplitPopulation;
                        if (isTooPopulous || isTooLarge) {
                            // Create new allied nest nearby
                            let angle = Math.random() * Math.PI * 2;
                            let dist = 200 + Math.random() * 100; // 200-300 pixels away
                            let newX = n.pos.x + Math.cos(angle) * dist;
                            let newY = n.pos.y + Math.sin(angle) * dist;
                            
                            // Find valid position
                            let pos = this.tribes.findValidNestPosition(newX, newY, 150);
                            
                            // Create new tribe (same parent tribe, but new ID)
                            let newTribeId = this.tribes.createTribe(`${this.tribes.tribes[n.tribeId].name} Colony`, this.tribes.tribes[n.tribeId].color);
                            
                            // 20% chance the new tribe becomes an enemy instead of an ally
                            let becomesEnemy = Math.random() < 0.2;
                            if (becomesEnemy) {
                                // Set hostile relations - declare war
                                this.tribes.updateOpinion(n.tribeId, newTribeId, -60);
                                this.tribes.updateOpinion(newTribeId, n.tribeId, -60);
                                // Declare war between the tribes
                                this.tribes.tribes[n.tribeId].atWarWith[newTribeId] = true;
                                this.tribes.tribes[newTribeId].atWarWith[n.tribeId] = true;
                                sfx.play('attack', 350, 0.2);
                            } else {
                            // Set strong alliance between parent and colony
                            this.tribes.updateOpinion(n.tribeId, newTribeId, 80);
                            this.tribes.updateOpinion(newTribeId, n.tribeId, 80);
                            }
                            
                            // Create new nest
                            let newNest = new Nest(pos.x, pos.y, newTribeId);
                            this.tribes.nests.push(newNest);
                            
                            // NEST BIRTH SOUND - Play birth-like tone when nest is created
                            if (typeof sfx !== 'undefined' && sfx.enabled) {
                                sfx.play('birth', getHarmonicFreq([HARMONICS.C5, HARMONICS.E5, HARMONICS.G5, HARMONICS.A5], 10), 0.1); // Harmonic birth tone
                            }
                            
                            // Transfer wealth using CONFIG split ratio (parent keeps more, child gets less)
                            let childRatio = CONFIG.nestSplitChildReceive;
                            let parentRatio = CONFIG.nestSplitParentRetain;
                            newNest.wealth = Math.floor(n.wealth * childRatio);
                            n.wealth = Math.floor(n.wealth * parentRatio);
                            
                            // Reassign members to new nest using child ratio (those closest to it)
                            tribeMembers.sort((a, b) => {
                                let dA = Vector.dist(a.pos, newNest.pos);
                                let dB = Vector.dist(b.pos, newNest.pos);
                                return dA - dB;
                            });
                            
                            let splitCount = Math.floor(tribeMembers.length * childRatio);
                            for (let i = 0; i < splitCount; i++) {
                                tribeMembers[i].tribeId = newTribeId;
                                tribeMembers[i].color = this.tribes.tribes[newTribeId].color;
                            }
                            
                            this.particles.push(new Particle(pos.x, pos.y, this.tribes.tribes[newTribeId].color, 'spark'));
                            sfx.play('split', 380, 0.25);
                        }
                    });
                }
                
                // NEST MERGING (when adjacent)
                if (this.frame % 250 === 0 && this.tribes.nests.length > 1) {
                    let nestsToRemove = [];
                    
                    for (let i = 0; i < this.tribes.nests.length; i++) {
                        for (let j = i + 1; j < this.tribes.nests.length; j++) {
                            let n1 = this.tribes.nests[i];
                            let n2 = this.tribes.nests[j];
                            
                            if (nestsToRemove.includes(n1) || nestsToRemove.includes(n2)) continue;
                            
                            let distance = Vector.dist(n1.pos, n2.pos);
                            
                            // If nests are adjacent and have positive relations
                            if (distance < CONFIG.nestMergeDistance) {
                                let relation = this.tribes.getOpinion(n1.tribeId, n2.tribeId);
                                
                                // Only merge if they like each other
                                if (relation > 30) {
                                    // Determine larger and smaller nest by population
                                    let n1Members = this.agents.filter(a => a.tribeId === n1.tribeId);
                                    let n2Members = this.agents.filter(a => a.tribeId === n2.tribeId);
                                    
                                    let larger, smaller, largerMembers, smallerMembers;
                                    if (n1Members.length >= n2Members.length) {
                                        larger = n1; smaller = n2;
                                        largerMembers = n1Members; smallerMembers = n2Members;
                                    } else {
                                        larger = n2; smaller = n1;
                                        largerMembers = n2Members; smallerMembers = n1Members;
                                    }
                                    
                                    // Merge: Smaller absorbed into larger
                                    // 1. Combine wealth
                                    larger.wealth += smaller.wealth;
                                    
                                    // 2. Transfer all members to larger tribe
                                    smallerMembers.forEach(a => {
                                        a.tribeId = larger.tribeId;
                                        a.color = this.tribes.tribes[larger.tribeId].color;
                                    });
                                    
                                    // 3. MASS MATING EVENT - genetic mixing with mutations
                                    let adultLarger = largerMembers.filter(a => a.isAdult());
                                    let adultSmaller = smallerMembers.filter(a => a.isAdult());
                                    
                                    // Pair up random members from each tribe for genetic exchange
                                    let pairingCount = Math.min(adultLarger.length, adultSmaller.length, 10); // Max 10 new babies
                                    for (let k = 0; k < pairingCount; k++) {
                                        let parent1 = adultLarger[Math.floor(Math.random() * adultLarger.length)];
                                        let parent2 = adultSmaller[Math.floor(Math.random() * adultSmaller.length)];
                                        
                                        if (parent1.energy > 60 && parent2.energy > 60) {
                                            // Create child at merge point
                                            let mergePoint = Vector.sub(larger.pos, smaller.pos).mult(0.5).add(smaller.pos);
                                            let child = new Agent(mergePoint.x, mergePoint.y, null, [parent1, parent2], larger.tribeId);
                                            this.agents.push(child);
                                            
                                            // Energy cost
                                            parent1.energy -= 20;
                                            parent2.energy -= 20;
                                            
                                            // Update loyalty
                                            parent1.adjustLoyalty(parent2.id, 30);
                                            parent2.adjustLoyalty(parent1.id, 30);
                                        }
                                    }
                                    
                                    // 4. Everyone mutates during merge
                                    [...largerMembers, ...smallerMembers].forEach(a => {
                                        // Small mutation to each gene
                                        for (let gene in a.dna) {
                                            if (typeof a.dna[gene] === 'number') {
                                                let mutation = (Math.random() - 0.5) * 0.2; // ¬±10%
                                                a.dna[gene] = Math.max(0, Math.min(1, a.dna[gene] + mutation));
                                            }
                                        }
                                    });
                                    
                                    // 5. Remove smaller nest and tribe
                                    nestsToRemove.push(smaller);
                                    
                                    // Visual feedback
                                    this.particles.push(new Particle(larger.pos.x, larger.pos.y, '#ffffff', 'heart'));
                                    this.particles.push(new Particle(smaller.pos.x, smaller.pos.y, '#ffffff', 'heart'));
                                    sfx.play('merge', 300, 0.4);
                                    
                                    // Break out of inner loop
                                    break;
                                }
                            }
                        }
                    }
                    
                    // Remove merged nests
                    this.tribes.nests = this.tribes.nests.filter(n => !nestsToRemove.includes(n));
                }
                
                // GARDENS: Spawn food and unique resources near nests
                if (this.frame % 50 === 0) {
                    this.tribes.nests.forEach(n => {
                        // Festivals (High Wealth)
                        if (n.wealth > 500 && Math.random() < 0.01) {
                            n.wealth -= 100;
                            sim.particles.push(new Particle(n.pos.x, n.pos.y, '#ffffff', 'heart')); // Burst
                            sim.agents.filter(a => a.tribeId === n.tribeId).forEach(a => {
                                a.energy = Math.min(a.energy + 50, a.maxEnergy);
                                a.health = Math.min(a.health + 20, a.maxHealth);
                            });
                        }

                        // Regular food
                        if (Math.random() < 0.3) {
                            let angle = Math.random() * Math.PI * 2;
                            let dist = 30 + Math.random() * 40;
                            sim.spawnResource(null, n.pos.x + Math.cos(angle)*dist, n.pos.y + Math.sin(angle)*dist, 'FOOD', false, n.tribeId);
                        }
                        
                        // Unique resource for this nest (amplifies specific gene)
                        if (Math.random() < 0.15) {
                            let angle = Math.random() * Math.PI * 2;
                            let dist = 25 + Math.random() * 35;
                            let res = {
                                pos: new Vector(n.pos.x + Math.cos(angle)*dist, n.pos.y + Math.sin(angle)*dist),
                                type: 'UNIQUE',
                                config: { color: n.resourceColor, val: 30, type: 'unique', radius: 5 },
                                radius: 5,
                                carrier: null,
                                active: true,
                                nestId: n.tribeId,
                                creatorTribe: n.tribeId,
                                decayTimer: CONFIG.resourceDecayTimers.UNIQUE || CONFIG.matDecay,
                                geneBoost: n.uniqueGene // Which gene this amplifies
                            };
                            this.resources.push(res);
                        }
                    });
                }
                
                // Leader Succession Logic
                if (this.frame % 100 === 0) {
                    this.tribes.updateRoles(this.agents);
                    for(let tid in this.tribes.tribes) {
                        let members = this.agents.filter(a => a.tribeId == tid);
                        let currentLeader = members.find(a => a.id === this.tribes.tribes[tid].leaderId);
                        
                        if (!currentLeader && members.length > 0) {
                             // Promote wealthiest
                             members.sort((a, b) => b.wealth - a.wealth);
                             this.tribes.tribes[tid].leaderId = members[0].id;
                             members[0].health = 2000; // Buff new leader
                             members[0].maxHealth = 2000;
                        }
                    }
                }

                for (let i = this.resources.length - 1; i >= 0; i--) {
                    let r = this.resources[i];
                    if (r.decayTimer !== undefined && r.decayTimer !== null) {
                        r.decayTimer--;
                        if (r.decayTimer <= 0) {
                            r.active = false;
                            continue;
                        }
                    }
                    if (r.type === 'SEED') {
                        r.age++;
                        if (r.age > CONFIG.seedGrowthTime) {
                            r.type = 'FOOD';
                            r.config = RES_TYPES.FOOD;
                            r.decayTimer = (CONFIG.resourceDecayTimers && CONFIG.resourceDecayTimers.FOOD) || CONFIG.matDecay;
                        }
                    }
                }

                // Track agent count before filtering to detect large die-offs
                let agentsBeforeFilter = this.agents.length;
                this.agents = this.agents.filter(a => {
                    if (a.dead) {
                        let drops = Math.floor(a.radius / 5);
                        if(a.role === 'Monster') drops = 30; 
                        for(let i=0; i<drops; i++) {
                        let r = new Resource(a.pos.x + (Math.random()*40-20), a.pos.y + (Math.random()*40-20), 'FOOD', false, a.tribeId);
                            this.resources.push(r);
                        }
                        // Skulls
                        sim.particles.push(new Particle(a.pos.x, a.pos.y, '#fff', 'skull'));
                        return false;
                    }
                    return true;
                });
                let agentsAfterFilter = this.agents.length;
                
                // Aggressive cleanup after large die-off detected here (more than 30% of agents died)
                if (agentsBeforeFilter > 0 && (agentsBeforeFilter - agentsAfterFilter) > agentsBeforeFilter * 0.3) {
                    console.log(`Large die-off detected in filter: ${agentsBeforeFilter} -> ${agentsAfterFilter} (${Math.round((agentsBeforeFilter - agentsAfterFilter) / agentsBeforeFilter * 100)}% died), triggering cleanup`);
                    this._cleanupAfterLargeDieOff();
                }
                // FOOD DECAY SYSTEM - food dies if not eaten or fertilized
                this.resources.forEach(r => {
                    if ((r.type === 'FOOD' || r.type === 'SEED') && r.life !== Infinity) {
                        r.life -= CONFIG.foodDecayRate;
                        if (r.life <= 0) r.active = false; // Food dies
                    }
                    // Decay MAT resources over time
                    if (r.type === 'MAT' && !r.carrier) {
                        r.decayTimer--;
                        if (r.decayTimer <= 0) r.active = false;
                    }
                });
                
                // Clean up resources - also cap if too many
                this.resources = this.resources.filter(r => r.active);
                if (this.resources.length > CONFIG.maxRes * 1.5) {
                    // If resources exceed max by 50%, remove oldest inactive ones
                    // Sort by some property or just keep the most recent
                    this.resources = this.resources.slice(-CONFIG.maxRes);
                }
                // Particles already cleaned up above - don't duplicate
                
                // Update projectiles
                this.projectiles.forEach(p => p.update(this.agents, this.tribes.nests));
                this.projectiles = this.projectiles.filter(p => p.active);

                // Periodic aggressive cleanup every 1000 frames to prevent memory accumulation
                if (this.frame % 1000 === 0) {
                    // Force cleanup of any lingering dead references
                    this.agents = this.agents.filter(a => !a.dead);
                    this.resources = this.resources.filter(r => r.active);
                    this.particles = this.particles.filter(p => p.life > 0);
                    this.projectiles = this.projectiles.filter(p => p.active && p.life > 0);
                    this.plagues = this.plagues.filter(p => p.life > 0);
                    
                    // Cap arrays if they're still too large
                    if (this.particles.length > 300) this.particles = this.particles.slice(-300);
                    if (this.projectiles.length > 100) this.projectiles = this.projectiles.slice(-100);
                    if (this.plagues.length > 20) this.plagues = this.plagues.slice(-20);
                    if (this.resources.length > CONFIG.maxRes * 1.5) {
                        this.resources = this.resources.slice(-CONFIG.maxRes);
                    }
                }

                if (this.frame % 3000 === 0) { // Reduced Frequency
                    // Disasters
                    if (Math.random() < 0.5) { // Reduced Chance
                        let disaster = Math.random();
                        if (disaster < 0.3) {
                            // Drought
                            this.resources = this.resources.filter(r => r.type !== 'FOOD');
                            this.setStatusMessage(`üåµ CATACLYSM: Drought - all food resources removed`, 300);
                        } else if (disaster < 0.6) {
                            // Boom
                            for(let i=0; i<20; i++) this.spawnResource(null, null, null, 'TREASURE');
                            this.setStatusMessage(`üí∞ CATACLYSM: Treasure boom - resources scattered`, 300);
                        } else {
                            // Pestilence
                            let plagueX = Math.random()*this.width;
                            let plagueY = Math.random()*this.height;
                            this.plagues.push(new Plague(plagueX, plagueY));
                            this.setStatusMessage(`üåã CATACLYSM: Plague unleashed at (${Math.floor(plagueX)}, ${Math.floor(plagueY)})`, 300);
                        }
                    }

                    for(let tid in this.tribes.tribes) {
                        let members = this.agents.filter(a => a.tribeId == tid);
                        if(members.length > CONFIG.unrestThreshold) {
                            let chance = Math.pow(members.length / CONFIG.unrestThreshold, 2) * 0.1;
                            if (Math.random() < chance) {
                                this.tribes.fractureTribe(parseInt(tid), members);
                            }
                        }
                    }
                }

                this.ctx.fillStyle = '#111827';
                this.ctx.fillRect(0, 0, this.width, this.height);
                
                // DRAW DIPLOMATIC, COMMERCIAL, AND WAR BONDS BETWEEN NESTS
                // CRITICAL: Always draw bonds every frame - they don't change often and flickering is jarring
                const ctx = this.ctx;
                for(let tid in this.tribes.tribes) {
                     for(let otherId in this.tribes.tribes) {
                         if (tid < otherId) { // Draw each bond only once
                             let tribe1 = this.tribes.tribes[tid];
                             let tribe2 = this.tribes.tribes[otherId];
                             let n1 = this.tribes.nests.find(n => n.tribeId == tid);
                             let n2 = this.tribes.nests.find(n => n.tribeId == otherId);
                             
                             if (n1 && n2) {
                                // Check if at war (draw war bonds first, they should be on top)
                                let isAtWar = (tribe1.atWarWith && tribe1.atWarWith[otherId] === true) || 
                                             (tribe2.atWarWith && tribe2.atWarWith[tid] === true);
                                
                                if (isAtWar) {
                                    // DRAW WAR BOND - Angry red bond with animated particles going both ways
                                    // Use torus distance and direction for proper wrapping
                                    let bondLength = Vector.distTorus(n1.pos, n2.pos, this.width, this.height);
                                    let torusDir = Vector.subTorus(n1.pos, n2.pos, this.width, this.height);
                                    let normalizedDir = bondLength > 0 ? new Vector(torusDir.x / bondLength, torusDir.y / bondLength) : new Vector(0, 0);
                                    
                                    // Draw the war bond line (thick, angry red)
                                    ctx.beginPath();
                                    ctx.moveTo(n1.pos.x, n1.pos.y);
                                    ctx.lineTo(n1.pos.x + torusDir.x, n1.pos.y + torusDir.y);
                                    ctx.strokeStyle = 'rgba(220, 38, 38, 0.9)'; // Angry red
                                    ctx.lineWidth = 5;
                                    ctx.setLineDash([8, 4]); // Dashed for visual effect
                                    ctx.stroke();
                                    ctx.setLineDash([]); // Reset
                                    
                                    // Animated particles moving both ways along the bond
                                    let animOffset = (this.frame * 2) % (bondLength * 2); // Animation speed
                                    let particleSize = 3;
                                    
                                    // Particles moving from n1 to n2 (left to right)
                                    for (let i = 0; i < 3; i++) {
                                        let progress = (animOffset / bondLength + i * 0.33) % 1.0;
                                        if (progress > 0 && progress < 1) {
                                            let px = n1.pos.x + torusDir.x * progress;
                                            let py = n1.pos.y + torusDir.y * progress;
                                            
                                            // Draw particle with trail effect
                                            ctx.fillStyle = 'rgba(255, 100, 100, 0.9)';
                                            ctx.beginPath();
                                            ctx.arc(px, py, particleSize, 0, Math.PI * 2);
                                            ctx.fill();
                                            
                                            // Bright center
                                            ctx.fillStyle = 'rgba(255, 200, 200, 1.0)';
                                            ctx.beginPath();
                                            ctx.arc(px, py, particleSize * 0.5, 0, Math.PI * 2);
                                            ctx.fill();
                                        }
                                    }
                                    
                                    // Particles moving from n2 to n1 (right to left, opposite direction)
                                    for (let i = 0; i < 3; i++) {
                                        let progress = ((1 - animOffset / bondLength) + i * 0.33) % 1.0;
                                        if (progress > 0 && progress < 1) {
                                            let px = n1.pos.x + torusDir.x * progress;
                                            let py = n1.pos.y + torusDir.y * progress;
                                            
                                            // Draw particle with trail effect
                                            ctx.fillStyle = 'rgba(200, 50, 50, 0.9)';
                                            ctx.beginPath();
                                            ctx.arc(px, py, particleSize, 0, Math.PI * 2);
                                            ctx.fill();
                                            
                                            // Bright center
                                            ctx.fillStyle = 'rgba(255, 150, 150, 1.0)';
                                            ctx.beginPath();
                                            ctx.arc(px, py, particleSize * 0.5, 0, Math.PI * 2);
                                            ctx.fill();
                                        }
                                    }
                                    
                                    continue; // Skip other bonds if at war (war bond takes priority)
                                }
                                
                                // Draw Diplomatic Bond (yellow/gold) - LOWERED threshold from 20 to 5
                                let dipBond = tribe1.diplomaticBonds[otherId] || 0;
                                if (dipBond > 5) {
                                 ctx.beginPath();
                                 ctx.moveTo(n1.pos.x, n1.pos.y);
                                 ctx.lineTo(n2.pos.x, n2.pos.y);
                                    let alpha = Math.min(0.8, dipBond / 80); // More visible
                                    ctx.strokeStyle = `rgba(250, 204, 21, ${alpha})`; // Yellow
                                    ctx.lineWidth = Math.min(8, 1 + dipBond / 15); // Thicker for stronger bonds
                                 ctx.stroke();
                                    
                                    // Draw bond strength indicator
                                    if (dipBond > 10) {
                                        let midX = (n1.pos.x + n2.pos.x) / 2;
                                        let midY = (n1.pos.y + n2.pos.y) / 2;
                                        ctx.fillStyle = `rgba(250, 204, 21, ${Math.min(0.9, dipBond / 100)})`;
                                        ctx.font = '10px monospace';
                                        ctx.textAlign = 'center';
                                        ctx.fillText(Math.floor(dipBond), midX, midY - 5);
                                    }
                                }
                                
                                // Draw Commercial Bond (cyan/blue) - LOWERED threshold from 20 to 5
                                let comBond = tribe1.commercialBonds[otherId] || 0;
                                if (comBond > 5) {
                                    ctx.beginPath();
                                    ctx.moveTo(n1.pos.x, n1.pos.y);
                                    ctx.lineTo(n2.pos.x, n2.pos.y);
                                    let alpha = Math.min(0.8, comBond / 80); // More visible
                                    ctx.strokeStyle = `rgba(34, 211, 238, ${alpha})`; // Cyan
                                    ctx.lineWidth = Math.min(8, 1 + comBond / 15); // Thicker for stronger bonds
                                    ctx.setLineDash([5, 5]); // Dashed for commercial
                                    ctx.stroke();
                                    ctx.setLineDash([]); // Reset
                                    
                                    // Draw bond strength indicator
                                    if (comBond > 10) {
                                        let midX = (n1.pos.x + n2.pos.x) / 2;
                                        let midY = (n1.pos.y + n2.pos.y) / 2;
                                        ctx.fillStyle = `rgba(34, 211, 238, ${Math.min(0.9, comBond / 100)})`;
                                        ctx.font = '10px monospace';
                                        ctx.textAlign = 'center';
                                        ctx.fillText(Math.floor(comBond), midX, midY + 10);
                                    }
                                }
                             }
                         }
                     }
                }

                // CRITICAL: Always draw nests every frame - they don't change often and flickering is jarring
                this.tribes.nests.forEach(n => n.draw(this.ctx));
                this.walls.forEach(w => w.draw(this.ctx));
                
                // CRITICAL: Always draw resources every frame - they don't move and flickering is jarring
                this.resources.forEach(r => {
                    if (!r || !r.active) return; // Skip invalid or inactive resources
                    if (r.draw) r.draw(this.ctx);
                    else if (r.type === 'UNIQUE') {
                        // Draw unique resources manually
                        if (!r.config || !r.config.color) return; // Skip if config missing
                        this.ctx.fillStyle = r.config.color;
                        this.ctx.beginPath();
                        this.ctx.arc(r.pos.x, r.pos.y, r.radius, 0, Math.PI * 2);
                        this.ctx.fill();
                        this.ctx.strokeStyle = '#ffffff';
                        this.ctx.lineWidth = 1;
                        this.ctx.stroke();
                    }
                });
                
                // CRITICAL FIX: Always draw all agents every frame to prevent visual jitter
                // Staggered drawing causes agents to appear at different rates, creating jitter
                // We keep staggered updates but ensure all agents draw every frame for smooth visuals
                this.agents.forEach(a => a.draw(this.ctx, a === this.selected));
                this.projectiles.forEach(p => p.draw(this.ctx));
                
                // Draw plagues (infection zones)
                this.plagues.forEach(p => {
                    if (p.life > 0) {
                        // Draw plague as a pulsing green circle
                        let alpha = 0.3 + 0.2 * Math.sin(this.frame * 0.1); // Pulsing effect
                        this.ctx.fillStyle = `rgba(34, 197, 94, ${alpha})`; // Green with transparency
                        this.ctx.beginPath();
                        this.ctx.arc(p.pos.x, p.pos.y, p.radius, 0, Math.PI * 2);
                        this.ctx.fill();
                        // Draw border
                        this.ctx.strokeStyle = `rgba(34, 197, 94, 0.6)`;
                        this.ctx.lineWidth = 2;
                        this.ctx.stroke();
                    }
                });
                
                // PERFORMANCE OPTIMIZATION: Draw particles less frequently when population is high
                let particleDrawInterval = 1;
                let totalAgentsForParticles = this.agents.length;
                if (totalAgentsForParticles > 120) {
                    particleDrawInterval = 2; // Every 2 frames when population is high
                }
                if (this.frame % particleDrawInterval === 0) {
                this.particles.forEach(p => p.draw(this.ctx));
                }

                for (let tid in this.tribes.tribes) {
                    let tribe = this.tribes.tribes[tid];
                    if (!tribe || !tribe.leaderUnderAttack) continue;
                    let attacker = this.agents.find(a => a.id === tribe.leaderUnderAttackTargetId);
                    let leader = this.agents.find(a => a.id === tribe.leaderId);
                    if (!attacker || attacker.dead || !leader || leader.health <= 0 || Vector.dist(attacker.pos, leader.pos) > 500) {
                        tribe.leaderUnderAttack = false;
                        tribe.leaderUnderAttackTargetId = null;
                    }
                }

                // PERFORMANCE OPTIMIZATION: Track frame time for adaptive quality
                let currentFrameTime = performance.now();
                let frameDelta = currentFrameTime - this.lastFrameTime;
                this.lastFrameTime = currentFrameTime;
                
                // Get current agent count
                let currentAgentCount = this.agents.length;
                
                // If agent count dropped significantly (more than 30%), reset frame history and adjust stagger
                // This prevents the system from being stuck in slow mode after agent count decreases
                if (this.lastAgentCount > 0 && currentAgentCount < this.lastAgentCount * 0.7) {
                    // Agent count dropped significantly - reset frame history to allow quick recovery
                    this.frameTimeHistory = [];
                    // Reset stagger size based on current agent count
                    if (currentAgentCount <= 80) {
                        this.updateStaggerSize = 4; // Reset to minimum for low agent count
                    } else if (currentAgentCount <= 120) {
                        this.updateStaggerSize = Math.min(6, this.updateStaggerSize); // Cap at 6
                    } else {
                        this.updateStaggerSize = Math.min(8, this.updateStaggerSize); // Cap at 8
                    }
                }
                this.lastAgentCount = currentAgentCount;
                
                // Track frame time history (keep last 10 frames, but shorter if agent count is low)
                let historyLength = currentAgentCount > 120 ? 10 : 5; // Shorter history when agent count is low
                this.frameTimeHistory.push(frameDelta);
                if (this.frameTimeHistory.length > historyLength) {
                    this.frameTimeHistory.shift();
                }
                
                // Calculate average frame time
                if (this.frameTimeHistory.length > 0) {
                    this.avgFrameTime = this.frameTimeHistory.reduce((a, b) => a + b, 0) / this.frameTimeHistory.length;
                }
                
                // Adaptive quality: Consider both frame time AND agent count
                // If agent count is low, be more aggressive about reducing stagger
                let targetStaggerForCount = 4; // Default
                if (currentAgentCount > 150) {
                    targetStaggerForCount = 12;
                } else if (currentAgentCount > 120) {
                    targetStaggerForCount = 8;
                } else if (currentAgentCount > 80) {
                    targetStaggerForCount = 6;
                }
                
                // Adaptive quality: If frame time is too high, increase stagger size dramatically
                if (this.avgFrameTime > 30) { // > 30ms = < 33fps - CRITICAL
                    this.updateStaggerSize = Math.min(16, this.updateStaggerSize + 2); // Increase stagger aggressively
                } else if (this.avgFrameTime > 25) { // > 25ms = < 40fps
                    this.updateStaggerSize = Math.min(12, this.updateStaggerSize + 1); // Increase stagger
                } else if (this.avgFrameTime < 18) { // < 18ms = > 55fps - good performance
                    // Decrease stagger more aggressively when agent count is low
                    if (currentAgentCount <= 80) {
                        this.updateStaggerSize = Math.max(4, this.updateStaggerSize - 2); // Decrease faster for low count
                    } else if (currentAgentCount <= 120) {
                        this.updateStaggerSize = Math.max(4, this.updateStaggerSize - 1); // Decrease normally
                    } else {
                        // For high agent count, decrease slowly but also consider target for count
                        this.updateStaggerSize = Math.max(targetStaggerForCount, this.updateStaggerSize - 1);
                    }
                }
                
                // Also adjust based on agent count if frame time is reasonable
                if (this.avgFrameTime < 25 && this.updateStaggerSize > targetStaggerForCount) {
                    // Frame time is good but stagger is higher than needed for current agent count
                    this.updateStaggerSize = Math.max(targetStaggerForCount, this.updateStaggerSize - 1);
                }
                
                // CRITICAL: Skip frame entirely if frame time is extremely high (prevent jitter)
                if (this.avgFrameTime > 50) { // > 50ms = < 20fps - skip update entirely
                    this.updateUI();
                    this.frame++;
                    requestAnimationFrame(() => this.loop());
                    return; // Skip this frame's update
                }

                this.updateUI();
                this.frame++;
                
                requestAnimationFrame(() => this.loop());
            }
        }

        function togglePanel(panelId, toggleId, forceOpen) {
            const panel = document.getElementById(panelId);
            const toggle = document.getElementById(toggleId);
            if (!panel || !toggle) return;
            const isOpen = !panel.classList.contains('hidden');
            const shouldOpen = forceOpen === undefined ? !isOpen : Boolean(forceOpen);
            panel.classList.toggle('hidden', !shouldOpen);
            toggle.classList.toggle('hidden', shouldOpen);
        }

        function toggleTribePanel(forceOpen) {
            togglePanel('tribe-panel', 'tribe-toggle-btn', forceOpen);
        }

        function toggleLegendPanel(forceOpen) {
            togglePanel('legend-panel', 'legend-toggle-btn', forceOpen);
        }

        function toggleHUDPanel(forceOpen) {
            const panel = document.getElementById('hud-panel');
            const collapsed = document.getElementById('hud-collapsed-btn');
            if (!panel || !collapsed) return;
            const isOpen = !panel.classList.contains('hidden');
            const shouldOpen = forceOpen === undefined ? !isOpen : Boolean(forceOpen);
            panel.classList.toggle('hidden', !shouldOpen);
            collapsed.classList.toggle('hidden', shouldOpen);
        }

        var sim = new Simulation();
        sim.loop();
        
    </script>
<script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'9a2d63178feb571f',t:'MTc2Mzg2NjUyMC4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
</html>
